{"posts":[{"title":"我的世界服务器","content":"1.Crafting Dead/我的世界服务器生存行尸走肉 玩法： https://space.bilibili.com/686127/favlist?fid=761086911&amp;ftype=collect 下载教程篇: 科技启动器下载地址：https://www.technicpack.net/ 整合包名称：Official Crafting Dead 详见：https://www.bilibili.com/video/BV1Et411b7wn 你可能会遇到： 当你下载完TechnicLauncher，并找到official-crafting-dead，开始下载安装到此步卡住。 ","link":"https://littlebuzi.github.io/mc_online_1"},{"title":"拥有一个浏览器干净的主页","content":"为什么要设置一个干净的主页咋就不说了，饱受其苦， 那么如何设置一个干净的主页呢？主要通过设置默认主页的方式来设置 加载迅速简洁： 百度搜索：https://m.baidu.com/?wpo=btmfast&amp;pu=sz%401321_480&amp;from=1013843a 百度搜索(虽然logo是谷歌)：https://leftshine.gitee.io/viaindex/2/One/index.html https://leftshine.gitee.io/viaindex/quarklike1_43/index.html https://leftshine.gitee.io/viaindex/via-ningjing-3.5/index.html https://leftshine.gitee.io/viaindex/GoodEvening/Good%20evening.html https://leftshine.gitee.io/viaindex/Lazy_Simple/index.html https://leftshine.gitee.io/viaindex/Ya_ke+mod/index.html https://leftshine.gitee.io/viaindex/Star0726/indexDark.html 樱花背景，首次加载较长：https://leftshine.gitee.io/viaindex/2/AniBg/index.html 恶龙：https://leftshine.gitee.io/viaindex/2/mengmeizi/index.html 超简洁：https://leftshine.gitee.io/viaindex/2/One/index.html 新鲜内容： https://www.zhihu.com/question/21744542/answer/292104008 功能强大： 小呆导航：https://www.webjike.com/index.html 关于构想 123 js jquery html python pyqt exe gui java gui js读入json 输出html 做出修改后 js读入变量 保存输出文件 https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js Python-Tkinter图形化界面设计（详细教程）：https://blog.csdn.net/RNG_uzi_/article/details/89792518 参考文献： 自定义简洁浏览器主页：https://www.cnblogs.com/thgpddl/p/12684475.html 有哪些网站适合做浏览器主页：https://www.zhihu.com/question/21744542 页面自动执行（加载）js的几种方法：https://www.cnblogs.com/2huos/p/js-autorun.html 浏览器报错 CORS 请求不是 http：https://blog.csdn.net/zeduan/article/details/104165628/ ","link":"https://littlebuzi.github.io/HomePage"},{"title":"PHP学习路线","content":"免费php学习课程： https://www.imooc.com/course/list?c=php PHP基础篇上、中、下（归纳编辑于）： 已收录： 1.PHP入门篇：https://www.imooc.com/view/54 2.PHP进阶篇：https://www.imooc.com/view/26 未收录： PHP7的基本变量：https://www.imooc.com/learn/1085 PHP+Mysql+Ajax实现分页：https://www.imooc.com/learn/1117 PHP-面向对象：https://www.imooc.com/learn/887 PHP函数篇：https://www.imooc.com/learn/827 PHP扩展安装指南：https://www.imooc.com/learn/757 PHP进阶篇-字符串操作：https://www.imooc.com/learn/726 ","link":"https://littlebuzi.github.io/learn_php"},{"title":"PHP基础学习笔记(下)","content":"一、数据库 数据库操作 PHP通过安装相应的扩展来实现数据库操作 当前主流的数据库有： MsSQL，MySQL，Sybase，Db2，Oracle，PostgreSQL，Access 一般情况下常说的LAMP架构指的是： Linux、Apache、Mysql、PHP if (function_exists('mysql_connect')) { echo 'Mysql扩展已经安装'; } 数据库扩展 数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。 像Mysql常用的扩展有原生的mysql库，可使用增强版的mysqli扩展，或使用PDO进行连接与操作。 不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。 mysql扩展进行数据库连接的方法： $link = mysql_connect('mysql_host', 'mysql_user', 'mysql_password'); mysqli扩展： $link = mysqli_connect('mysql_host', 'mysql_user', 'mysql_password'); PDO扩展： $dsn = 'mysql:dbname=testdb;host=127.0.0.1'; $user = 'dbuser'; $password = 'dbpass'; $dbh = new PDO($dsn, $user, $password); 连接MySQL数据库 指定数据库的地址，用户名及密码。 $host = 'localhost'; $user = 'code1'; $pass = '666'; $link = mysql_connect($host, $user, $pass); 选择一个操作的数据库，mysql_select_db函数选择数据库。 mysql_select_db('code1'); 设置当前连接使用的字符编码，一般使用utf8编码。 mysql_query(&quot;set names 'utf8'&quot;); 执行MySQL查询 采用mysql_query加sql语句的形式向数据库发送查询指令。 $res = mysql_query('select * from user'); 查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 $row = mysql_fetch_array($res); var_dump($row); 默认的，PHP使用最近的数据库连接执行查询， 但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。 $link1 = mysql_connect('127.0.0.1', 'code1', ''); $link2 = mysql_connect('127.0.0.1', 'code1', '', true); //开启一个新的连接 $res = mysql_query('select * from user limit 1', $link1); //从第一个连接中查询数据 插入数据到MySQL $sql = &quot;insert into user(name, age, class) values('李四', 18, '高三一班')&quot;; mysql_query($sql); //执行插入语句 //或 $name = '李四'; $age = 18; $class = '高三一班'; $sql = &quot;insert into user(name, age, class) values('$name', '$age', '$class')&quot;; mysql_query($sql); //执行插入语句 //mysql_insert_id函数可以获取自增的主键id。 $uid = mysql_insert_id(); //可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。 取得数据查询结果 PHP有多个函数可以获取数据集中的一行数据，最常用的是mysql_fetch_array， 可以通过设定参数来更改行数据的下标，默认的会包含数字索引的下标以及字段名的关联索引下标。 $sql = &quot;select * from user limit 1&quot;; $result = mysql_query($sql); $row = mysql_fetch_array($result); 可以通过设定参数MYSQL_NUM只获取数字索引数组，等同于mysql_fetch_row函数， 如果设定参数为MYSQL_ASSOC则只获取关联索引数组，等同于mysql_fetch_assoc函数。 $row = mysql_fetch_row($result); $row = mysql_fetch_array($result, MYSQL_NUM); //这两个方法获取的数据是一样的 $row = mysql_fetch_assoc($result); $row = mysql_fetch_array($result, MYSQL_ASSOC); 如果要获取数据集中的所有数据，我们通过循环来遍历整个结果集。 $data = array(); while ($row = mysql_fetch_array($result)) { $data[] = $row; } 查询分页数据 通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，要构造m与n来实现获取某一页的所有数据。 假定当前页为page，每页显示page，每页显示page，每页显示n条数据，那么m为当前页前面所有的数据， 既m=(m = (m=(page-1) * $n，通过构造SQL语句在PHP中实现数据翻页。 $page = 2; $n = 2; $m = ($page - 1) * $n; $sql = &quot;select * from user limit $m, $n&quot;; $result = mysql_query($sql); //循环获取当前页的数据 $data = array(); while ($row = mysql_fetch_assoc($result)) { $data[] = $row; } 使用m与m与m与n变量来表示偏移量与每页数据条数，但推荐使用更有意义的变量名来表示， 比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。 更新与删除数据 // 更新 $sql = &quot;update user set name = '曹操' where id=2 limit 1&quot;; if (mysql_query($sql)) { echo '更新成功'; } // 删除 $sql = &quot;delete from user where id=2 limit 1&quot;; if (mysql_query($sql)) { echo '删除成功'; } 对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数， 如果数据没有变化，则结果为0。 $sql = &quot;update user set name = '曹操' where id=2 limit 1&quot;; if (mysql_query($sql)) { echo mysql_affected_rows(); } 关闭MySQL连接 mysql_close(); 虽然PHP会自动关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下， 可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。 在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。 $link = mysql_connect($host, $user, $pass); mysql_close($link); PHP+Mysql+Ajax实现分页 https://www.imooc.com/learn/1117 PHP环境LAMP/LNMP安装与配置 LAMP是Linux + Apache/Nginx + Mysql + PHP的简称。 目前，国内外，无论一线互联网企业还是创业公司，LAMP都是Web开发的主流，以其高性能、特稳定、开源免费等特性闻名于世。 https://www.imooc.com/learn/703 扩展学习： PHP进阶篇-GD库图像处理：http://www.imooc.com/learn/701 来源：慕课网，内容持续更新中... ","link":"https://littlebuzi.github.io/learn_php_3"},{"title":"PHP基础学习笔记(中)","content":" 本文章是继PHP基础学习笔记（上）的下篇，主要记录php基础知识，资源整合自慕课网。 一、数组定义 数组就是一个键值对组成的语言结构，键类似于酒店的房间号，值类似于酒店房间里存储的东西。 $arr = array(); 表示创建一个空数组，并把创建的空数组赋值给变量$arr。 索引数组初始化 PHP有两种数组：索引数组、关联数组。 索引和关联两个词都是针对数组的键而言的。 索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 fruit |香蕉|苹果|雪梨| |:-|:-:|-:| |0|1|2| $fruit = array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;); print_r($fruit); 索引数组赋值 赋值有三种方式: $arr[0]='苹果'; array('0'=&gt;'苹果'); $arr = array('0'=&gt;'苹果'); if( isset($arr) ) {print_r($arr);} isset（） 函数是检查 括号内的是否被定义了，定义为null 也表示true。 索引数组内容 $fruit = array('苹果','香蕉'); $fruit0 = $fruit['0']; print_r($fruit0);//结果为苹果 循环访问索引数组里的值 $fruit=array('苹果','香蕉','菠萝'); // for循环 for($i=0; $i&lt;3; $i++){ echo '&lt;br&gt;数组第'.$i.'值是：'.$fruit[$i]; } //foreach循环 foreach($fruit as $key=&gt;$value){ echo '&lt;br&gt;第'.$key.'值是：'; } 关联数组初始化 // 创建一个关联数组，关联数组的键“orange”，值是“橘子” $fruit = array( // 关联数组赋值 'apple'=&gt;&quot;苹果&quot;, 'banana'=&gt;&quot;香蕉&quot;, 'pineapple'=&gt;&quot;菠萝&quot; ); // 访问关联数组内容 $fruit0 = $fruit['banana']; print_r($fruit0); // foreach循环访问关联数组里的值 foreach($fruit as $k=&gt;$v){ echo '&lt;br&gt;水果的英文键名：'.$k.'，对应的值是：'.$v; 二、类和对象 类是面向对象程序设计的基本概念，通俗的理解类就是对现实中某一个种类的东西的抽象。 如汽车可以抽象为一个类， 属性：名字、轮胎、速度、重量等， 操作方法：换挡、前进、后退等。 // 定义一个汽车类的方法为 class Car { $name = '汽车'; //定义属性 function getName() { //定义方法 return $this-&gt;name; //方法内部可以使用$this伪变量调用对象的属性或者方法 } } // 类是一类东西的结构描述，而对象则是一类东西的一个具体实例， // 例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。 // 对象通过new关键字进行实例化： $car = new Car(); $car-&gt;name = '奥迪A6'; //设置对象的属性值 echo $car-&gt;getName(); //调用对象的方法 输出对象的名字 //也可以采用变量来创建 $className = 'Car'; $car = new $className(); //类与对象看起来比较相似，但实际上有本质的区别， //类是抽象的概念，对象是具体的实例。 //类可以使程序具有可重用性。 对象之类的属性 在类中定义的变量称之为属性， 通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。 属性声明是由以下关键字开头。 public：公开的 protected：受保护的 private：私有的 class Car { //定义公共属性 public $name = '汽车'; //定义受保护的属性 protected $color = '白色'; //定义私有属性 private $price = '100000'; } 默认都为public，外部可以访问。 一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。 当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。 $car = new Car(); echo $car-&gt;name; //调用对象的属性 echo $car-&gt;color; //错误 受保护的属性不允许外部调用 echo $car-&gt;price; //错误 私有属性不允许外部调用 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。 class Car{ private $price = '1000'; public function getPrice() { return $this-&gt;price; //内部访问私有属性 ​ } } 定义类的方法 方法就是在类中的function，很多时候我们分不清方法与函数有什么差别， 在面向过程的程序设计中function叫做函数，在面向对象中function则被称之为方法。 同属性一样，类的方法也具有public，protected 以及 private 的访问控制。 被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的类成员则只能被其定义所在的类访问。 class Car { public function getName() { return '汽车'; } ​} $car = new Car(); echo $car-&gt;getName(); 使用关键字static修饰的，称之为静态方法。 静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。 class Car { public static function getName() { return '汽车'; } ​} echo Car::getName(); //结果为“汽车” // 静态方法也可以通过变量来进行动态调用 $func = 'getSpeed'; $className = 'Car'; echo $className::$func(); //动态调用静态方法 静态方法中，$this伪变量不允许使用。 可以使用self，parent，static在内部调用静态方法与属性。 class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } public static function speedUp() { return self::$speed+=10; } } class BigCar extends Car { public static function start() { parent::speedUp(); } } BigCar::start(); echo BigCar::getSpeed(); 车辆加速 class Car { private static $speed = 10; public function getSpeed() { return self::$speed; } //在这里定义一个静态方法，实现速度累加10 public static function speedUp() { return self::$speed+=10; } } $car = new Car(); Car::speedUp(); //调用静态方法加速 echo $car-&gt;getSpeed(); //调用共有方法输出当前的速度值 构造函数和析构函数 __construct()定义一个构造函数，具有构造函数的类， 会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。 class Car { function __construct() { print &quot;构造函数被调用\\n&quot;; } } $car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串 在子类中如果定义了__construct则不会调用父类的__construct， 如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。 class Car { function __construct() { print &quot;父类构造函数被调用\\n&quot;; } } class Truck extends Car { function __construct() { print &quot;子类构造函数被调用\\n&quot;; parent::__construct(); } } $car = new Truck(); 同样，PHP5支持析构函数，使用__destruct()进行定义, 析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。 class Car { function __construct() { print &quot;构造函数被调用 \\n&quot;; } function __destruct() { print &quot;析构函数被调用 \\n&quot;; } } $car = new Car(); //实例化时会调用构造函数 echo '使用后，准备销毁car对象 \\n'; unset($car); //销毁时会调用析构函数 当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。 访问控制 类属性必须定义为公有、受保护、私有之一。 为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。 class Car { $speed = 10; //错误 属性必须定义访问控制 public $name; //定义共有属性 } 类中的方法可以被定义为公有、私有或受保护。 如果没有设置这些关键字，则该方法默认为公有。 class Car { ​ //默认为共有方法 function turnLeft() { } } 如果构造函数定义成了私有方法，则不允许直接实例化对象了， 这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建， 比如单例模式只允许有一个全局唯一的对象。 class Car { private function __construct() { echo 'object create'; } private static $_object = null; public static function getInstance() { if (empty(self::$_object)) { self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象 } return self::$_object; } } //$car = new Car(); //这里不允许直接实例化对象 $car = Car::getInstance(); //通过静态方法来获得一个实例 对象继承 继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类， 除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法， 可以采用继承汽车类来共享这些属性与方法，实现代码的复用。 class Car { public $speed = 0; //汽车的起始速度是0 public function speedUp() { $this-&gt;speed += 10; return $this-&gt;speed; } } //定义继承于Car的Truck类 class Truck extends Car { public function speedUp(){ $this-&gt;speed = parent::speedUp() + 50; } } $car = new Truck(); $car-&gt;speedUp(); echo $car-&gt;speed; //结果：60 重载 PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。 __set，对不存在属性赋值 __get，对不存在属性读取 __isset，判断属性是否设置 __unset，销毁属性 方法的重载通过__call来实现，当调用不存在的方法的时候， 将会转为参数调用__call方法，当调用不存在的静态方法时会使用__callStatic重载。 class Car { public $speed = 10; //在这里使用重载实现speedDown方法 public function __call($name, $args) { if ($name == 'speedDown') { $this-&gt;speed -= 10; } } } $car = new Car(); $car-&gt;speedDown(); //调用不存在的speedDown方法 echo $car-&gt;speed; // $name 参数是要调用的方法名称。 // $arg 参数是一个枚举数组，包含着要传递给方法 $name 的参数。 // 所有的重载方法都必须被声明为 public。 //这些魔术方法的参数都不能通过引用传递。 //属性重载只能在对象中进行。在静态方式中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。 详细：https://www.imooc.com/code/546 高级特性 class Car { public $name = 'car'; public function __clone() { $obj = new Car(); $obj-&gt;name = $this-&gt;name; } } $a = new Car(); $a-&gt;name = 'new car'; $b = clone $a; if ($a == $b) echo '=='; //true if ($a === $b) echo '==='; //false $str = serialize($a); //对象序列化成字符串 echo $str.'&lt;br&gt;'; $c = unserialize($str); //反序列化为对象 var_dump($c); 详细：https://www.imooc.com/code/547 三、正则表达式 正则表达式是对字符串进行操作的一种逻辑公式， 就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。 $p = '/apple/'; $str = &quot;apple banna&quot;; if (preg_match($p, $str)) { echo 'matched'; } 其中字符串'/apple/'就是一个正则表达式，用于匹配源字符串中是否存在apple字符串。 PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配， 常用来判断一类字符模式是否存在。 基本语法 PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如： /foo bar/ #^[^0-9]$# ~php~ //如果模式中包含分隔符，则分隔符需要使用反斜杠（\\）进行转义。 /http:\\/\\// //如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。 $p = 'http://'; $p = '/'.preg_quote($p, '/').'/'; echo $p; //分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等， //例如使用i修饰符可以忽略大小写匹配： $str = &quot;Http://www.imooc.com/&quot;; if (preg_match('/http/i', $str)) { echo '匹配成功'; } // 忽略大小写匹配BBC $p = '/bbc/i'; $str = &quot;BBC是英国的一个电视台&quot;; if (preg_match($p, $str)) { echo '匹配成功'; } 元字符与转义 正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有： \\ 一般用于转义字符 ^ 断言目标的开始位置(或在多行模式下是行首) $ 断言目标的结束位置(或在多行模式下是行尾) . 匹配除换行符外的任何字符(默认) [ 开始字符类定义 ] 结束字符类定义 | 开始一个可选分支 ( 子组的开始标记 ) 子组的结束标记 ? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词) 量词，0 次或多次匹配 量词，1 次或多次匹配 { 自定义量词开始标记 } 自定义量词结束标记 //下面的\\s匹配任意的空白符，包括空格，制表符，换行符。[\\s]代表非空白符。[\\s]+表示一次或多次匹配非空白符。 $p = '/^我[^\\s]+(苹果|香蕉)$/'; $str = &quot;我喜欢吃苹果&quot;; if (preg_match($p, $str)) { echo '匹配成功'; } 元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有： \\ 转义字符 ^ 仅在作为第一个字符(方括号内)时，表明字符类取反 标记字符范围 其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。 //下面的\\w匹配字母或数字或下划线。 $p = '/[\\w\\.\\-]+@[a-z0-9\\-]+\\.(com|cn)/'; $str = &quot;我的邮箱是Spark.eric@imooc.com&quot;; preg_match($p, $str, $match); echo $match[0]; //匹配str中的电话 $p = '/\\d+\\-\\d+/'; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; 贪婪模式与懒惰模式 正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符， 但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。 贪婪模式：在可匹配与可不匹配的时候，优先匹配 //下面的\\d表示匹配数字 $p = '/\\d+\\-\\d+/'; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 懒惰模式：在可匹配与可不匹配的时候，优先不匹配 $p = '/\\d?\\-\\d?/'; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：0-1 当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数 $p = '/\\d{3}\\-\\d{8}/'; $str = &quot;我的电话是010-12345678&quot;; preg_match($p, $str, $match); echo $match[0]; //结果为：010-12345678 匹配str中的姓名 $p = '/name:([\\w\\s]+)/'; $str = &quot;name:steven jobs&quot;; preg_match($p, $str, $match); echo $match[1]; //结果为：steven jobs 正则表达式匹配 //正则匹配，并输出邮箱地址,匹配email的方法还有有很多 $subject = &quot;my email is spark@imooc.com&quot;; $pattern = '/[\\w\\-]+@\\w+\\.\\w+/'; preg_match($pattern, $subject, $matches); echo $matches[0]; 详细：https://www.imooc.com/code/562 查找所有匹配结果 preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果， preg_match_all可以循环获取一个列表的匹配结果数组。 $str = &quot;&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;/ul&gt;&quot;; //在这里补充代码，实现正则匹配所有li中的数据 $p = &quot;/&lt;li&gt;(.*)&lt;\\/li&gt;/i&quot;;//解释下这个正则： //后面的i表示不区分大小写，&lt;li&gt;(.*?)&lt;\\/li&gt;表示li标签内的匹配的()内的值有多少， 括号内的.表示所有单字符,*表示数量为0个或者多个。也就是li标签内有字符就显示出来 preg_match_all($p, $str, $matches); print_r($matches[1]); 结果： Array ( [0] =&gt; item 1 [1] =&gt; item 2 ) 详细：https://www.imooc.com/code/563 正则表达式的搜索和替换 $str = '主要有以下几个文件：index.php, style.css, common.js'; //将目标字符串$str中的文件名替换后增加em标签 $p = '/\\w+\\.\\w+/i'; $str = preg_replace($p, '&lt;em&gt;$0&lt;/em&gt;', $str); echo $str; 结果： 主要有以下几个文件：index.php, style.css, common.js 常用案例 $user = array( 'name' =&gt; 'spark1985', 'email' =&gt; 'spark@imooc.com', 'mobile' =&gt; '13312345678' ); //进行一般性验证 if (empty($user)) { die('用户信息不能为空'); } if (strlen($user['name']) &lt; 6) { die('用户名长度最少为6位'); } //用户名必须为字母、数字与下划线 if (!preg_match('/^\\w+$/i', $user['name'])) { die('用户名不合法'); } //验证邮箱格式是否正确 if (!preg_match('/^[\\w\\.]+@\\w+\\.\\w+$/i', $user['email'])) { die('邮箱不合法'); } //手机号必须为11位数字，且为1开头 if (!preg_match('/^1\\d{10}$/i', $user['mobile'])) { die('手机号不合法'); } echo '用户信息验证成功'; 四、cookie Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。 一般情况下，Cookie通过HTTP headers从服务端返回到客户端。 多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中， 所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。 PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE['key']的形式来读取某个Cookie值。 PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。 setcookie('test', time()); ob_start(); print_r($_COOKIE); $content = ob_get_contents(); $content = str_replace(&quot; &quot;, '&amp;nbsp;', $content); ob_clean(); header(&quot;content-type:text/html; charset=utf-8&quot;); echo '当前的Cookie为：&lt;br&gt;'; echo nl2br($content); 设置cookie PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数， 我们常用到的为前5个： name（ Cookie名）可以通过$_COOKIE['name'] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为'/'，则整个网站都有效 domain（有效域）默认整个域名都有效，如果设置了'www.imooc.com',则只在www子域中有效 $value = 'test'; setcookie(&quot;TestCookie&quot;, $value); setcookie(&quot;TestCookie&quot;, $value, time()+3600); //有效期一小时 setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样， 唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 setrawcookie('cookie_name', rawurlencode($value), time()+60*60*24*365); 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 header(&quot;Set-Cookie:cookie_name=value&quot;); 设置一个名为test的Cookie $value = time(); setcookie('test', $value); if (isset($_COOKIE['test'])) { echo 'success'; } 删除与过期时间 setcookie('test', time()); //在这里试着删除test的cookie值 setcookie('test', '', time()-1); var_dump($_COOKIE); 将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。 之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂， 实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。 了解原理以后，我们也可以直接通过header来删除cookie。 header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate('D, d M Y H:i:s \\G\\M\\T', time()-1)); 这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。 有效路径 cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为'/'， 在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如： setcookie('test', time(), 0, '/path'); 上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。 一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径， 这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。 当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。 setcookie('test', '1',0, '/path'); var_dump($_COOKIE['test']); session与cookie的异同 cookie将数据存储在客户端，建立起用户与服务器之间的联系， 通常可以解决很多问题，但是cookie仍然具有一些局限： cookie相对不是太安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k 每次请求都要进行网络传输，占用带宽 session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。 使用session //先执行session_start方法开启session session_start(); //设置一个session，然后通过全局变量$_SESSION进行session的读写 $_SESSION['test'] = time(); //显示当前的session_id echo &quot;session_id:&quot;.session_id(); echo &quot;&lt;br&gt;&quot;; //读取session值 echo $_SESSION['test']; // var_dump($_SESSION); //删除与销毁一个session unset($_SESSION['test']); echo &quot;&lt;br&gt;&quot;; var_dump($_SESSION); //如果要删除所有的session，可以使用session_destroy函数销毁当前session， //session_destroy会删除所有数据，但是session_id仍然存在。 session_start(); $_SESSION['name'] = 'jobs'; $_SESSION['time'] = time(); session_destroy(); //session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候， //$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。 session_start(); $_SESSION['name'] = 'jobs'; $_SESSION['time'] = time(); unset($_SESSION); session_destroy(); var_dump($_SESSION); //此时已为空 //如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到， //则还需要显式的调用setcookie方法删除session_id的cookie值。 session会自动的对要设置的值进行encode与decode， 因此session可以支持任意数据类型，包括数据与对象等。 session_start(); SESSION[′ary′]=array(′name′=&gt;′jobs′);_SESSION[&#x27;ary&#x27;] = array(&#x27;name&#x27; =&gt; &#x27;jobs&#x27;); S​ESSION[′ary′]=array(′name′=&gt;′jobs′);_SESSION['obj'] = new stdClass(); var_dump($_SESSION); 默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题， session来存储用户的登录信息 session可以用来存储多种类型的数据，因此具有很多的用途， 常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。 用户在登录成功以后，通常可以将用户的信息存储在session中， 一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。 $_SESSION['uid'] = $userinfo['uid']; $_SESSION['userinfo'] = $userinfo; 一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中， 他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型， 同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 session_start(); //假设用户登录成功获得了以下用户数据 $userinfo = array( 'uid' =&gt; 10000, 'name' =&gt; 'spark', 'email' =&gt; 'spark@imooc.com', 'sex' =&gt; 'man', 'age' =&gt; '18' ); header(&quot;content-type:text/html; charset=utf-8&quot;); /* 将用户信息保存到session中 */ $_SESSION['uid'] = $userinfo['uid']; $_SESSION['name'] = $userinfo['name']; $_SESSION['userinfo'] = $userinfo; //* 将用户数据保存到cookie中的一个简单方法 */ $secureKey = 'imooc'; //加密密钥 $str = serialize($userinfo); //将用户信息序列化 //用户信息加密前 $str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB)); //用户信息加密后 //将加密后的用户数据存储到cookie中 setcookie('userinfo', $str); //当需要使用时进行解密 $str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB); $uinfo = unserialize($str); echo &quot;解密后的用户信息：&lt;br&gt;&quot;; print_r($uinfo); 结果： 解密后的用户信息： Array ( [uid] =&gt; 10000 [name] =&gt; spark [email] =&gt; spark@imooc.com [sex] =&gt; man [age] =&gt; 18 ) 五、文件系统 读取文件内容 $content = file_get_contents('./test.txt'); // file_get_contents，可以将整个文件全部读取到一个字符串中 $content = file_get_contents('./test.txt', null, null, 100, 500); //可通过参数控制读取内容的开始点以及长度。 echo $content; PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法， fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。 $fp = fopen('./text.txt', 'rb'); while(!feof($fp)) { echo fgets($fp); //读取一行 } fclose($fp); $fp = fopen('./text.txt', 'rb'); $contents = ''; while(!feof($fp)) { $contents .= fread($fp, 4096); //一次读取4096个字符 } fclose($fp); 使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。 判断文件是否存在 is_file与file_exists. file_exists: //判断文件是否存在，同时也可以判断目录是否存在 $filename = './test.txt'; if (file_exists($filename)) { echo file_get_contents($filename); } is_file: //is_file是确切的判断给定的路径是否是一个文件,从函数名可以看出 $filename = './test.txt'; if (is_file($filename)) { echo file_get_contents($filename); } is_readable与is_writeable更加精确 在文件是否存在的基础上，判断文件是否可读与可写。 //可写 $filename = './test.txt'; if (is_writeable($filename)) { file_put_contents($filename, 'test'); } //可读 if (is_readable($filename)) { echo file_get_contents($filename); } 取得文件的修改时间 文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。 fileowner：获得文件的所有者 filectime：获取文件的创建时间 filemtime：获取文件的修改时间 fileatime：获取文件的访问时间 其中最常用的是文件的修改时间，通过文件的修改时间， 可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。 mtime=filemtime(mtime = filemtime(mtime=filemtime(filename); echo '修改时间：'.date('Y-m-d H:i:s', filemtime($filename)); $filename = '/data/webroot/usercode/code/resource/test.txt'; echo '所有者：'.fileowner($filename).'&lt;br&gt;'; echo '创建时间：'.filectime($filename).'&lt;br&gt;'; echo '修改时间：'.filemtime($filename).'&lt;br&gt;'; echo '最后访问时间：'.fileatime($filename).'&lt;br&gt;'; //给$mtime赋值为文件的修改时间 $mtime = filemtime($filename); //通过计算时间差 来判断文件内容是否有效 if (time() - $mtime &gt; 3600) { echo '&lt;br&gt;缓存已过期'; } else { echo file_get_contents($filename); } 取得文件的大小 $filename = '/data/webroot/usercode/resource/test.txt'; echo filesize($filename); //没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和， //因此需要通过递归的方法来循环计算目录的大小。 详细：https://www.imooc.com/code/578 写入内容到文件 $filename = '/data/webroot/usercode/code/test2.txt'; $fp = fopen($filename, 'w'); fwrite($fp, 'hello world'); fclose($fp); // 或者 $fp = fopen('./test.txt', 'w'); fwrite($fp, 'hello'); fwrite($fp, 'world'); fclose($fp); 删除文件 跟Unix系统命令类似，PHP使用unlink函数进行文件删除。 unlink($filename); 删除文件夹使用rmdir函数，文件夹必须为空，如果不为空或者没有权限则会提示失败。 rmdir($dir); 如果文件夹中存在文件，可以先循环删除目录中的所有文件，然后再删除该目录，循环删除可以使用glob函数遍历所有文件。 foreach (glob(&quot;*&quot;) as $filename) { unlink($filename); } 六、异常处理 从PHP5开始，PHP支持异常处理，异常抛出之后，后面的代码将不会再被执行。 当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。 基本语法 try{ //可能出现错误或异常的代码 //catch表示捕获，Exception是php已定义好的异常类 } catch(Exception $e){ //对异常处理，方法： //1、自己处理 //2、不处理，将其再次抛出 } //每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;，当然可以对应多个&quot;catch&quot; //Catch - &quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象。 创建可抛出一个异常的函数 function checkNum($number){ if($number&gt;1){ throw new Exception(&quot;异常提示-数字必须小于等于1&quot;); } return true; } //在 &quot;try&quot; 代码块中触发异常 try{ checkNum(2); //如果异常被抛出，那么下面一行代码将不会被输出 echo '如果能看到这个提示，说明你的数字小于等于1'; }catch(Exception $e){ //捕获异常 echo '捕获异常: ' .$e-&gt;getMessage(); } 检测文件是否存在 $filename = 'test.txt'; try { if (!file_exists($filename)) { throw new Exception('文件不存在'); } } catch(Exception $e) { echo $e-&gt;getMessage(); } 异常处理类 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容 code 异常代码 file 抛出异常的文件名 line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息 getTraceAsString 获取异常追踪信息的字符串 getMessage 获取出错信息 class MyException extends Exception { function getInfo() { return '自定义错误信息'; } } try { throw new MyException('error'); } catch(Exception $e) { echo $e-&gt;getInfo(); } 详细：https://www.imooc.com/code/601 捕获异常信息 在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常， 抛出异常，可以保障程序的正确性与安全，避免导致不可预知的bug。 //一般的异常处理流程代码为： try { throw new Exception('wrong'); } catch(Exception $ex) { echo 'Error:'.$ex-&gt;getMessage().'&lt;br&gt;'; echo $ex-&gt;getTraceAsString().'&lt;br&gt;'; } echo '异常处理后，继续执行其他代码'; 获取错误发生的所在行 在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。 通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题。 try { throw new Exception('wrong'); } catch(Exception $ex) { $msg = 'Error:'.$ex-&gt;getMessage().&quot;\\n&quot;; $msg.= $ex-&gt;getTraceAsString().&quot;\\n&quot;; $msg.= '异常行号：'.$ex-&gt;getLine().&quot;\\n&quot;; $msg.= '所在文件：'.$ex-&gt;getFile().&quot;\\n&quot;; //将异常信息记录到日志中 PHP异常处理之 file_put_contents('error.log', $msg); } 扩展学习： PHP进阶篇-函数 ：http://www.imooc.com/learn/737 PHP进阶篇-日期时间函数：http://www.imooc.com/learn/698 来源：慕课网，内容持续更新中... ","link":"https://littlebuzi.github.io/learn_php_2"},{"title":"PHP基础学习笔记(上)","content":" 学习一门新的计算机语言，对于基础基础不能丢三落四、模凌两可，这是一定要过关的。这对于以后遇到问题，能事半功倍，快人一步。不然会处处碰壁，事倍功半。假如你不是特别优秀的人，那可以选择像我一样，重复再重复吧，加油💪~ 一、符号 单引号括，双引号都可以用: &lt;?php echo &quot;Hi,imooc！&quot;;?&gt; &lt;?php echo 'Hi,imooc！';?&gt; 连接符（.）： &lt;?php echo 'Hi,'.'imooc!';?&gt; php在这一点比较特殊，其它语言中是用加号（+）来表示的，比如：JavaScirpt、Asp、C。 结尾要加分号： （;）分号;一定在半角状态下输入。 注释语句: PHP：// 注释语句 Html：&lt;!--注释语句--&gt; CSS：/*注释语句*/ 注释语句可以在PHP程序的任意位置（但注释语句一定要写在<?php ?>之间）。 二、变量 定义&amp;输出： $var_name = &quot;苹果&quot;; $n = 10; var_dump($var_name); var_dump($n); 命名规则 1.变量名必须以字母或下划线 “_”开头， &quot;$_name&quot;√ &quot;$name&quot; √ &quot;$name2&quot;√ &quot;$9name&quot;× 2.由字母、数字、“_”、汉字组成。 &quot;$_qq&quot;√ &quot;$qq308&quot;√ &quot;$my_apple&quot;√ &quot;$name我等&quot; √ &quot;$name*&quot;× (不允许符号) &quot;$666&quot;× (不允许纯数字) &quot;$my apple&quot;× (不允许空格) 格式 1.下划线法：$my_apple 2.驼峰命名法：$myApple 3.在PHP中变量名是区分大小写， “$my_book” “$my_Book” 代表两个不同的变量。 变量的数据类型 php支持八种原始类型： 1.四种标量类型： boolean 布尔型 ①只有两个值，一个是TRUE，另一个FALSE。即为是或否/真或假。 ②不区分大小写， &quot;TRUE&quot; = &quot;true &quot; ③主要用在条件结构。 ④用”echo”输出时，“true”则输出“1”，“false”不输出。 所以需要注意变量的类型，“1”可能是整型也可能是true，所以需要var_dump输出一下， 如：https://www.imooc.com/code/745 integer 整型 $data_int = 123; // 十进制数 ，123 $data_int = -123; // 一个负数 ，-123 $data_int = 0123; // 八进制数（等于十进制的 83） ，83 $data_int = 0x123; // 十六进制数（等于十进制的 26） ，291 // 十进制、八进制（数字前“0”）、十六进制（数字前“0x”）。(0是阿拉伯数字0，不是英文字母&quot;欧/o&quot;) float 浮点型（也称double） $num_float = 1.234; //小数点 ，1.234 $num_float = 1.2e3; //科学计数法，小写e ，1200 $num_float = 7.0E-10; //科学计数法，大写E ，0.007 // 支持小数点、科学计数法小写的e，大写的E表示。 string (字符串) “$str_string1 = '我是字符串';” // 字符和字节一样，所以一共有256种不同字符的可能性。 // 三种方法定义：单引号形式、双引号形式和Heredoc结构形式。 // 单双引号嵌入与转义符“\\” $str_string1 = '甲问：&quot;你在哪里学的PHP？&quot;'; $str_string2 = &quot;乙毫不犹豫地回答：'当然是慕课网咯！'&quot;; $str_string3 = '甲问:\\'能告诉我网址吗？\\''; $str_string4 = &quot;乙答道:\\&quot;www.imooc.com\\&quot;&quot;; // 美元符号标识的变量与单双引号 $love = &quot;I love you!&quot;; $string1 = &quot;慕课网,$love&quot;; 输出：慕课网,I love you! $string2 = '慕课网,$love'; 输出：慕课网,$love // Heredoc结构形式，很长的字符串 $string1 = &lt;&lt;&lt;GOD 我有一只小毛驴，我从来也不骑。 有一天我心血来潮，骑着去赶集。 我手里拿着小皮鞭，我心里正得意。 不知怎么哗啦啦啦啦，我摔了一身泥. GOD; 2.两种符合类型： array 数组 object 对象 3.特殊类型： resource 资源 资源是由专门的函数来建立和使用的， // 例如打开文件、数据连接、图形画布。 $file=fopen(&quot;f.txt&quot;,&quot;r&quot;); //打开文件 $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); //连接数据库 $img=imagecreate(100,100);//图形画布 // 对资源进行创建、使用和释放 $file_handle = fopen(&quot;/data/webroot/resource/php/f.txt&quot;,&quot;r&quot;); if ($file_handle){ //接着采用while循环（后面语言结构语句中的循环结构会详细介绍）一行行地读取文件，然后输出每行的文字 while (!feof($file_handle)) { //判断是否到最后一行 $line = fgets($file_handle); //读取一行文本 echo $line; //输出一行文本 echo &quot;&lt;br /&gt;&quot;; //换行 } } fclose($file_handle);//关闭文件 // 任何资源，在不需要的时候应该被及时释放。 // 忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。 null NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值， ①当被赋值为NULL：var1 = null;/var1 = NULL; ②或者尚未被赋值：var_dump(var2);③或者被unset()：var2); ③或者被unset()：var2);③或者被unset()：var3 = &quot;节日快乐！&quot;;unset($var3); 这三种情况下变量被认为为NULL。 变量占用内存 echo $m1 = memory_get_usage(); // 获取当前PHP消耗的内存，结果：624432， // 在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），分成几种数据类型。 详见：https://www.imooc.com/code/743 三、常量 常量可以理解为值不变的量（如圆周率）； 或者是常量值被定义后，在脚本的其他任何地方都不可以被改变。分为自定义常量和系统常量 自定义常量 根据我们开发的需要，而定义的常量，它通过使用PHP中的函数define()定义。 （注：函数，我们可以理解为一个混凝土搅拌机，亦或是一个筛子，通过入口提供原料，然后出口产出结果，在函数中也允许入口不提供任何数据，出口也允许不返回任何值。） // define()函数的语法格式为(3个参数)： bool define(string $constant_name, mixed $value[, $case_sensitive = true]) //“constant_name”为必选参数，常量名称,即标志符，常量的命名规则与变量的一致，但是要注意哦，它可不带美元符号哦。 //“value”为必选参数，它是常量的值。 //“case_sensitive”为可选参数，指定是否大小写敏感，设定为true表示不敏感，一般不指定第三个参数的情况下，默认第三个参数的值为false。 注： string表示参数类型为字符串类型， mixed表示参数类型可以接受为多种不同的类型， case_sensitive = true表示默认为布尔类型TRUE 如： $p = &quot;PII&quot;; define(&quot;PI&quot;,3.14); define($p,3.14); echo PI; echo &quot;&lt;br /&gt;&quot;; echo PII; 结果： 3.14 3.14 常量的作用 常量主要功效是可以避免重复定义，篡改变量值。在我们进行团队开发时，或者代码量很大的时候，对于一些第一次定义后不改变的量，如果我们使用变量，在不知情的情况下，使用同一变量名时，变量值就会被替换掉，从而会引发服务器执行错误的任务。 此外，使用常量还能提高代码的可维护性。如果由于某些原因，常量的值需要变更时候，我们只需要修改一个地方。例如在做计算中，起初我们取圆周率为3.14，于是很多计算中我们都使用3.14进行计算，当要求计算精度提高，圆周率需要取3.142的时候，我们不得不修改所有使用3.14的代码，倘若代码量比较多时，不仅工作量大，还可能遗漏。 系统常量 系统常量是PHP已经定义好的常量，我们可以直接拿来使用，常见的系统常量有： echo __FILE__; // php程序文件名。它可以帮助我们获取&quot;当前文件在服务器的物理位置&quot;。 echo __LINE__; // PHP程序文件行数。它可以告诉我们，&quot;当前代码在第几行&quot;。 echo PHP_VERSION; // 当前解析器的版本号。可以提前知道&quot;PHP代码是否可被该PHP解析器解析&quot;。 echo PHP_OS; // 执行当前PHP版本的操作系统名称。&quot;服务器所用的操作系统名称&quot;，可以根据该操作系统优化我们的代码。 常量取值 获取常量值的有两种方法取值。 第一种是使用常量名直接获取值；例如计算圆周率的面积： define(&quot;PI&quot;,3.14); $r=1; $area = PI*$r*$r; //计算圆的面积 第二种是使用constant()函数。它和直接使用常量名输出的效果是一样的， 但函数可以动态的输出不同的常量，在使用上要灵活、方便，其语法格式如下： $p=&quot;&quot;; //定义圆周率的两种取值 define(&quot;PI1&quot;,3.14); define(&quot;PI2&quot;,3.142); //定义值的精度 $height = &quot;中&quot;; //根据精度返回常量名，将常量变成了一个可变的常量 if($height == &quot;中&quot;){ $p = &quot;PI1&quot;; }else if($height == &quot;低&quot;){ $p = &quot;PI2&quot;; } $r=1; echo $p; // 若不使用constant，输出的就是Pi1 $area= constant($p)*$r*$r; echo $area; mixed constant(string constant_name) 第一个参数constant_name为要获取常量的名称，也可为存储常量名的变量。 如果成功则返回常量的值，失败则提示错误信息常量没有被定义。 （注：mixed表示函数返回值类型为多种不同的类型，string表示参数类型为字符串类型） 判定常量是否被定义 如果常量被重复定义以后，PHP解析器会发出“Constant XXX already defined”的警告， 提醒我们该常量已经被定义过。在团队开发，或代码量很大的情况下，如何去判定一个常量是否被定义呢？ defined()函数可以帮助我们判断一个常量是否已经定义，其语法格式为： define(&quot;PI1&quot;,3.14); $p = &quot;PI1&quot;; $is1 = defined($p); $is2 = defined(&quot;PI2&quot;); var_dump($is1); var_dump($is2); 结果： bool(true) bool(false) //其中，赋值给$p目的就是间接来表明PI1已经被定义，所以$is1 = defined(PI1);亦可行。 // define方法是定义一个常量的方法，返回的是该已定义的常量； // defined方法是判断一个常量是否定义，返回的是一个bool值（true/false）。 bool defined(string constants_name) 它只有参数constant_name，指的是要获取常量的名称，若存在则返回布尔类型true，否则返回布尔类型false; （注：bool表示函数返回值类型为布尔类型） 四、运算符 分为算术运算符、赋值运算符、比较运算符、三元运算符、逻辑运算符、字符串连接运算符、错误控制运算符。 算术运算符： 加法运算、减法运算、乘法运算、除法运算 赋值运算符： (1)“=”：把右边表达式的值赋给左边的运算数。它将右边表达式值复制一份，交给左边的运算数。 换而言之，首先给左边的运算数申请了一块内存，然后把复制的值放到这个内存中。 (2)“&amp;”：引用赋值，意味着两个变量都指向同一个数据。 它将使两个变量共享一块内存，如果这个内存存储的数据变了，那么两个变量的值都会发生变化。 $a = &quot;学习PHP！&quot;; $b = $a; $c = &amp;$a; $a = &quot;我天天在学习PHP！&quot;; echo $b.&quot;&lt;br /&gt;&quot;; echo $c.&quot;&lt;br /&gt;&quot;; 结果： 学习PHP！ 我天天在学习PHP！ 比较运算符 三元运算符 (“?:”)三元运算符也是一个比较运算符， 对于表达式(expr1)?(expr2):(expr3)，如果expr1的值为true，则此表达式的值为expr2，否则为expr3。 $a = 78;//成绩 $b = $a &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;; echo $b; 结果：及格 逻辑运算符 1、逻辑与：要求所有人都投票同意，才会通过某协议； 2、逻辑或：只要求一个人投票同意就行； 3、逻辑异或：只能有且只能有一个人投票同意； 4、逻辑非：某个人要反对，但是通过逻辑非，使其反对无效； “与”和“或”有两种不同形式运算符的原因是它们运算的优先级（就是运算的有限顺序，比如我们小学的时候学习四则运算，加减乘除混合在一起啦，优先计算乘除，再计算加减）不同。 字符串连接运算符 （1）连接运算符(“.”)：它返回将右参数附加到左参数后面所得的字符串。 $a = &quot;张先生&quot;; $tip = $a.&quot;,欢迎您在慕课网学习PHP！&quot;; echo $tip.&quot;&lt;br /&gt;&quot;; 结果： 张先生,欢迎您在慕课网学习PHP！ （2）连接赋值运算符(“.=”)：它将右边参数附加到左边的参数后。 $b = &quot;东边日出西边雨&quot;; $b .= &quot;,道是无晴却有晴&quot;; $c = &quot;东边日出西边雨&quot;; $c = $c.&quot;,道是无晴却有晴&quot;; echo $b.&quot;&lt;br /&gt;&quot;; echo $c.&quot;&lt;br /&gt;&quot;; 结果： 东边日出西边雨,道是无晴却有晴 东边日出西边雨,道是无晴却有晴 错误控制运算符 PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉； 如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查。 需要注意的是：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。 $conn = @mysql_connect(&quot;localhost&quot;,&quot;username&quot;,&quot;password&quot;); // 这样就不会报错并打印出来 取整函数 ceil() 函数向上舍入为最接近的整数。 echo(ceil(0.60); echo(ceil(0.40); echo(ceil(5); echo(ceil(5.1); echo(ceil(-5.1); echo(ceil(-5.9)); 输出： 1 1 5 6 -5 -5 五、顺序结构 顺序结构就像一条直线，按着顺序一直往下执行。我们编写的代码默认都是按照顺序结构执行的。 条件结构: if…else… if(条件){ //分配服务器干的任务A }else{ //分配服务器干的任务B } if…else if… if(条件一){ //分配服务器干的任务A }else if(条件二){ //分配服务器干的任务B } if…else if…else… if(条件一){ //分配服务器干的任务A }else if(条件二){ //分配服务器干的任务B }else{ //分配服务器干的任务C } 当两个条件对立时用if…else，当两个条件不存在对立关系时用if…else if… switch…case… switch (条件) { case 条件值一: //任务一 break; case 条件值二: //任务二 break; default: //默认任务 } switch…case…中的break： break的作用是结束switch，亦可以避免冗长的 “if..else if..else”代码块。 //A例子 $num = 2; $sum = 10; switch($num){ case 1: $sum = $sum + 10; break; case 2: $sum = $sum + 10; break; case 3: $sum = $sum + 10; break; default: $sum = $sum + 10; } echo &quot;A例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;; 结果：A例子的值是：20 // 直接查询到num为2，sum加10后即刻break，跳出查找。 //B例子 $num = 2; $sum = 10; switch($num){ case 1: $sum = $sum + 10; case 2: $sum = $sum + 10; case 3: $sum = $sum + 10; default: $sum = $sum + 10; } echo &quot;B例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;; 结果：B例子的值是：40 //查询到num为2后，sum加10，因为没break，继续执行case3，加了10，再执行了defailt。 while循环语句 while(条件){ //执行任务 } 首先判断某个条件是否符合（条件返回值是否为TRUE）， 若符合则执行任务，执行完毕任务，再判断条件是否满足要求，符合则重复执行此任务，否则结束任务。 do while循环语句 do{ //执行任务 }while(条件) 首先执行任务（while语句是先判断条件是否成立，再执行任务），执行任务完毕，判断某个条件是否符合（条件返回值是否为TRUE），若符合则再次执行任务，执行完毕任务，继续判定条件。 while与do…while循环语句的区别： while先判断条件是否成立，后执行循环，do...while先执行一次任务，再判断是否继续执行循环，也就是说do...while至少会执行一次任务。当条件为FALSE时，while中的任务会一次也不执行，do...while中的任务会执行1次。 for循环语句 for(初始化;循环条件;递增项){ //执行任务 } for($i = 1,$i&lt;=100;$i++){ echo &quot;666&quot;; } for 语句中，“初始化”在循环开始前无条件求值一次，“循环条件”在每次循环开始前求值。如果值为 TRUE，则继续循环，执行循环体语句（执行任务）。如果值为 FALSE，则终止循环。“递增项”在每次循环之后被求值（执行）。其常用于循环执行代码块指定的次数。 foreach循环语句 常用于遍历数组，一般有两种使用方式:不取下标、取下标。 //eg $students = array( '2010'=&gt;'令狐冲', ... ... ... ... '2019'=&gt;'宁中则', );//10个学生的学号和姓名，用数组存储 （1）只取值，不取下标 foreach (数组 as 值){ //执行的任务 } //使用循环结构遍历数组,获取学号和姓名 foreach($students as $v) { echo $v;//输出（打印）姓名 echo &quot;&lt;br /&gt;&quot;; } （2）同时取下标和值 foreach (数组 as 下标 =&gt; 值){ //执行的任务 } //使用循环结构遍历数组,获取学号和姓名 foreach($students as $key =&gt;$v) { echo $key.&quot;:&quot;.$v;//输出（打印）学号：姓名 echo &quot;&lt;br /&gt;&quot;; } ?&gt; 结构嵌套 条件嵌套 if里加if， if (条件) { if 条件成立时执行的代码; } elseif (条件) { elseif 条件成立时执行的代码; } else { 条件不成立时执行的代码; } 循环嵌套 常用于遍历二维数组。 $students = array( '2010'=&gt;array('令狐冲',&quot;59&quot;), ... ... ... ... '2019'=&gt;array('宁中则',&quot;90&quot;), );//10个学生的学号、姓名、分数，用数组存储 foreach($students as $key=&gt;$val) { //使用循环结构遍历数组,获取学号 echo $key; //输出学号 echo &quot;:&quot;; //循环输出姓名和分数 foreach($val as $v) { echo $v; } echo &quot;&lt;br /&gt;&quot;; } #循环结构与条件结构嵌套 $students = array( '2010'=&gt;'令狐冲', ... ... ... ... '2019'=&gt;'宁中则', );//10个学生的学号和姓名，用数组存储 $query = '2014'; //使用循环结构遍历数组,获取学号和姓名 foreach($students as $key =&gt;$v) { //使用条件结构，判断是否为该学号 if($key == $query) { echo $v;//输出（打印）姓名 break;//结束循环（跳出循环） } } 在执行任务时，对于一些特殊的任务进行额外处理。 扩展学习： PHP进阶篇-字符串操作：http://www.imooc.com/learn/726 来源：慕课网，内容持续更新中... 为什么有了这么完备的“慕课网学习系统”，还要做个复制粘贴呢？ 1.这是一个笔记，是慕课课程的提炼，为学精一门语言而开辟的一个学习笔记文章。 2.再好的学习平台，也可能会有结束的一天，所以我现在做的事情，可能可以为优秀的平台在茫茫的互联网长河中留下一点点痕迹。 ","link":"https://littlebuzi.github.io/learn_php_1"},{"title":"目前流行的9大前端框架","content":"Vue https://cn.vuejs.org Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 php交互： https://www.cnblogs.com/cc1997/p/10522678.html [Vuejs+php] MySQL数据转JSON传值到前端 React https://react.docschina.org/ React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 Angular https://angular.io AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 QucikUI http://www.uileader.com/product_quickui QucikUI 4.0是一套完整的企业级web前端开发解决方案，由基础框架、UI组件库、皮肤包、示例工程和文档等组成。底层基于jquery构建。使用QucikUI 开发者可以极大地减少工作量，提高开发效率，快速构建功能强大、美观、兼容的web应用系统。 Layui https://www.layui.com/ layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 入门： 开始使用：https://www.layui.com/doc/ 组件：https://www.layui.com/demo/ 详细说明：https://www.layui.com/doc/element/layout.html CDN引入： https://www.layuicdn.com/ 为 Layui 的广大用户提供免费的CDN静态库，非常稳定、快速、免费的 Layui开源组件项目 国内CDN加速服务 PHP交互： https://fly.layui.com/jie/32688/ PHP后台怎么写才能使返回的数据渲染layui表格呢 Avalon http://avalonjs.coding.me/ avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。 Dojo https://dojo.io/ Dojo致力于实现最大的互操作性。Web组件提供了一种机制，可以在Dojo应用程序中利用非Dojo组件，并在非Dojo应用程序中轻松使用基于Dojo的小部件。Dojo为Web组件提供一流的支持。您今天做出的决定不应该将您锁定在未来的决策中。 Ember https://emberjs.com/ Ember.js可能是最固执己见的主流框架，这也是其最大的优势。它有创建Ember.js应用程序的正确方法，通常只有一种方法来创建应用程序。Ember.js更类似于一个产品或平台，在那里你会到一个供应商的长期支持和维护。Ember.js提供了对其平台的全面版本管理，升级工具以及对API升级的强大指导和工具。成熟，是对Ember.js的一个很好的总结。 Aurelia https://aurelia.io/ Aurelia是一个令人惊叹的框架，它在不牺牲功能的情况下采用简单而干净的代码。在本教程中，我们将通过构建“Todo”应用程序向您介绍Aurelia的简单性。您将看到应用程序代码的简洁程度，您将学习Aurelia的几个基本概念和功能。 ","link":"https://littlebuzi.github.io/前端_1"},{"title":"Pytorch预训练的Resnet模型 Danbooru2018","content":"原作者：https://github.com/RF5/danbooru-pretrained 准备环境 Pytorch (&gt;1.0) 提取图片的以下特征： ","link":"https://littlebuzi.github.io/face_4"},{"title":"工具网站","content":"二次元识图工具网站 https://trace.moe/ 找番剧网站，有大量日番资源 优点：找到图片番剧后可实时预览 缺点：只能识别番剧，魔改、加水印、模糊等图片不可用 https://saucenao.com/ 找画网站，接入p站等数据 优点：识别很多画师原创图及同人图 缺点：查找结果为英文、日文、罗马音等。需要借助翻译工具 https://www.baidu.com/ 搜索引擎类，百度谷歌等 优点：可找的范围很广，包括但不限于：动漫、各类MV、影视剧等等，全中文 缺点：结果并不是很精确需要进一步搜索，可能出现奇怪的结果 人肉识别@凉风Kaze[doge] 优点：快 准 狠 缺点：消耗一个三连（误） 各种搜索引擎，某度，某狗，某歌等等…… 优点：谷歌搜索更广更专业 缺点：国内没有，可尝试这个第三方国内版https://gfsoso.fcczp.com/image.html 线上 PDF 工具 https://smallpdf.com/cn/ 优点：功能一应俱全、简单好用 缺点：免费次数有限 ","link":"https://littlebuzi.github.io/amine_reg_1"},{"title":"动漫人物数据集","content":"Danbooru : Danbooru2019： https://www.gwern.net/Danbooru2019 A LARGE-SCALE CROWDSOURCED AND TAGGED ANIME ILLUSTRATION DATASET 一个大规模的众包和标记动画插图数据集 Danbooru2017： https://www.gwern.net/Danbooru2019#danbooru2017 Danbooru2018： https://www.gwern.net/Danbooru2019#danbooru2018 Getchu : (原址需科学上网访问) 百度云： https://pan.baidu.com/s/1bTWoEcJRzXJaMM8jELPCBA CSDN： https://blog.csdn.net/ONE_SIX_MIX/article/details/95935010 github 仓库： https://github.com/One-sixth/getchu_character_picture_grabber Niconico : (仅限于学术目的的图) 需要科研机构申请才可以下载。【放弃~】 nico-opendata：https://nico-opendata.jp/en/index.html At Niconico, we are providing a wide variety of data from our services, to be used for academic purposes. 仅限用于学术目的。 包含： Nico-Illust 超过40万张图像（插图） This dataset contains over 400,000 images (illustraions) from Niconico Seiga and Niconico Shunga. Niconico Seiga is a community for posting illustrations. 一个发布插图的社区。 Niconico Shunga is a community for posting illustrations, where submission of explicit content is allowed. Viewers under age 18 are prohibited in this website. 本网站禁止18岁以下观众观看。 其他： IIIT-CFW https://zhuanlan.zhihu.com/p/25138563 集合了各种类型的数据集（好多没见过的，感觉很全？可能有用，得再看看。）， 比较麻烦的就是得登陆某个网站、再用度盘下载。 各领域公开数据集下载 “整理了一些网上的免费数据集，分类下载地址如下，希望能节约大家找数据的时间。” 真实人脸： VGGFace2 : A large scale image dataset for face recognition http://www.robots.ox.ac.uk/~vgg/data/vgg_face2/index.html#about 9000+身份，330w+图像 ","link":"https://littlebuzi.github.io/dongman_1"},{"title":"PHP、JS、CSS基操","content":" PHP 免费快速学习php PHP入门篇：https://www.imooc.com/learn/54 PHP进阶篇：https://www.imooc.com/learn/26 更多：https://www.imooc.com/search/?words=php PHP环境LAMP/LNMP安装与配置 https://www.imooc.com/learn/703 PHP+Mysql+Ajax实现分页 https://www.imooc.com/learn/1117 PHP生成随机数的几种方法 https://www.cnblogs.com/jjxhp/p/9601147.html PHP 升级到5.5后MySQL的代替法 https://blog.csdn.net/apple_llb/article/details/51406648 php调用exe一直加载怎么回事？ https://ask.csdn.net/questions/231711 还有可能是在exec()后面给予了任务，导致一直加载。 cmd命令语句还在后台运行中，没有黑框弹出来，需等待更长时间。 使用PHP实现用户注册登录的功能 https://github.com/Micanss/PHP-Register-Login ... ... JavaScript 报错TypeError: $(...).live is not a function 解决：用 .on 代替 .live , 旧的版本被替换了 https://blog.csdn.net/qq_36370731/article/details/79016451 报错TypeError: $(…).ajaxForm is not a function 可能： 1.jquery版本和bootstrap冲突 2.同时加载了两次jquery https://stackoverflow.com/questions/35261239/ajaxform-is-not-a-function# 【JavaScript】按钮绑定点击事件-onCliek事件 https://blog.csdn.net/kye055947/article/details/79619538 iframe 自适应高度，更改内容时iframe高度怎么根据新的内容高度自动改变 https://blog.csdn.net/txqd1989/article/details/78551943 ... ... CSS 前端 css input[type=file] 样式美化，input上传按钮美化 https://blog.csdn.net/cuilei210/article/details/78842231 菜鸟教程：CSS 按钮示范 https://www.runoob.com/css3/css3-buttons.html cmd ##运行CMD里面，怎么把得到的结果数据保存为文本文件 https://zhidao.baidu.com/question/596846191.html 用批处理命令获取文件夹名称 创建test.bat，双击运行内容如下： @Echo off dir /b&gt;test.txt https://zhidao.baidu.com/question/936329819153763892.html ","link":"https://littlebuzi.github.io/php_jicao_1"},{"title":"Tensorflow利用inception_v3模型和retrain实现图像分类训练","content":"参考文献： https://blog.csdn.net/ZeyiRTangent/article/details/87886445 #准备： 1.五个分类好存有各自类别的文件夹【文件夹及其内图片的名称全小写，绝对路径名中不能包含中文】 2.inception_v3模型下载，无需解压【http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz】 3.克隆/下载 https://github.com/tensorflow/tensorflow &amp; https://github.com/tensorflow/hub （在~hub-master\\examples\\image_retraining中找到retrain.py文件，待会需要定位文件位置） 。。。 可能遇到的问题： 查看Windows下TensorFlow对python版本的要求 https://blog.csdn.net/sinat_23619409/article/details/84202596 windows10 conda python多版本切换 https://www.cnblogs.com/simuhunluo/p/8540459.html windows 怎么更新 Python 版本（现有 Python 版本装了很多库）卸载重装，工作量就大了，有没有什么直接更新的方式，不会删库那种办法 https://www.v2ex.com/amp/t/477473 conda（anaconda）删除清华源，改回原源 https://blog.csdn.net/qinglingLS/article/details/89363368 PackagesNotFoundError: The following packages are not available from current channels: https://blog.csdn.net/miao0967020148/article/details/85230430 迁移学习关于下载不了inception-v3，自己网络又加载不了的问题 https://blog.csdn.net/nationalline450/article/details/82085007 原址： https://tfhub.dev/google/imagenet/inception_v3/feature_vector/3 出现以下报错： Warning! ***HDF5 library version mismatched error*** The HDF5 header files used to compile this application do not match the version used by the HDF5 library to which this application is linked. Data corruption or segmentation faults may occur if the application continues. This can happen when an application was compiled by one version of HDF5 but linked with a different version of static or shared HDF5 library. You should recompile the application or check your shared library related settings such as 'LD_LIBRARY_PATH'. You can, at your own risk, disable this warning by setting the environment variable 'HDF5_DISABLE_VERSION_CHECK' to a value of '1'. Setting it to 2 or higher will suppress the warning messages totally. Headers are 1.10.4, library is 1.10.5 SUMMARY OF THE HDF5 CONFIGURATION ================================= General Information: ------------------- HDF5 Version: 1.10.5 Configured on: 2019-03-04 ... ... ... ... ... ... Function Stack Tracing: OFF Strict File Format Checks: OFF Optimization Instrumentation: Bye... （多版本导致冲突）pip uninstall h5py Ubuntu: HDF5报错: HDF5 header version与HDF5 library不匹配 https://www.cnblogs.com/platero/p/4077934.html Python环境中HDF5报错：HDF5 library version mismatched error https://blog.csdn.net/zhaoyin214/article/details/104095227 使用conda装完plt/pillow后，错误又出来了，详细看，conda在安装pillow时帮你安装hdf5版本了： 再卸载一次h5py，然后可能提示： ModuleNotFoundError: No module named 'matplotlib' ， python导入'matplotlib'包报错 解决：https://blog.csdn.net/weixin_43670105/article/details/87911820 【不能解决】 UserWarning: h5py is running against HDF5 1.10.2 when it was built against 1.10.3, this may ca... https://www.jianshu.com/p/c248bbea1da7 tensorflow版本：2.0过高怎么办？ 解决： 适当回退tensorflow版本： pip install tensorflow==1.13.1 安装Tensorflow 2.0后的坑has no attribute 'contrib' https://blog.51cto.com/cfy10/2446977?source=dra ModuleNotFoundError: No module named 'tensorflow.contrib.rnn' https://blog.csdn.net/u014742995/article/details/86496292 提示python版本过高、冲突（tensorflow版本）怎么办？ conda install python=3.6 Anaconda中将python 3.7版本退回python 3.6版本 https://blog.csdn.net/Fhujinwu/article/details/85851587 遇到 label xxx no image found 类问题： 如 提示： CRITICAL:tensorflow:Label 51 has no images in the category validation. Tensorflow - No valid folders of images found at XXXXX #10104 ERROR:tensorflow:No valid folders of images found at https://github.com/tensorflow/tensorflow/issues/10104 http://www.codeclip.com/4141.html 参考文献： https://blog.csdn.net/ZeyiRTangent/article/details/87886445 相似推荐，有助思考： https://blog.csdn.net/weixin_38663832/article/details/80555341 https://blog.csdn.net/EZ_guachong/article/details/90048846 https://github.com/sourcedexter/tfClassifier https://stackoverflow.com/questions/45076911/tensorflow-failed-to-create-a-newwriteablefile-when-retraining-inception 迁移学习 https://blog.csdn.net/chaipp0607/article/details/73380390 https://blog.csdn.net/Night___Raid/article/details/102975023 ","link":"https://littlebuzi.github.io/tensorflow2"},{"title":"TensorFlow支持的动漫人物识别网站的存储库","content":"开始： 在知乎上偶然阅读到这位作者的文章：https://zhuanlan.zhihu.com/p/70511070 参考： https://gitee.com/littlebuzi/danbooru-pretrained https://github.com/freedomofkeima/MoeFlow https://github.com/freedomofkeima/transfer-learning-anime https://github.com/nagadomi/animeface-2009 https://github.com/KichangKim/DeepDanbooru/releases/tag/v1-20191108-sgd-e30 ","link":"https://littlebuzi.github.io/tensorflow3"},{"title":"About Download","content":"下载 https://www.4kdownload.com/zh-cn/downloads https://github.com/soimort/you-get ","link":"https://littlebuzi.github.io/download1"},{"title":"Python基操","content":"Python 爬虫 beautifulsoup4 基础 pycharm、python环境搭建好后 装载html文档，使用beautifulsoup的第一步是把html文档装载到beautifulsoup中，使其形成一个beautifulsoup对象。 import requests from bs4 import BeautifulSoup url = &quot;xxxx&quot; r = requests.get(url) htmls = r.text #print(htmls) soup = BeautifulSoup(htmls, 'html.parser') 初始化BeautifulSoup类时，需要加入两个参数，第一个参数即是我们爬到html源码，第二个参数是html解析器，常用的有三个解析器，分别是”html.parser”,”lxml”,”html5lib”，官网推荐用lxml，因为效率高，当然需要pip install lxml一下。 例子 html对象： uls=''' &lt;h3&gt;Header3 (Start here)&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;List items&lt;/li&gt; &lt;li&gt;Etc...&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;List items&lt;/li&gt; &lt;ul&gt; &lt;li&gt;Nested list items&lt;/li&gt; &lt;li&gt;Nested list items&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;List items&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Header 2 (end here)&lt;/h2&gt; lis = [] for ul in uls: for li in ul.findAll('li'): if li.find('ul'): break lis.append(li) for li in lis: print(li.text) #print(li.text.encode(&quot;utf-8&quot;)) https://www.jb51.net/article/156907.htm https://blog.csdn.net/huxiny/article/details/79679066 百度图片爬虫： https://blog.csdn.net/qq_40774175/article/details/81273198 Python代码报错 FileExistsError: [WinError 183] 当文件已存在时，无法创建该文件。 检查路劲是否有中文，有则换成英文或数字 https://zhidao.baidu.com/question/1309336445243832299.html Python 读取和输出到 txt 文件 with open(&quot;test.txt&quot;, &quot;r&quot;,encoding='UTF-8') as f: # 打开文件 data = f.read() # 读取文件 print(data) 读入这种文件时： test.txt 樱之宫莓香 轰焦冻 鬼灯 和泉守兼定 str=[] with open(&quot;test.txt&quot;, &quot;r&quot;,encoding='UTF-8') as f: # 打开文件 data = f.readlines() for line in data: line = line.strip('\\n') # 去掉列表中每一个元素的换行符 str.append(line) print(str) 参考： https://blog.csdn.net/zhang__shuang_/article/details/82527314 Python读取文件时出现UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position xx: 解决方案: https://blog.csdn.net/zhang__shuang_/article/details/82527314 ①：Python 正则表达式 re 中出现'str' object has no attribute 'findall' ②：出现TypeError: 'list' object is not callable异常的情况与解决方法 ③：利用python将中文名转换为英文名 python递归遍历目录和子目录下的所有文件，并将文件目录存入列表 import os def get_file(root_path,all_files=[]): ''' 递归函数，遍历该文档目录和子目录下的所有文件，获取其path ''' files = os.listdir(root_path) for file in files: if not os.path.isdir(root_path + '/' + file): # not a dir all_files.append(root_path + '/' + file) else: # is a dir get_file((root_path+'/'+file),all_files) return all_files # example path = './raw_data' print(get_file(path)) https://blog.csdn.net/weixin_39858881/article/details/86543689 Python中复制文件的两种简单方式 方法一：借助操作系统中本身的拷贝命令 import os os.system(&quot;xcopy C:\\\\1.txt D:&quot;) 方法二：借助shutil模块来完成拷贝操作 import shutil shutil.copyfile('C:\\\\1.txt', 'D:\\\\1.txt') ","link":"https://littlebuzi.github.io/pacong"},{"title":"Pr+Au+MMD入门","content":"Pr入门： https://www.jianshu.com/p/d88b5b8e6520 https://baijiahao.baidu.com/s?id=1625249302308705665&amp;wfr=spider&amp;for=pc 下载： http://www.32r.com/search.asp?wd=Premiere%20Pro Au入门： https://jingyan.baidu.com/article/cbf0e500d381706faa2893e0.html 下载： http://www.32r.com/search.asp?wd=audition MMD入门： 1.下载 https://www.bilibili.com/video/av20662019/ http://blog.sina.com.cn/s/blog_15fe57f4d0102x6g9.html http://www.3322.cc/search.asp?wd=miku 2.教程 http://blog.sina.com.cn/s/blog_15fe57f4d0102x7mm.html http://tieba.baidu.com/p/5868731425 http://blog.sina.com.cn/s/blog_15fe57f4d0102x66y.html https://zhidao.baidu.com/question/488239911574372932.html https://tieba.baidu.com/p/5020448822?pn=1 ","link":"https://littlebuzi.github.io/pr_1"},{"title":"Win 搭建 Go + Beego + Idea","content":" 1.安装 Go 选择window版本：https://golang.google.cn/dl/ 2.安装 idea 下载：IntelliJ IDEA 2018.3 安装+永久激活:（版本需小于2019,有可能plugins商店使用异常） idea 中配置安装 go https://blog.csdn.net/cui_yonghua/article/details/90900336 idea 中安装 bee IDEA打开命令行快捷键：Alt + F12 5.安装 beego 输入： //检验 go version //下载beego框架 go get -u github.com/astaxie/beego go get -u github.com/beego/bee //等待片刻 下载完后： go bee version（检验） //成功 6.第一个 go 项目 在windows环境下搭建beego环境 以及第一个项目 ","link":"https://littlebuzi.github.io/go1"},{"title":"基于 tensorflow 的动漫人物识别","content":" 总目标：实现动漫人脸识别、建立动漫人脸数据库 本文定位在有一定python、linux基础和我这样的学生阅读 遇到问题❓/错误❌，请查看文末或文章间隙 1、标注图片中动漫人物的脸部 环境： 服务器：腾讯云（新用户优惠，阿里云之前使用了） 操作系统：CetenOS 6.5 (环境配置复杂度: Window &gt; Centos &gt; Ubuntu 因个人原因使用centos较多) python版本：3.5（自带2.6.6） window端（客户端）工具：Xshell、Xftp 1.1、依赖下载： ① 动漫人脸分类器下载： https://github.com/nagadomi/lbpcascade_animeface/ ② i2v库的安装： Github：https://github.com/rezoo/illustration2vec/ 1.2、Test环境： 准备下linux服务器主机(centos)属性、环境： 查看linux系统CPU和内存命令 python -V 安装anaconda（推荐安装中等较新版本，尽量避免未知错误）/ 安装pip（可能后续会出问题） CentOS 7安装Anaconda3 import cv2 可能会遇到anaconda崩了，涉及python多重版本conda软链接指向出了问题等： 修改软链接 修改.bashrc 重新安装anaconda 或者使用了清华源或其他源的旧版本，或官方版的最新，尝试anaconda版本回退一点点 1.3、参数查询、环境调试结束，开始测试功能： 文件目录： 动漫人脸检测并截取： (尝试进行从一张图片中识别并截取人脸进行保存的操作) #coding=utf-8 import cv2 import sys import os.path cascade = cv2.CascadeClassifier('/root/comic/lbpcascade_animeface.xml') # 引入xml image = cv2.imread('/root/comic/test.jpg', cv2.IMREAD_COLOR) # 读入一幅彩色图片 gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 色彩空间转换 gray = cv2.equalizeHist(gray) # 图像直方图均衡化 faces = cascade.detectMultiScale(gray, # detector options scaleFactor=1.1, minNeighbors=5, minSize=(24, 24)) i = 0 for (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (0, 0, 255), 2) face = image[y: y + h, x:x + w, :] face = cv2.resize(face, (96, 96)) save_filename = '%s_%d.png' % (os.path.basename('/root/comic/faces/').split('.')[0], i) cv2.imwrite(&quot;/root/comic/faces/&quot; + save_filename, face) i = i + 1 #cv2.imshow(&quot;AnimeFaceDetect&quot;, image) cv2.waitKey(0) cv2.imwrite(&quot;/root/comic/out.png&quot;, image) 2、截取并保存视频一帧帧截取到的动漫人脸(目标)： 2.1、文件目录： 2.2、导入视频一帧帧截取动漫人脸： #coding=utf-8 import cv2 import os face_id = 1 count = 0 cap = cv2.VideoCapture('/root/comic/1.mp4') face_detector = cv2.CascadeClassifier('/root/comic/lbpcascade_animeface.xml') while True: # 从摄像头读取图片 sucess, img = cap.read() # 转为灰度图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 检测人脸 faces = face_detector.detectMultiScale(gray, 1.3, 5) for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+w), (255, 0, 0)) count += 1 font = cv2.FONT_HERSHEY_TRIPLEX cv2.putText(img, 'num:%d' % (count), (x + 30, y + 30), font, 1, (255, 0, 255), 4) # 保存图像 cv2.imwrite(&quot;/root/comic/characters/User.&quot; + str(face_id) + '.' + str(count) + '.jpg', gray[y: y + h, x: x + w]) #cv2.imshow('image', img) # 保持画面的持续。 k = cv2.waitKey(1) if k == 27: # 通过esc键退出摄像 break # 关闭摄像头 cap.release() cv2.destroyAllWindows() 2.2、分类图片： 将不同人物分类到属于他命名的文件夹下： #开发中 3、训练图片： 开始制定、训练出模型(代码太长影响观感,完整代码github)： #coding=utf-8 from skimage import io, transform import glob import os import tensorflow as tf import numpy as np import time import matplotlib.pyplot as plt # 训练验证数据集目录 path = '/root/comic_reg/data/train-validation-set/'#最后少了个斜杠 读入失败 # 模型保存地址，最后接的是模型名字 model_path = '/root/comic_reg/model/model.ckpt' # 将所有的图片resize成100*100 # 读取图片 # 打乱顺序 # 将所有数据分为训练集和验证集 ratio = 0.7 s = np.int(num_example*ratio) x_train = data[:s] y_train = label[:s] x_val = data[s:] y_val = label[s:] # -----------------构建网络---------------------- # 占位符 x = tf.placeholder(tf.float32, shape=[None, w, h, c], name='x') y_ = tf.placeholder(tf.int32, shape=[None, ], name='y_') # 第一个卷积层（100——&gt;50) # 第二个卷积层(50-&gt;25) # 第三个卷积层(25-&gt;12) # 第四个卷积层(12-&gt;6) # 全连接层 # ---------------------------网络结束--------------------------- # (小处理)将logits乘以1赋值给logits_eval，定义name，方便在后续调用模型时通过tensor名字调用输出tensor # 定义一个函数，按批次取数据 # 训练和测试数据，可将n_epoch设置更大一些 n_epoch = 50 batch_size = 32 saver = tf.train.Saver() sess = tf.Session() sess.run(tf.global_variables_initializer()) # 自定义保存数据列表 trainlosslist = [] trainacclist = [] validationlosslist = [] validationacclist = [] for epoch in range(n_epoch): start_time = time.time() # training train_loss, train_acc, n_batch = 0, 0, 0 for x_train_a, y_train_a in minibatches(x_train, y_train, batch_size, shuffle=True): _, err, ac = sess.run([train_op,loss,acc], feed_dict={x: x_train_a, y_: y_train_a}) train_loss += err; train_acc += ac; n_batch += 1 print(&quot; train loss: %f&quot; % (train_loss / n_batch)) print(&quot; train acc: %f&quot; % (train_acc / n_batch)) # 添加到列表 trainlosslist.append(train_loss / n_batch) trainacclist.append(train_acc / n_batch) # validation val_loss, val_acc, n_batch = 0, 0, 0 for x_val_a, y_val_a in minibatches(x_val, y_val, batch_size, shuffle=False): err, ac = sess.run([loss, acc], feed_dict={x: x_val_a, y_: y_val_a}) val_loss += err; val_acc += ac; n_batch += 1 print(&quot; validation loss: %f&quot; % (val_loss / n_batch)) print(&quot; validation acc: %f&quot; % (val_acc / n_batch)) # 添加到列表 validationlosslist.append(val_loss / n_batch) validationacclist.append(val_acc / n_batch) saver.save(sess,model_path) sess.close() # 绘图 x = np.arange(1, n_epoch, 1) plt.plot(x, np.array(trainacclist)[x-1], label=&quot;train-acc&quot;) plt.plot(x, np.array(validationacclist)[x-1], label=&quot;validation-acc&quot;) plt.plot(x, np.array(trainlosslist)[x-1], label=&quot;train-loss&quot;) plt.plot(x, np.array(validationlosslist)[x-1], label=&quot;validation-loss&quot;) # 设置坐标轴名称 plt.xlabel('epoch') # 画两条基准线 plt.plot(x, x/x, label=&quot;one&quot;) plt.plot(x, x-x, label=&quot;zero&quot;) # 参数：loc设置显示的位置，0是自适应；ncol设置显示的列数 plt.legend(loc=0, ncol=1) #plt.show() plt.savefig(&quot;/root/comic_reg/out.png&quot;) 4、识别图片： from skimage import io,transform import tensorflow as tf import numpy as np import glob path = '/root/comic_reg/data/test-set/*.png' image_dict = {0: '一花',1:'二乃',2:'三玖',3:'四叶',4:'五月'} count_true=[] w=100 h=100 c=3 def read_one_image(path): img = io.imread(path) img = transform.resize(img,(w,h)) return np.asarray(img) with tf.Session() as sess: data = [] # 目录列表 paths = glob.glob(path) #print(paths) for img in paths: data.append(read_one_image(img)) saver = tf.train.import_meta_graph('/root/comic_reg/model/model.ckpt.meta') saver.restore(sess,tf.train.latest_checkpoint('/root/comic_reg/model/')) graph = tf.get_default_graph() x = graph.get_tensor_by_name(&quot;x:0&quot;) feed_dict = {x:data} logits = graph.get_tensor_by_name(&quot;logits_eval:0&quot;) classification_result = sess.run(logits,feed_dict) #打印出预测矩阵 print(&quot;\\n预测矩阵:\\n&quot;, classification_result) #打印出预测矩阵每一行最大值的索引 print(&quot;\\n简略结果:\\n&quot;, tf.argmax(classification_result,1).eval(), '\\n') print(&quot;具体情况: &quot;) #根据索引通过字典对应人物的分类 output = [] output = tf.argmax(classification_result,1).eval() count = 0 for i in range(len(output)): # output[i]是测试结果编码，paths[i])[-7]是原定图片编号（路飞1） flag = False if str(output[i]+1) == paths[i][-7]: flag = True if flag == True: count_true.append(paths[i][-7:]) count += 1 print(&quot;第 &quot; + str(i+1) + &quot; 张 (&quot; + paths[i][-7:] + &quot;) 人物预测: &quot; + image_dict[output[i]] + &quot; &quot; + str(flag)) print(&quot;\\n准确率: {:.2f}%&quot;.format(count / len(output) * 100 )) print(count_true) 结果： 因为只有第一个人物图片准备充足所以其他人物识别率会偏低 之前使用： 服务器：腾讯云 操作系统：Ubuntu Server 18.04.1 LTS 64位 类型：公共镜像（池） 内存：2 GB CPU：1 核 硬盘：50 G 公网带宽：1 Mbps 步骤1.1中可能遇到的问题： 1.下载速度太慢： 法一： liunx 下载 Github_Releases 下载提速： Linux系统下hosts文件的位置是 /etc/hosts ，以root用户登录Linux，使用vi编辑/etc/hosts文件，将附加的内容添加在其后面即可： 修改hosts(liunx): 52.216.186.155 github-production-release-asset-2e65be.s3.amazonaws.com wget https://github.com/rezoo/illustration2vec/releases/download/v2.0.0/illust2vec_tag_ver200.caffemodel 以此类推... 法二： 修改hosts(window): 当我们需要本地调试网站或者屏蔽某个网站的时候可以手动将这个网站添加到系统hosts文件中，因为hosts文件的优先级高于DNS，所以可以达到你想要在浏览器里呈现的结果，当然这只在本地有用！ 一、Windows中hosts文件一般在C:\\Windows\\System32\\drivers\\etc目录下，格式是 127.0.0.1 localhost ::1 localhost 52.216.186.155 github-production-release-asset-2e65be.s3.amazonaws.com 可以用记事本修改，前面是IP地址，后面是域名。127.0.0.1这个是本地环回地址。 比如127.0.0.1 www.baidu.com就是把www.baidu.com这个域名指向127.0.0.1的地址。 ##法三： Github镜像网站：http://github-mirror.bugkiller.org/ xftp传上去云端 当然这也需要很久 不多折合下来很大可能快50-100倍。如果像我一样有一台window云服务，那就让它来做这件事。下载，上传，都在云上进行。 详细请看 https://www.cmsky.com/linux-hosts/ 步骤2.2中可能遇到的问题： 【Linux】 解决报错： ImportError: libSM.so.6: cannot open shared object file: No such file or directory 原因： libSM、libSM等不存在 解决办法： yum install xxx 详：https://www.cnblogs.com/richerdyoung/p/8458910.html 步骤2.3中可能遇到的问题： 查看linux系统CPU和内存命令 https://jingyan.baidu.com/article/fdbd4277b16d1cb89e3f48e4.html Python MemoryError https://blog.csdn.net/xiaopihaierletian/article/details/57416110 在用Python处理大数据时，本来16G的内存，内存还没使用四分之一就开始报MemoryError的错误，后来才知道32bit的Python使用内存超过2G之后，就报这个错误，还没有其他的提示消息。果断换64bit的Python。 https://blog.csdn.net/weixin_33928137/article/details/93646975 https://blog.csdn.net/xovee/article/details/101077022 linux 使用文件增加虚拟内存 swap https://msd.misuland.com/pd/3070888491219949990 https://www.cnblogs.com/ling-yu-amen/p/10819879.html import cv2 找不到 face AttributeError: module 'cv2.face' has no attribute 'createEigenFaceRecognizer' 解决办法 原因： 一.版本问题，目前使用版本cv2.face中createEigenFaceRecognizer更名或移除 解决：请查看对应版本的说明文档，使用对应版本或属性名。 二.未安装 opencv_contrib，所以 model = cv2.face.createEigenFaceRecognizer() 行找不到face 解决： 1.使用pip、源码安装方法 pip install opencv-python opencv-contrib-python 或 https://blog.csdn.net/wyx100/article/details/78498609 2.conda ： conda install opencv-python opencv-contrib-python 问：博主你的代码有问题，你的项目文件夹怎么建的？ 答：项目还在开发中，这是俺滴毕设所以还未完善，只有个大概，望体谅谢谢大家 工具：xftp、xshell：https://www.netsarang.com/zh/free-for-home-school/ 参考文献： https://blog.csdn.net/abcd740181246/article/details/89878613 https://blog.csdn.net/zyxhangiian123456789/article/details/87911999 https://blog.csdn.net/qq_29007291/article/details/81103603 https://blog.csdn.net/mozf881/article/details/84929443 ","link":"https://littlebuzi.github.io/face_1"},{"title":"基于opencv的人脸识别签到系统 ","content":" 学校小学期项目：人脸识别签到系统 一、需求和计划： 随着高科技的蓬勃发展，人体特征分析技术已经作为身份快速识别及视频监控等领域的最新增值点与应用点，在身份识别、智能安防、智能监控、出入管理、证卡认证等方面发挥巨大作用。面部检测识别技术，是利用计算机图像分析、模型理论、人工智能及模式识别技术的非接触性高端模式识别技术，其可完成从复杂的图像场景中检测、检出特征人像信息，并进行匹配识别的智能分析过程。 软件的发展给我们的经济带来了很大的推动作用，现在越来越多的软件技术运用于各行各业，市场经济作为经济发展的一部分，推行新的技术对其有很大的帮助作用，而人类面部识别智能化的应用，为工作及生产带来很大便利，提高了效益。比如日常工作中的面部考勤签到，vip客户面部识别，来访人员面部识别等，这些系统的应用为行业及单位带来了很大的收益，因此随着技术的进步，跟上时代的步伐显得尤为重要。 二、项目设计： 1、 人员脸部信息采集 在学校集中进行学生和教师的人脸信息采集（现阶段），证件、部门、职务等信息登记（以后）。 2、 人员基础信息管理 在系统中基础信息管理需要管理工作人员的基本资料：包括面部信息、证件号、部门（暂未）等,可以以不同参数为索引百行排列、查询，并可以生成工作人员信息报表。 3、 IP摄像机终端管理（目标） 在系统中，可以对前端IP摄像机进行远程管理，比如修改IP地址，修改设备编号及开启采集与识别功能。 4、 系统扩展接口（目标） 系统提供与企事业单位内其他业务系统的开发接口，实现面部识别考勤系统与其他业务系统的结合使用，方便生产场所的业务管理，提高工作效率。 5、 查询统计报表 系统可以对工作人员的考勤信息进行查询统计，并生成相应工作报表，为单位进一步提供有针对性的工作考勤管理提供信息决策支持。 7、系统设置 实现系统的使用用户及权限信息管理，实现系统参数设定管理。 使用的库 ： 1.opencv（人脸识别）： （内置）算法，摄像头，引用xml。 2.tkinter（图形界面）： 图形化界面，（简单按钮事件）链接各py文件，业务逻辑。 （内置）算法，摄像头，引用xml Tkinter： 图形化界面，（简单按钮事件）链接各py文件，业务逻辑 界面： 三、项目实现过程： 人脸检测： 使用OpenCV的人脸检测器进行人脸的初步检测，使haarcascade_frontalface_default.xml训练进行人脸的二分类判定，完成人脸检测。换调用摄像头：“cv2.VideoCapture(1)”，使用Python+OpenCV进行视频中的人脸检测，人脸关键点定位：关键点定位的目标是在确知人脸位置的基础上，精确定位面部的关键点，如下图示意： 图像采集： 采集1000张图片，转换为灰度图并报错，以自己设定好的规律命名图片文件，易于之后的读取后训练。 获得面部关键点的目的是进行人脸的对齐和标准化。标准化的人脸输入可以获得更高的人脸识别精度。 图像特征采集： 人脸特征提取是根据上述标准化的人脸区域图块，提取出数字化的特征。即完成从RGB信息到数值特征的变换。此环节需要尽量使得同一个人物的不同人脸所提取到的特征尽可能相似，而不同人物的人脸所提取的特征尽可能相异。 模型的训练： 人脸识别的模型的训练采用LBPH算法： cv2.face.LBPHFaceRecognizer_create() OpenCV人脸识别LBPH算法源码分析 注册成功： 签到成功： 四、项目总结和体会： 要搞一个人脸识别程序，首先我们需要先用提前裁剪好的标注好的人脸照片训练一个识别器。比如说，我们的识别器需要识别两个人，一个人的id是1，而另一个的id是2，于是在数据集里面，1号人的所有照片会有id 1号，2号人同理。然后我们就会使用这些数据集照片去训练识别器，再从一个视频中识别出1号人。 我们把要做的事分成三部分： 1.创建数据集 2.训练 3.识别 生成数据集，写一个数据集生成脚本。Python环境，Pycharm等IDE。 在目录中放好haarcascade_frontalface_default.xml 。OpenCV自带的。 我在github上进行了下载接下来使用cv2获取摄像头数据以及XML文件：我们的数据集需要先从摄像头采集一些人脸例子照片，当然，只能是同一个人的。然后程序会给这些例子照片添加id，并将照片保存在一个文件夹中，这个文件夹我们就将它命名为data，在py脚本的同目录下创建一个data的文件夹。 为了不会将不同的人脸照片弄混，我们需要定一个命名规则，用于给照片命名。例如，命名规则为User.[ID].[SampleNumber].jpg。如果是2号人的第十张照片，我们可以将它命名为User.2.10.jpg。为什么要定义这样的格式呢？因为这样，在加载照片训练的时候，我们就可以只通过照片的文件名，就能简单地判断是几号用户的人脸照片。而后取出时进行分割，拿到对应id的图片，计算特征值。通过shell输入，来获取人的id，并且初始化计算器变量来存储人们的例子数。 有一个值得注意的地方，gray[y : y + h, x : x + w]。此处我们是把一张灰度图片看成一个二维数组（或二维矢量），然后使用python中[]截取OpenCV检测出来的人脸区域。为了照片识别度，质量好一点，我们需要提高一下两次拍摄之间的延迟。代码会在两个拍摄间延迟100毫秒，100毫秒足够让我们去移动我们人脸的角度了（时间不够长就再加）。在拍摄1000张后停止。 最后释放资源：cap.release() cv2.destroyAllWindows() 识别和录取到训练其实都是差不多的业务逻辑。我们的1000张图片如果质量更好，或者说直接10000张。可能效果会好很多。 在算法抉择方面我们选用了1996年的LBPH算法，还有其他更多算法 如： recognizer = cv2.face.EigenFaceRecognizer_create() recognizer = cv2.face.FisherFaceRecognizer_create() 不同算法详细介绍： 人脸识别算法之特征脸方法(Eigenface、FisherFace、LBPH) LBPH算法： 原理：通过已知条件，利用特定关系逐步递推，最终得到结果。 1.提取特征值并转换 2.生成数据集，训练，生成yml文件 3.计算（欧式）距离，输出相似度 整体代码流程： 完整代码： Github: littlebuzi / FaceRecognition ","link":"https://littlebuzi.github.io/face"},{"title":"制作“漫画网站”爬虫","content":"v1.0 目的 1.目标网站：https://www.这里是网址.cc/ 2.目标结果：获取全部漫画图片文件，并分好文件夹 实现过程 基本逻辑 代码实现 import requests from bs4 import BeautifulSoup import re import os #1-1030 for num1 in range(1,1031): circle = requests.get('https://这里是网址/book/'+str(num1)) # 将获取的图片地址依次放入count中 count = [] # 将获取的网页内容放入BeautifulSoup soup = BeautifulSoup(circle.text, 'lxml') # 根据谷歌SelectGadGet这个插件，获取html标签，比如获取：#gallery-list for item_book in soup.select('.d_bg_t'): for book_name in item_book.find_all('a'): if(book_name.string!='韩国'and book_name.string!='男性'): book_name_clean=book_name.string print(num1, book_name_clean) os.makedirs('D://manhua//整站漫画爬取//' + str(num1) +'.'+ book_name_clean ) #menu_path_num = [] for item in soup.select('.d_menu&gt;ul&gt;li'): # 用bs4中的find_all获取 #gallery-list 中是否存在 img这个标签 for a in item.find_all('a'): #print('a', a) # m 是 img标签中存在的属性 menu_path = 'https://www.manhwa.cc/' + a.get('href') #count.append(menu_path) #menu_path_num.append(re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path)) menu_path_num=re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path) #当前一部书爬取循环，从上面得到每一章地址后，遍历这么多“章”次 #for num in menu_path_num: print('book_url:',menu_path) circle = requests.get(menu_path) # 将获取的图片地址依次放入count中 count = [] # 将获取的网页内容放入BeautifulSoup soup = BeautifulSoup(circle.text, 'lxml') # 根据谷歌SelectGadGet这个插件，获取html标签，比如获取：#gallery-list for title in soup.select('div.fl.r_tab_l'): for title in title.find_all('span'): print('title:', title.text) title=title.text for item in soup.select('.r_img'): # 用bs4中的find_all获取 #gallery-list 中是否存在 img这个标签 for img in item.find_all('img'): print('img_url:', img) # m 是 img标签中存在的属性 img_path = img.get('data-original') count.append(img_path) # 用enumerate依次取出count中的图片地址 放入v中 os.makedirs('D://manhua//整站漫画爬取//' + book_name_clean + '//' + str(title) + '//') for i, v in enumerate(count): # 将获取的v值再次放入request中进行与网站相应 image = requests.get(v) # 存取图片过程中，出现不能存储 int 类型，故而，我们对他进行类型转换 str()。w:读写方式打开，b：二进制进行读写。图片一般用到的都是二进制。 with open('D://manhua//整站漫画爬取//' + book_name_clean + '//'+ str(title) + '//' +str(i) + '.jpg', 'wb') as file: #with open('C://Users//50159//Desktop//manhua//test//' + str(num1) + '_' + str(i) + '.jpg', 'wb') as file: # content：图片转换成二进制，进行保存。 file.write(image.content) print(i) 到这基本工作已完成，进入测试阶段，出现以下 测试问题 1.第250本左右，书名字开始出现异常，爬取书名有其他文字并出现混乱，因为之前是通过最前面几本书的情况，通过抛弃字样，来筛选出书名，而后1030本里标签发生变动，所以之后通过只取第一个出现的标签代替现在的筛选。 2.文件夹命名及生成文件夹出错，由于整理时出现混乱，代码写重复了。而后修改。 3.中途停止，可能是网站识别到了这是爬虫，而后添加伪浏览器头部head，还是会停，基本是connect超时。 针对上面问题，修改成了2.0版本: import requests from bs4 import BeautifulSoup import re import os #1-1030 for num1 in range(2,1031): #716字符问题无法生成文件夹 import urllib.request # url包 def openUrl(circle): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Host': 'jandan.net' } req = urllib.request.Request(circle, headers=headers) response = urllib.request.urlopen(req) # 请求 html = response.read() # 获取 html = html.decode(&quot;utf-8&quot;) # 解码 print(html) # 打印 if __name__ == &quot;__main__&quot;: circle = requests.get('https://这里是网址/book/' + str(num1)) # 将获取的图片地址依次放入count中 count = [] # 将获取的网页内容放入BeautifulSoup soup = BeautifulSoup(circle.text, 'lxml') # 根据谷歌SelectGadGet这个插件，获取html标签，比如获取：#gallery-list for item_book in soup.select('.d_bg_t'): for book_name in item_book.select('a')[0]: book_name_clean = book_name.string print(num1, book_name_clean) #os.makedirs('D://manhua//整站漫画爬取//' + str(num1) +'.'+ book_name_clean ) for item_book in soup.select('.d_bg_t'): for book_name in item_book.find_all('a'): if(book_name.string!='韩国'and book_name.string!='男性'): book_name_clean=book_name.string print(num1, book_name_clean) #menu_path_num = [] for item in soup.select('.d_menu&gt;ul&gt;li'): # 用bs4中的find_all获取 #gallery-list 中是否存在 img这个标签 for a in item.find_all('a'): #print('a', a) # m 是 img标签中存在的属性 menu_path = 'https://www.manhwa.cc/' + a.get('href') #count.append(menu_path) #menu_path_num.append(re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path)) menu_path_num=re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path) #当前一部书爬取循环，从上面得到每一章地址后，遍历这么多“章”次 #for num in menu_path_num: print('book_url:',menu_path) circle = requests.get(menu_path) # 将获取的图片地址依次放入count中 count = [] # 将获取的网页内容放入BeautifulSoup soup = BeautifulSoup(circle.text, 'lxml') for title in soup.select('div.fl.r_tab_l'): for title in title.find_all('span'): print('title:', title.text) title=title.text for item in soup.select('.r_img'): # 用bs4中的find_all获取 #gallery-list 中是否存在 img这个标签 for img in item.find_all('img'): print('img_url:', img) # m 是 img标签中存在的属性 img_path = img.get('data-original') count.append(img_path) # 用enumerate依次取出count中的图片地址 放入v中 os.makedirs('D://manhua//整站漫画爬取//' + book_name_clean + '//' + str(title) + '//') for i, v in enumerate(count): # 将获取的v值再次放入request中进行与网站相应 image = requests.get(v) # 存取图片过程中，出现不能存储 int 类型，故而，我们对他进行类型转换 str()。w:读写方式打开，b：二进制进行读写。图片一般用到的都是二进制。 with open('D://manhua//整站漫画爬取//' + book_name_clean + '//'+ str(title) + '//' +str(i) + '.jpg', 'wb') as file: #with open('C://Users//50159//Desktop//manhua//test//' + str(num1) + '_' + str(i) + '.jpg', 'wb') as file: # content：图片转换成二进制，进行保存。 file.write(image.content) print(i) 爬取过程： 基本可行，最高纪录 ，爬取四本后停止。 真的太多了，一本大小平均150M左右。 总结： 爬取正本漫画 ✅ 整站漫画半自动化爬取（停止需手动启动一次）✅ 全自动下载网站漫画 （会被网站截停）❌ v2.0 2.0优化版 特点 ui界面添加✅ 网站截停后 播放音乐提醒 接近半自动重启 ✅ 各个细节爬取优化，优化接近自身无报错 ✅ cmd输出界面优化✅ 计时器检测添加中（待） 全自动重启（待） 逻辑 代码 启动代码： import os os.system(r&quot;python D:\\manhua\\这里是网址\\manhua4.py&quot;) os.system(r&quot;F:\\CloudMusic\\是萝莉控真是太好了.mp3&quot;) 爬取代码： import requests from bs4 import BeautifulSoup import re import os from PyQt5.QtWidgets import QApplication, QWidget, QLineEdit, QInputDialog, QGridLayout, QLabel, QPushButton, QFrame, QProgressBar first=1 class InputDialog(QWidget): def __init__(self): super(InputDialog,self).__init__() self.initUi() def initUi(self): self.setWindowTitle(&quot;漫画爬取&quot;) self.setGeometry(50,50,1200,600) label1=QLabel(&quot;第一本:&quot;) label2=QLabel(&quot;最后一本:&quot;) self.nameLable = QLabel(&quot;1&quot;)#1 self.first=int(self.nameLable.text()) self.nameLable.setText(str(self.first)) self.nameLable.setFrameStyle(QFrame.Panel|QFrame.Sunken) self.styleLable = QLabel(&quot;1&quot;)#1030 self.last=self.styleLable.text() self.styleLable.setText(str(self.last)) self.styleLable.setFrameStyle(QFrame.Panel|QFrame.Sunken) # 设置进度条(弃用) nameButton=QPushButton(&quot;更改&quot;) nameButton.clicked.connect(self.selectName) styleButton=QPushButton(&quot;更改&quot;) styleButton.clicked.connect(self.selectStyle) okButton = QPushButton(&quot;OK&quot;) okButton.clicked.connect(self.selectOk) mainLayout=QGridLayout() mainLayout.addWidget(label1,0,0) mainLayout.addWidget(self.nameLable,0,1) mainLayout.addWidget(nameButton,0,2) mainLayout.addWidget(label2,1,0) mainLayout.addWidget(self.styleLable,1,1) mainLayout.addWidget(styleButton,1,2) mainLayout.addWidget(okButton,2,1) self.setLayout(mainLayout) #爬取代码 def ManHua(self): for num1 in range(first,1030): import urllib.request # url包 def openUrl(circle): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Host': 'jandan.net' } req = urllib.request.Request(circle, headers=headers) response = urllib.request.urlopen(req) # 请求 html = response.read() # 获取 html = html.decode(&quot;utf-8&quot;) # 解码 print(html) # 打印 if __name__ == &quot;__main__&quot;: circle = requests.get('https://这里是网址/book/' + str(num1)) count = [] soup = BeautifulSoup(circle.text, 'lxml') for item_book in soup.select('.d_bg_t'): for book_name in item_book.select('a')[0]: book_name_clean = book_name.string print('') print(&quot;正在下载：&quot;,num1, book_name_clean) aa=0 #print(aa,num1) if num1&gt;aa: aa=num1 #print(aa) for i in range(int(num1*(100/1030))+1): print('\\r'+'总进度：' + '▇' * (i // 2) + str(i) + '%', end='') print('') for item in soup.select('.d_menu&gt;ul&gt;li'): for a in item.find_all('a'): menu_path = 'https://这里是网址/' + a.get('href') # count.append(menu_path) # menu_path_num.append(re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path)) menu_path_num = re.findall(r&quot;\\d+\\.?\\d*&quot;, menu_path) # 当前一部书爬取循环，从上面得到每一章地址后，遍历这么多“章”次 # for num in menu_path_num: #print('book_url:', menu_path) circle = requests.get(menu_path) count = [] soup = BeautifulSoup(circle.text, 'lxml') #print(menu_path) print('.', end='') for title in soup.select('div.fl.r_tab_l'): for title in title.find_all('span'): #print('title:', title.text) title = title.text for item in soup.select('.r_img'): for img in item.find_all('img'): #print('img_url:', img) img_path = img.get('data-original') count.append(img_path) #自动识别'文件夹+文件'重复后跳过下载如何continue if(os.path.exists('D:/manhua/manhuatest/' + book_name_clean + '/' + str(title) + '/')): continue else: os.makedirs('D:/manhua/manhuatest/' + book_name_clean + '/' + str(title) + '/') for i, v in enumerate(count): image = requests.get(v) if (os.path.exists('D:/manhua/manhuatest/' + book_name_clean + '/' + str(title) + '/' + str(i) + '.jpg')): continue else: with open('D:/manhua/manhuatest/' + book_name_clean + '/' + str(title) + '/' + str(i) + '.jpg', 'wb') as file: file.write(image.content) #print(i) continue continue def selectName(self): name,ok = QInputDialog.getText(self,&quot;第一本&quot;,&quot;第一本序号:&quot;, QLineEdit.Normal,self.nameLable.text()) if ok and (len(name)!=0): self.nameLable.setText(name) def selectStyle(self): style, ok = QInputDialog.getText(self, &quot;最后一本&quot;, &quot;最后一本序号:&quot;, QLineEdit.Normal, self.nameLable.text()) if ok and (len(style)!=0): self.styleLable.setText(style) def selectOk(self): self.ManHua() if __name__==&quot;__main__&quot;: import sys app=QApplication(sys.argv) myshow=InputDialog() myshow.show() sys.exit(app.exec_()) 过程 总结 整站漫画全自动化爬取✅ 不能自动重启❌ 基本百分之95的功能实现，项目可宣布成功完成！✅ ","link":"https://littlebuzi.github.io/manhua"},{"title":"Tensorflow","content":"Tensorflow是什么？ Google的开源软件库： 采取数据流，用于数值计算。 支持多种平台 —— GPU、CPU、移动设备。（方便的无缝切换，不用更改大部分的代码） 最初用于深度学习，变得越来越通用。（tensorflow并不只是适用于深度学习，大部分还是深度学习，只要是能抽象为数据流图的问题，都能使用它来解决） 数据流图： 节点 —— 处理数据 对数据进行计算，每个框框（方形，圆形）都表示一个节点。 线 —— 节点输入输出的关系 节点与节点之间的数据依赖。（如偏最上面的三个绿色节点，Cross Entropy 依赖 Softmax 和Cross Labels 的输出，通过计算得出新的值，如果前两个节点没有计算完，后面的节点是无法计算的。） 线上运输张量（tensor） 线上运输的数据，所有的n维构成了数据的集合，0维数据 ——&gt; 数字，1维数据 ——&gt; 向量，二维 ——&gt; 矩阵，大于等于3维的数据 ——&gt; 高位矩阵。 让tensor（张量）在数据流图中flow（流动）——&gt;tensorflow 节点被分配到各种计算设备上运行 特性： 高度的灵活性 可以表示为数据流图的都可使用，主要同于神经网络，卷积等都使用了封装。也可写自己的封装，就像panda函数那样。 真正的可移植性 可在很多设备上执行，如 CPU、GPU、移动设备。你在电脑里训练了一个model，可部署在服务器上，手机上，Docker上。 多语言支持 python、c++、java、R、javascript 产品和科研结合 自动求微分 性能最优化 TF1.0 — 架构： TF2.0 — 架构： TF2.0 — 简化的模型开发流程： 使用 tf.data 加载数据 使用 tf.keras 构建模型，也可以使用 premade estimator 来验证模型 使用 tensorflow hub 进行迁移学习 使用 eager mode 进行运行和调试 使用分发策略来进行分布式训练 导出到 SavedModel 使用 Tensorflow Serve、Tensorflow Lite、Tensorflow.js 部署模型 ","link":"https://littlebuzi.github.io/tensorflow1"},{"title":"Python二三事","content":" 一、pip源（地址）： （1）阿里云 : http://mirrors.aliyun.com/pypi/simple/ （2）豆瓣 : http://pypi.douban.com/simple/ （3）清华大学 : https://pypi.tuna.tsinghua.edu.cn/simple/ （4）中国科学技术大学 : http://pypi.mirrors.ustc.edu.cn/simple/ （5）华中科技大学 : http://pypi.hustunique.com/ 1.普通使用： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas pip_install_-i_源的地址_包/库名 '_'符号代表空格 2.清华源使用介绍： pypi 镜像使用帮助 pypi 镜像每 5 分钟同步一次。 临时使用 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 注意，simple 不能少, 是 https 而不是 http 设为默认 升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置： pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 3.关于一键修改源、Linux 二、anaconda/conda 切换为国内源 windows下 在清华源和中科大源之间自行选择 添加清华源 命令行中直接使用以下命令 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ 设置搜索时显示通道地址 conda config --set show_channel_urls yes 注意如果需要pytorch, 还需要添加pytorch的镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 添加中科大源 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes Linux下 将以上配置文件写在~/.condarc中 vim ~/.condarc channels: - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - defaults show_channel_urls: true ","link":"https://littlebuzi.github.io/pip"},{"title":"安卓入门-目录结构【Android Studio】","content":" ","link":"https://littlebuzi.github.io/android"},{"title":"GitHub","content":"你所使用的很多开源程序都是在Github上 从较高的层面来说，GitHub是一个基于网站和云的服务，可以帮助开发人员存储和管理他们的代码，以及跟踪和控制对代码的更改。要准确理解GitHub是什么，您需要了解两个相关原则： 版本控制 Git 在本文中，我们将首先解释这两个原则。然后，我们将深入研究GitHub，以及如何使用GitHub与WordPress一起工作。 版本控制 版本控制可帮助开发人员跟踪和管理软件项目代码的更改。随着软件项目的发展，版本控制变得至关重要。以WordPress为例…… 在这一点上，WordPress是一个非常大的项目。如果核心开发人员想要在WordPress代码库的某个特定部分上工作，那么让他们直接编辑“官方”源代码是不安全或有效的。 相反，版本控制允许开发人员安全地完成分支和合并。 通过分支，开发人员复制部分源代码（称为存储库）。然后，开发人员可以安全地更改代码的这一部分，而不会影响项目的其余部分。 然后，一旦开发人员使他或她的部分代码正常工作，他或她就可以将该代码合并回主要源代码以使其正式化。 然后跟踪所有这些更改，并在需要时可以还原。 Git Git是Linus Torvalds于2005年创建的一个特定的开源版本控制系统。 具体来说，Git是一个分布式版本控制系统，这意味着每个开发人员的计算机上都可以使用整个代码库和历史记录，这样可以轻松进行分支和合并。 根据Stack Overflow开发人员调查，超过87％的开发人员使用Git。 GitHub GitHub是一家营利性公司，提供基于云的Git存储库托管服务。从本质上讲，它使个人和团队更容易使用Git进行版本控制和协作。 GitHub的界面足够用户友好，所以即使是新手编程也可以利用Git。如果没有GitHub，使用Git通常需要更多娴熟技术并使用命令行。 GitHub是如此用户友好，有些人甚至使用GitHub来管理其他类型的项目 - 比如写书。 此外，任何人都可以免费注册和托管公共代码存储库，这使得GitHub特别受开源项目的欢迎。 作为一家公司，GitHub通过销售托管私有代码存储库以及其他以业务为中心的计划来赚钱，这些计划使组织更容易管理团队成员和安全性。 探索GitHub接口 为了让您基本了解GitHub接口的外观，这里是GitHub存储库中托管的WordPress源代码： 从这里，您可以查看正在处理的各个分支，以及有人进行提交时（这有点像“保存”文件）。根据存储库的设置方式，您也可以创建自己的分支并在那里进行自己的提交。 一旦进行了一些更改，您就可以通过发出拉取请求将该代码提交回分支。拉取请求基本上是要求分支机构的负责人包含您的代码。它还可以帮助那个人准确地看到你在代码中改变了什么。 如果你想更长久地在你自己的帐户上编辑部分或全部WordPress源代码，你也可以通过单击Fork按钮来叉它（叉子在概念上类似于分支，但是fork更永久）： 使用Git和GitHub与WordPress 许多WordPress主题和插件开发人员在GitHub上托管他们项目的源代码。例如，您可以查看Elementor页面构建器代码，Zerif Lite主题源代码等等。 但也有WordPress插件可以帮助您更直接地使用Git和WordPress。 例如，VersionPress旨在将Git的强大功能引入常规的WordPress操作，例如更新帖子或安装插件。VersionPress为您的WordPress文件和数据库添加版本控制。 WP Pusher是另一个基于Git的插件，可让您直接从GitHub将主题和插件部署到WordPress网站。 开始使用GitHub 要开始使用GitHub： 注册一个免费的GitHub帐户 按照GitHub Hello World指南了解您可能想要采取的最受欢迎的操作。 官网地址：https://github.com/ 如何加快github下载速度 https://blog.csdn.net/mist99/article/details/80602090 52.216.186.155 github-production-release-asset-2e65be.s3.amazonaws.com service network restart ","link":"https://littlebuzi.github.io/github_learn"},{"title":"疑难杂症","content":"xp的web之旅 环境： 用家里的xp系统，是之前用类似“番茄花园”的整合版安装的。 在尝试各种wamp的版本屡屡碰壁后，试着用其他整合环境： 1.phpstudy 初次采用时，搭建z-blog感觉良好，界面也比较熟悉。 而后的chanzhi与lzcms都同一个错误，you don’t have permisson to aseen it ! ;可能是lzcms的静态没开，但之后开了也没反应，并不能确认是否开成功。 之后发现可能是之恩能够开在linux上！也可能第一次访问后，就默认了一个ip一个网站，再访问其他需要在配置文件里修改加上，但这个可能比较小，因为这违反了www的访问习惯， 在这个目录下，就算是不同系统，如果把他们看成其中一个的分系统，那样也说得清。 2.phpwamp 就是因为phpstudy遇到了这个情况，所以采用phpwamp，感觉这个比他跟老式，不过更加适合我的xp。 用着用着感觉也是和phpstudy差不多，类似于绑定访问的第一个，这次我不用lzcms，我用chanzhicms。也尝试着去改这改那，发现还是不行。 最后，找到了wamp2.2/2.4（之前的假wamp浪费了很多时间），php版本和apache版本也刚好到chanzhi要求。 所以用上了这个wamp，xp真的不容易，各种软件要兼容，在现在这个环境下。 计划：用wamp学tp，最初的想法就是这样，为了混乱原有的环境，想在另一台电脑，xp上弄，结果也不省心。最后可以了 写能执行cmd命令的bat文件 每次运行jar文件时，我总是需要先打开cmd窗口，再切换到我jar文件保存的盘符，再执行java -jar test.jar，虽然操作不是很复杂，但是如果直接写一个bat文件，每次使用直接双击，这种傻瓜式的方式，估计更容易被大家所喜欢并能够方便使用。 方式也很简单，比如： 新建一个txt文本，输入如下： 然后保存为bat文件即可，如果以后路径或者名称有变更的话，直接编辑修改，不用每次再去cmd中输入指令了。 双击即可运行test1.jar的代码啦！ 又或者例如： 更新hexo，同步缓存 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/qq_15158911/article/details/54613948 云计算 docker 参考： https://blog.csdn.net/qq_22211217/article/details/80414227 https://blog.csdn.net/hehailiang_dream/article/details/79983229 https://blog.csdn.net/yr12dong/article/details/80720690 关于网络工程师 考纲： 【中国计算机技术职业资格网(软考)】 2019年官网考纲：http://www.ruankao.org.cn/platform/details?code=02_24 学习资源： 【哔哩哔哩 (゜-゜)つロ 干杯~-bilibili】 1.2019网络工程师【软考】 2.网络工程师考试-视频教程-希赛 下载途径： 1.https://www.jijidown.com/ 2.b站手机版 3.https://github.com/Henryhaohao/Bilibili_video_download 简易桌面 v1.0 总结 项目1：简易桌面1.0 针对于mom使用eclipse为平台制作的第一代，简易桌面软件，目的在于用户的简易操作。 问题：经验总结： 第一：明确目的，时刻纠正方向，走走停停。 第二：确定方向，用图画的方式将界面描绘好，利于以后的代码翻译编写。 第三：在实际编程的过程中，会出现一些小改动，处于临时的灵感，就会对草稿图进行修改，想象计划与实际真的有很大的出入。真的不去实际做一做，可能你永远也不知道。 第四：停留知识水平，框架的基础构建，只是皮毛，经过网上的百度学习，在错误值积累经验，蹒跚学步，跌跌撞撞。做出来还是可以看的，但是技术要求方面不高。达不到要求。 第五：有必要进行一次完整的学习，零碎伴有一些错误的学习经历，危害甚大。一次不完整的学习经历的确可以对往后造成很大的危害。 第六：遇到问题方面；是灵感想法创意的来源。认识到错误，提高自己。做好笔记。 第七，固步自封，井底之蛙，最为致命；以上讨论的比较大概，会做更详细的分析（问题）。 今天导出后 在xp上准备运行 先前研究过得知 需要运行环境jre才能运行可运行jar，在win10（有jre1.8的环境中运行可以）上ok，在xp上时，显示jar直接为一个zip，考虑问题，可能是环境jre安装错误，后面才意识到要安在c盘，还要注册表注册？主要是下载来的jre1.8u151是类似安装包安装在c盘上后的文件夹效果，应该下个安装包。再来试试。正在放到xp上的感觉，xp真的很久很久。以后考虑换成win7，再来，可能会轻松点 简易桌面 v1.0 问题 简易桌面v1.0 问题1:（状态：已解决） 解决：用new Enter（）的方法，比没有想象中的跳转画面，但是衍生出new后，布局排版乱了，按钮飞到最上面，经过移植斗地主的布局代码，经过调试修改，成功解决，ojbk） 问题：以new Enter（）；的形式切换应用节目缺点，画面会跳一下，影响观感，使用体验。 将DDX展开为全屏，原游戏窗口大小不变，流式布局下添加按钮btn，setbounds，背景Lable。 问题二：（未解决） 卡片式切换组件？ 文字+纯色背景→图片→组件→程序 new Enter（）后，前个class会自动隐藏掉 问题三：（simplewindow系统设计） 主界面-音乐播放器 音乐播放器考虑new后会重复播放，而且主界面在new后还在，所以计划把播放器仅仅镶在第一个主界面即可，有难度……应该ok 斗地主界面 推箱子界面 魔兽 相片浏览界面 主菜单 进度50% 音乐界面修改作为主菜单 看相册界面作为主界面与游戏按钮并列的按钮 这两个项目进展可以，遇到的问题很多也解决了很多，github上的代码不错，要达到预期效果还需要经过不断调整，学习。 进度85% 简易桌面 v1.0 错误汇总 问题1：【五子棋退出按钮后序出现多余画面】 注意点1： 【五子棋退出按钮后序出现多余画面】 这是五子棋小游戏的游戏画面 其他地方大致都调试好，运行都ok。 出问题的是红色圈的按钮；“返回桌面” if(event.getSource()==exitbtn){ dispose(); //存在执行后，会继续弹出按钮和面板，再按一次吃咸的“确认”按钮，才能正常关闭 } 详细如下： 当按按钮“返回桌面”时，应该是执行“dispose（）”，一个很直接的关闭窗口命令。 然而出现了这一幕，可能是关乎于: this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setDefaultCloseOperation(JFrame.EXIT_ON_DISPOSE); //（这句dispose） 不知道正确性，就是当关闭窗口时是否停止整个线程？的意思？ 这种情况是出现在用Star()启动时会出现，（frame之间切换的冲突？），单独运行这个五子棋Gobang（），关闭便不会出现这种情况。 注意点2： 【第？个ImagesVewier，尝试通过识别图片分辨率，长和宽来确定他的setbounds和size】 通过识别图片的长和宽，如（图片）width+height&gt;=1800（拟定大小，尽可能小），考虑图片比较小就将其定位于接近框架中间（框架为全屏），并且将其（照片）设为一个800*800（较小）的大小。若width+height&lt;1800，考虑比较大的图片，将其设置为最大窗口大小，后续考虑，图片的长宽比例，进行图片size的调整。 if(width+height&gt;=1800){ iconimage.setbounds(200,200,800,800) } if(width+height&lt;1800){ iconimage.setbounds(350,350,800,800)//拉扯 } 注意点3：按钮监听的两种模式 按钮监听的两种模式：第一种可以监听事件里可以直接使用dispose();而第二种需要如：jFrame.dispose()；this.dispose();????还未100%肯定，待研究 class entend ActionListener { //按钮布局，JButton； 如果是在class里初始化声明了如： JButton DDZButton，BOXButton，WZQButton； 后面接的直接可以是： DDZButton = new JButton(&quot;斗地主&quot;,new ImageIcon(&quot;images/dizhu.gif&quot;)); BOXButton = new JButton(new ImageIcon(&quot;image/bt.jpg&quot;)); WZQButton = new JButton(&quot;五子棋&quot;,new ImageIcon(&quot;images/5son.png&quot;)); DDZButton.setBounds(63,34,180,130); BOXButton.setBounds(64,180,180,133); WZQButton.setBounds(63,331,188,140); this.add(WZQButton); this.add(BOXButton); this.add(DDZButton); //装监听 backButton.addActionListener(this); DDZButton.addActionListener(this); BOXButton.addActionListener(this); public ActionListener{ if(ae.getSource()==DDZButton) { new Main(); } if(ae.getSource()==BOXButton) { new LoginFrame(); } if(ae.getSource()==WZQButton) { new Gobang(); } } } 而如果没有事先声明初始化的话 这样： JButton DDZButton = new JButton(&quot;斗地主&quot;,new ImageIcon(&quot;images/dizhu.gif&quot;)); JButton BOXButton = new JButton(new ImageIcon(&quot;image/bt.jpg&quot;)); JButton WZQButton = new JButton(&quot;五子棋&quot;,new ImageIcon(&quot;images/5son.png&quot;)); DDZButton.xxxxx{ xxxxxxx } //监听都好像不用 注意点4：imagesviwer拥有的功能 github上的这个imagesviwer拥有的功能与其他类型的图片浏览器相比。其具有多了按钮有图标，其他很相似。但意外发现“-&gt;”这个符号。提示错误，是因为这个符号是jdk1.8的新特性。我得eclipse jdk开发环境最高是到1.7，所以。。然后为了解决这个问题，首先装上一个jdk1.8（这里补充jdk是开发环境，jre是运行环境，即导出成可运行jar后，需要先安装对应版本的jre。），关联eclipse后，依然是不行，（具体：依然提醒和之前一样的错误，没有变化）。然后上了eclipse的官网，Oracle上下了个网络安装包，安装了个应该是ee版本的eclipse，最高jdk版本达到1.9（最新），安装打开后，启动画面是什么otion（氧气的英文）。结果导入包后，运行结果：界面出来了，但是按按钮没反应。（图片并未出来，后面有说明）eclipse里提示错误： { Exception in thread &quot;AWT-EventQueue-0&quot; java.lang.NullPointerException at github.ViewerAction.actionPerformed(ViewerAction.java:39) at javax.swing.AbstractButton.fireActionPerformed(Unknown Source) at javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source) at javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source) at javax.swing.DefaultButtonModel.setPressed(Unknown Source) at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown Source) at java.awt.Component.processMouseEvent(Unknown Source) at javax.swing.JComponent.processMouseEvent(Unknown Source) at java.awt.Component.processEvent(Unknown Source) at java.awt.Container.processEvent(Unknown Source) at java.awt.Component.dispatchEventImpl(Unknown Source) at java.awt.Container.dispatchEventImpl(Unknown Source) at java.awt.Component.dispatchEvent(Unknown Source) at java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source) at java.awt.LightweightDispatcher.processMouseEvent(Unknown Source) at java.awt.LightweightDispatcher.dispatchEvent(Unknown Source) at java.awt.Container.dispatchEventImpl(Unknown Source) at java.awt.Window.dispatchEventImpl(Unknown Source) at java.awt.Component.dispatchEvent(Unknown Source) at java.awt.EventQueue.dispatchEventImpl(Unknown Source) at java.awt.EventQueue.access$500(Unknown Source) at java.awt.EventQueue$3.run(Unknown Source) at java.awt.EventQueue$3.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.awt.EventQueue$4.run(Unknown Source) at java.awt.EventQueue$4.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.awt.EventQueue.dispatchEvent(Unknown Source) at java.awt.EventDispatchThread.pumpOneEventForFilters(Unknown Source) at java.awt.EventDispatchThread.pumpEventsForFilter(Unknown Source) at java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source) at java.awt.EventDispatchThread.pumpEvents(Unknown Source) at java.awt.EventDispatchThread.pumpEvents(Unknown Source) at java.awt.EventDispatchThread.run(Unknown Source) Exception in thread &quot;AWT-EventQueue-0&quot; java.lang.NullPointerException at github.ViewerAction.actionPerformed(ViewerAction.java:39) at javax.swing.AbstractButton.fireActionPerformed(Unknown Source) at javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source) at javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source) at javax.swing.DefaultButtonModel.setPressed(Unknown Source) at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown Source) at java.awt.Component.processMouseEvent(Unknown Source) at javax.swing.JComponent.processMouseEvent(Unknown Source) at java.awt.Component.processEvent(Unknown Source) at java.awt.Container.processEvent(Unknown Source) at java.awt.Component.dispatchEventImpl(Unknown Source) at java.awt.Container.dispatchEventImpl(Unknown Source) at java.awt.Component.dispatchEvent(Unknown Source) at java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source) at java.awt.LightweightDispatcher.processMouseEvent(Unknown Source) at java.awt.LightweightDispatcher.dispatchEvent(Unknown Source) at java.awt.Container.dispatchEventImpl(Unknown Source) at java.awt.Window.dispatchEventImpl(Unknown Source) at java.awt.Component.dispatchEvent(Unknown Source) at java.awt.EventQueue.dispatchEventImpl(Unknown Source) at java.awt.EventQueue.access$500(Unknown Source) at java.awt.EventQueue$3.run(Unknown Source) at java.awt.EventQueue$3.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.awt.EventQueue$4.run(Unknown Source) at java.awt.EventQueue$4.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(Unknown Source) at java.awt.EventQueue.dispatchEvent(Unknown Source) at java.awt.EventDispatchThread.pumpOneEventForFilters(Unknown Source) at java.awt.EventDispatchThread.pumpEventsForFilter(Unknown Source) at java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source) at java.awt.EventDispatchThread.pumpEvents(Unknown Source) at java.awt.EventDispatchThread.pumpEvents(Unknown Source) at java.awt.EventDispatchThread.run(Unknown Source) } 但是以前曾经在通过改变里面的图片绝对路径后，显示图片后，按按钮好像第一次不行，之后再试就可以正常运行了。 注意点5：进入斗地主反应（响应）慢 问题一：进入“斗地主小游戏”的时候，反应速度接近7至8秒。其他的小游戏还行。 ","link":"https://littlebuzi.github.io/xp_web"},{"title":"Python & Minecraft","content":"1.用python学习minecraft 原理：用python2.7.6接入mc游戏接口，利用python语句调试mc游戏。 异常：控制台（开服器cmd）有时会出现python调试后（已经开始执行运行一个py时），无反应，游戏也是。按下回车后即可（类似于刷新），才有反应（恢复正常） 最为基础的是这个“将pythonGUI和mc游戏连接起来”具体是python链接进mc提供的接口： 创建一个py格式文件，在myadventure目录下例：buildHouse.py 1.导入需要的模块：【类似于Java的Import】import mcpi.minecraft as minecraftimport mcpi.block as block(还有时间方面的import time) 2.连接Minecraft游戏：【注意大小写，英文冒号以及python语言格式】mc=minecraft.Minecraft.create() 一. 1.在这个网站下载“入门包”：https://www.wiley.com/WileyCDA/Section/id-823690.html 2.python2.7.6下载：https://www.python.org/download/releases/2.7.6/ 二. 1.打开 开服器cmd，开服localhost，使用mc1.6.4客户端连上localhost … ","link":"https://littlebuzi.github.io/minecraft_python"},{"title":"关于博客主题","content":"typecho博客主题修改 以下为修改主题，自定义的一些配置： 原主题地址： Postbird-typecho-two-sidebar-block作者: postbird 版本: 0.0.1Postbird typecho 两栏博客简约主题 了解详情： https://gitee.com/postbird/typecho-blog-theme-two-siderbar 仿docs主题（改进）： 1.导航栏颜色，背景。 2.菜单折叠颜色。 3.模板响应式。 随缘找回来，因为以选择其他主题，有空换一下截个图（然而也没人看，主要是记录修改的规律嗯） 自定义脚本：（百度统计） &lt;script&gt; (function(){ var canonicalURL, curProtocol; //Get the &lt;link&gt; tag var x=document.getElementsByTagName(&quot;link&quot;); //Find the last canonical URL if(x.length &gt; 0){ for (i=0;i&lt;x.length;i++){ if(x[i].rel.toLowerCase() == 'canonical' &amp;&amp; x[i].href){ canonicalURL=x[i].href; } } } //Get protocol if (!canonicalURL){ curProtocol = window.location.protocol.split(':')[0]; } else{ curProtocol = canonicalURL.split(':')[0]; } //Get current URL if the canonical URL does not exist if (!canonicalURL) canonicalURL = window.location.href; //Assign script content. Replace current URL with the canonical URL !function(){var e=/([http|https]:\\/\\/[a-zA-Z0-9\\_\\.]+\\.baidu\\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?&quot;https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif&quot;:&quot;//api.share.baidu.com/s.gif&quot;;t?(n+=&quot;?r=&quot;+encodeURIComponent(document.referrer),r&amp;&amp;(n+=&quot;&amp;l=&quot;+r)):r&amp;&amp;(n+=&quot;?l=&quot;+r);var i=new Image;i.src=n}}(window);})(); &lt;/script&gt; 自定义 stylesheet 样式： .widget { margin-bottom: 0!important; } .list-group-item-info { color: #fff; } #secondary .list-group-item.list-group-item-info { background-color: #343a40!important; } Gridea博客主题修改 顶部导航栏会在纵向滚动条下拉时自动隐藏（淡出），在上拉时在弹出 （给出最大阅读空间，保留上拉出现导航栏，保证功能） 找到Gridea的工作目录： 进入并打开：Gridea\\themes\\lemon\\templates\\includes\\header.ejs 开头添加： &lt;style&gt; .header-navigation { position:fixed; top:0; width:100%; height:60px; line-height:60px; background-color:#333; text-align:center; box-shadow:0 14px 28px rgba(0,0,0,0.25),0 10px 10px rgba(0,0,0,0.22); z-index:9999; } /* Slide transitions */ .slideUp { /* -webkit-transform:translateY(-100px); transform:translateY(-100px); */ -webkit-transform:translateY(-100px); -ms-transform:translateY(-100px); -o-transform:translateY(-100px); transform:translateY(-100px); /*transition:transform .5s ease-out; */ -webkit-transition:transform .5s ease-out; -o-transition:transform .5s ease-out; transition:transform .5s ease-out; } .slideDown { /*-webkit-transform:translateY(0); transform:translateY(0); */ -webkit-transform:translateY(0); -ms-transform:translateY(0); -o-transform:translateY(0); transform:translateY(0); /*transition:transform .5s ease-out; */ -webkit-transition:transform .5s ease-out; -o-transition:transform .5s ease-out; transition:transform .5s ease-out; } &lt;/style&gt; 保存，刷新Gridea，查看效果 ","link":"https://littlebuzi.github.io/typecho_theme"},{"title":"数据库&PHP-问题合集","content":"#关于数据库-mysql账号密码login 数据库——mysql 忘记密码处理： 主要分成两种情况： 第一大种：（集成环境安装的，倾向php，mysql小型数据库） 账号：root 密码： 免密； root； 168168； 123456 等 第二大种：（倾向mysql安装版或压缩版，半集成） 账号：root 密码： （一段字符英文加数字）默认给你设置好，第一次初始化需要手动修改（特色） 如： ABC123xyz Wx&lt;&lt;1Cfdd8&amp;f 新的理解: 在阿里云上安装phpstudy后，第一次进入数据库密码不对，默认数据库密码应为root，所以phpstudy没用他自己的数据库，mysql也启动失败，最后手动启动“服务”里的mysql，查看原有mysql密码，可以了。 #php查询sql 中文乱码“ ？” 查询中文时出现乱码”？？？？1“ 编码检查都是utf-8 之后按照这个，修改了mysql 的 my.ini 三个位置 ok https://blog.csdn.net/u014762625/article/details/80667115 由上图可见database和server的字符集使用了latin1编码方式，不支持中文，即存储中文时会出现乱码。以下修改方法： Linux 系统 (1)关闭mysql服务 service mysql stop (2)修改 /etc/mysql/my.cnf （默认的安装路径） vim /etc/mysql/my.cnf 打开my.cnf后，在文件内的[mysqld]下增加如下两行设置: character_set_server=utf8 init_connect='SET NAMES utf8' 保存退出 (3) 重新启动mysql服务 service mysql restart 完成修改，使用查询命令show variables like 'character%'; 查看编码变为utf8的。 windows系统 打开mysql安装目录，有一个my-default.ini文件，复制一份修改名称my.ini 打开my.ini,加入下面的内容： [mysqld] character-set-server=utf8 [mysql] default-character-set=utf8 [client] default-character-set=utf8 保存，重启mysql服务，完成修改。 ———————————————— 版权声明：本文为CSDN博主「宋宋Jimi」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u014762625/article/details/80667115 以下与标题无关： （记一次记录ip，get ip php语句 安在菜单栏的加载里（数据库查询） 插进数据库 再后台读取） 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 501596098@qq.com 文章标题:php数据库的增删改查及php与javascript之间的交互 本文作者:Buzi 发布时间:2019-07-30, 13:54:07 最后更新:2019-09-18, 15:09:30 原始链接:http://littlebuzi.github.io/2019/07/30/php/mysql_php/ 版权声明: &quot;署名-非商用-相同方式共享 4.0&quot; 转载请保留原文链接及作者。 ","link":"https://littlebuzi.github.io/mysql_web"},{"title":"php数据库的增删改查&php与javascript之间的交互","content":" 这篇文章主要为大家详细介绍了php数据库的增删改查，以及php与javascript之间的交互，具有一定的参考价值，感兴趣的小伙伴们可以参考一下,原地址：https://www.jb51.net/article/122598.htm 使用语言操作数据库是重中之重，如果一门语言你不懂得如何操作数据库，那么你还是没有学会这门语言。 PHP操作数据库的方法并不难 同时php的值还可以与JavaScript脚本之间进行控制 一般是php的值传递到javascript中，一般不会反过来操作 一、基本目标 首先，在mysql中有一张用户信息表user，里面的字段分别是id,username与password，打开网页dbselect.php，首先就用php查出整张user表： 然后，插入数据的一栏，输入数据，就可把数据插入到mysql中的user表当中 在修改数据的一栏中，第一个下拉菜单是通过javascript来创建的，根据表中的数据多少，而给予多少的下拉选项。 第二个下拉菜单让用户选择要修改的列 第三个输入框就是让用户输入要修改的值 至于为什么没有做删除数据，那是因为一来删除数据的操作与修改数据类似，二是因为在自增表中一般不删除数据的，仅仅是设置键值让这条数据隐藏 二、基本思想 程序入口是dbselect.php，操作数据库的过程分别是两个新页面，一个dbinsert.php，一个是dbupdate.php，这两个页面操作完数据库，马上通过javascript返回。 三、制作过程 （1）dbselect.php 也是本实现过程中，最复杂的一个页面 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;dbselect&lt;/title&gt; &lt;/head&gt; &lt;body&gt; user表： &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;username&lt;/td&gt; &lt;td&gt;password&lt;/td&gt; &lt;/tr&gt; &lt;?php //php连接数据库的指定动作，其中第一个root是数据库的用户名，第二个root是数据库的密码 //如果连接失败，马上通过die语句打断后面的所有程序，只输出“连接失败” $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); if(!$con){ die(&quot;连接失败！&quot;); } //要操作test数据库 mysql_select_db(&quot;test&quot;,$con); //total变量是用来记录user记录条数的 $total; //要在test数据库中操作select count(*) as total from user语句并且把结果放到result变量里 $result=mysql_query(&quot;select count(*) as total from user&quot;); //result变量是个数据，$total=$row[&quot;total&quot;];把查询结果中的total列的值赋予给php中的total变量 //$row=mysql_fetch_array($result)能够把当前行的值赋予给row数组，并把游标下移一行，游标并不需要初始化，自动完成 while($row=mysql_fetch_array($result)){ $total=$row[&quot;total&quot;]; } //输出整个表的过程与上面的过程类此 $result=mysql_query(&quot;select * from user&quot;); while($row=mysql_fetch_array($result)){ echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;${row[&quot;id&quot;]}&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;${row[&quot;username&quot;]}&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;${row[&quot;password&quot;]}&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; } //查询完毕，记得人走带门 mysql_close($con); ?&gt; &lt;/table&gt; &lt;br /&gt; &lt;!--以下是两个表单，不再赘述了--&gt; 插入数据： &lt;form action=&quot;dbinsert.php&quot; method=&quot;get&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; password:&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go!&quot; /&gt; &lt;/form&gt; 修改数据： &lt;form action=&quot;dbupdate.php&quot; method=&quot;get&quot;&gt; &lt;select id=&quot;userid&quot; name=&quot;userid&quot;&gt;&lt;/select&gt; &lt;script&gt; //这是php与javascript交互部分，把上面求出来的php的$total变量，赋予给javascript的var total var total=&lt;?php echo $total; ?&gt;; var i=1; for(i=1;i&lt;total+1;i++){ //javascript增加节点过程 var selectnode=document.createElement(&quot;option&quot;); selectnode.value=i; selectnode.innerHTML=i; document.getElementById(&quot;userid&quot;).appendChild(selectnode); } &lt;/script&gt; &lt;select name=&quot;rowname&quot;&gt; &lt;option value=&quot;username&quot;&gt;username&lt;/option&gt; &lt;option value=&quot;password&quot;&gt;password&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; name=&quot;rowtext&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;go!&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; javascript控制html节点的详细，可以参照我之前写的《【JavaScript】网页节点的增删改查》一文（点击打开链接） （2）dbinsert.php &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;dbinsert.php&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php //首先从dbselect.php的表单中接受操作的数据 //dbselect.php故意用到get方法，只是想说明php中对get与post的处理同样可以通过$_REQUEST[&quot;变量名&quot;]来实现 $username=$_REQUEST[&quot;username&quot;]; $password=$_REQUEST[&quot;password&quot;]; //操作数据库的指定动作同dbselect.php。 $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); if(!$con){ die(&quot;连接失败！&quot;); } mysql_select_db(&quot;test&quot;,$con); //控制数据库比dbselect.php更加简单，因为不用对数据库的查询结果进行处理 //只是要注意，这里连接字符串是用到.的，而不是jsp的+，asp的&amp;，请注意！ mysql_query(&quot;insert into user(username,password) values ('&quot;.$username.&quot;','&quot;.$password.&quot;');&quot;); mysql_close($con); ?&gt; &lt;script&gt; alert(&quot;添加成功&quot;); window.location.href=&quot;dbselect.php&quot; rel=&quot;external nofollow&quot; rel=&quot;external nofollow&quot; ; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （3）dbupdate.php 与dbinsert.php逻辑是一模一样的，只是mysql_query那个的查询语句，从insert into语句变成了update语句而已 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $userid=$_REQUEST[&quot;userid&quot;]; $rowname=$_REQUEST[&quot;rowname&quot;]; $rowtext=$_REQUEST[&quot;rowtext&quot;]; $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); if(!$con){ die(&quot;连接失败！&quot;); } mysql_select_db(&quot;test&quot;,$con); mysql_query(&quot;update user set &quot;.$rowname.&quot;='&quot;.$rowtext.&quot;' where id=&quot;.$userid.&quot;;&quot;); mysql_close($con); ?&gt; &lt;script&gt; alert(&quot;修改成功&quot;); window.location.href=&quot;dbselect.php&quot; rel=&quot;external nofollow&quot; rel=&quot;external nofollow&quot; ; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以上，就是整个制作过程。 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 501596098@qq.com 文章标题:php数据库的增删改查及php与javascript之间的交互 本文作者:Buzi 发布时间:2019-07-30, 13:54:07 最后更新:2019-09-18, 15:09:30 原始链接:http://littlebuzi.github.io/2019/07/30/php/mysql_php/ 版权声明: &quot;署名-非商用-相同方式共享 4.0&quot; 转载请保留原文链接及作者。 ","link":"https://littlebuzi.github.io/mysql_php"},{"title":"企业建站-问题合集","content":"#部署-巅云自助建站系统3.0学习试用 1.刚用的时候，phpwamp运行，结果乱码。改用wamp也是。改utf-8源码标签，不行。最后尝试改index为utf-8记事本保存可以。但剩下的文件手动改不可能。就用了个批量改文件软件把所有格式的文件都改成utf-8，改动中，提示“.db”,修改不成功。最后改完，运行。还是乱码，记事本打开，还是utf-8编码。。。最后把说明看一遍，有个地方：阿帕奇和php版本有要求（好像阿帕奇没说），php版本说要5.3-5.6，不信邪换了下，真的行了。。。 所以，需看清php版本！！！ #dicuz不支持php7以及以上 on wamp wamp部署discuzx时： wamp版本： discuzx： （正好遇上discuzx关闭，貌似） 放进www下后发现，报错： 原因dicuz不支持php7以及以上（我的运行时是php7.2非5.6） 所以屏蔽掉这里 /install/index.php 即可！ 访问空白 https://gitee.com/3dming/DiscuzL/attach_files 这个可行！ ","link":"https://littlebuzi.github.io/dianyun"},{"title":"二次元资讯网站","content":" 二次元资讯网站 练手(cms_wordpress方向研究) + 兴趣（二次元） 基于/环境 1.wordpress（php） 2.mysql 3.wampserver 图片 首页1 首页2 目录分类 登录注册 文章 排行版 手机版 ","link":"https://littlebuzi.github.io/Quadratic_element"},{"title":"帝国时代Ⅱ—2018年世界高手排名前10","content":" NO1.Theviper 🏆 挪威人 28岁 属于战队：神队 2011-2018年至今还是保持着世界第一的位置，帝国时代历史上第一个最久的世界第一玩家，世界大赛无论团战或者单挑获过无数次冠军。打局风格：全能型，经济和军事平衡接近完美，比赛非常认真投入，娱乐局就喜欢非主流玩法较多，评分：9.9分 RANK积分2700+ NO2.Liereyy 又名 天才少年 奥地利人 17岁 未来世界第一，所属战队：AM 2017年初RANK积分2300+，后面有一次和DAUT打过一次比赛用MM左右摇摆躲开DAUT船的攻击，吸引了所有玩家的眼球，进步神速，具有非常恐怖的手速，后面再次和VIP交手几次单挑赛比分接近都遗憾输了，也许是太年轻了，需要时间来磨练心态和经验，但是除了VIP世界上没人打得过他，打局风格：经济完美，微操完美，评分9.8分 RANK积分2680+ NO3.TheMax 芬兰人 24岁 世界第一团战王 所属战队：芬兰队 2017年MAX带进芬兰队杀入国家杯决赛，MAX是我的偶像，因为他常常做了没人做的到事情，常常在超级逆风局里面可以1V3甚至1V4 CARRY全场，分明分基本第一，中后期具有爆发力的一个玩家，因为他的队友并不是很厉害，如果队友可以拖到中后期MAX就可以带领他们走向胜利。打局风格：围家，经济完美，后期18线操作，评分9.7 RANK积分2550+ NO4.YO 又名 猜火车 中国人 26岁 所属战队：中国SY，2011年出道，单挑和多人基本都非常细致，，具有灵气的一位选手，不慌不忙，近年来比赛都非常出众，2016年带领SY在王者之师世界大赛上击败神队获得冠军，今年的封心比赛获得冠军，打局风格：全能型选手，沉稳，问题不大，后期发力，评分9.7分 RANK积分2600+ NO5.LYX 又名 冲动 中国人 30岁 所属战队:中国SY,2009年就非常厉害了，2012年在VIP巅峰时期冲动连日VIP几局，成为了很多玩家的偶像，搞事情特别强，偷猪，围资源，阴塔能力非常犀利，经验丰富，意识流玩家，2016年带领中国SY在王者之师大赛击败神队获得冠军，多人局作用非常大，最愿意牺牲的一个玩家，现在无论单挑和多人局都是非常具有观赏性的玩家，打局风格：全能型，能打能坑能奶，直播经典语录：我艹这个傻逼，评分9.6分 RANK积分2500+ NO6.VIVI 又名肥龙 当年情 中国人25岁 所属战队：中国疯狂 08年出道，09年在征服地带非常出名，因为喜欢骂人，然后所有人骂我傻逼，我就非常出名了，2012年积分打到2200+然后退役，打LOL。2016年复出，16年带领CR队在王者之师拿了第四，17年带领疯狂队拿了国家杯第三，近期在微软大赛上做了很多人认为做不到的事情，0比2落后的情况上连反天才少年3局，好了不吹逼了，打局风格： 前期非常凶，后期也不差，兄弟，不要慌，等我升曾瑞。评分9.6分 RANK 积分2600+ NO7.NICOV 阿根廷人 25岁 所属战队：AM队 NICOV2016积分打到世界第一，吸了无数粉丝，阿拉伯单挑非常凶，那时候肥龙老师跟车老师都深深对他有恐惧感，多次被打哭，当时好多人认为他是VIP的接班人，但毕竟是阿拉伯地图出众，他的经济调配非常极限，城堡一波带走了对手，但是比赛的时候的心态容易崩，，今年封心举办的单挑赛就可以看得出来，在积分遥遥领先的情况下被车老师赶超，但是多人局也非常出色，在今年的非洲王朝带领AM队拿了亚军，打局风格：经济极限 前期很凶 后期也不错，评分9.5分 积分2550+ NO8.MBL 挪威人 24岁 所属战队 AM队 MBL这个玩家一直非常活跃在国际积分平台，AM队创始人，MBL很多人认为他比较菜，但是他的后期超级猛，喜欢偷经济，防守拖到帝王时代发力，因为他后期能种100块农田，打不死你耗死你，真正的经济流玩家，最近的阿拉伯大师赛获得击败火车获得冠军，还有国际现场公寓杯在VIP3比1领先的情况下连反VIP3局击败VIP，有时候非常猛有时候非常懵逼的玩家之一，也具有灵气的打法，让对手不知道他在干嘛，打局风格：种田为主，搭爆自己，防守为主，评分9.5分 积分2600+ NO9.DAUT 塞黑人 32岁 所属战队：神队 DAUT拿过无数次世界冠军，前世界第一， DAUT在没有VIP出现之前基本都是世界第一，但是现在也非常凶猛，经济军事和意识都还是保持在高水准，单挑没人敢说包赢他，经验丰富，意识老辣，经济非常出众，今年在非洲王朝的大赛上带领神队击败AM获得冠军，打局风格：进攻后发展，经济发展非常快，比较出名的一句话，DAUT castle 评分9.4分 RANK积分 2500+ NO10.RIUT 巴西人 25岁 所属战队：巴西队 RIUT是早期非常出名的选手，曾经的世界第二，打局非常沉稳又非常猛，在很早年前就拿过N次冠军，但是最近比较少玩，只在比赛的时候出现，水平依然高水准，早期在神队玩，现在在巴西队，RIUT之前是老外最喜欢的玩家，因为进攻犀利，微操细致，非常沉稳，对线基本不会蹦 ，得了很多人的认可，打局风格：细致 快而不乱 进攻非常凶猛，打手级别，评分9.4分 RANK积分2500+ 转载自斗鱼鱼吧：https://yuba.douyu.com/p/425315671538341464 主播：肥龙最帅最牛B ","link":"https://littlebuzi.github.io/diguo"},{"title":"GitHub","content":"你所使用的很多开源程序都是在Github上 从较高的层面来说，GitHub是一个基于网站和云的服务，可以帮助开发人员存储和管理他们的代码，以及跟踪和控制对代码的更改。要准确理解GitHub是什么，您需要了解两个相关原则： 版本控制 Git 在本文中，我们将首先解释这两个原则。然后，我们将深入研究GitHub，以及如何使用GitHub与WordPress一起工作。 版本控制 版本控制可帮助开发人员跟踪和管理软件项目代码的更改。随着软件项目的发展，版本控制变得至关重要。以WordPress为例...... 在这一点上，WordPress是一个非常大的项目。如果核心开发人员想要在WordPress代码库的某个特定部分上工作，那么让他们直接编辑“官方”源代码是不安全或有效的。 相反，版本控制允许开发人员安全地完成分支和合并。 通过分支，开发人员复制部分源代码（称为存储库）。然后，开发人员可以安全地更改代码的这一部分，而不会影响项目的其余部分。 然后，一旦开发人员使他或她的部分代码正常工作，他或她就可以将该代码合并回主要源代码以使其正式化。 然后跟踪所有这些更改，并在需要时可以还原。 Git Git是Linus Torvalds于2005年创建的一个特定的开源版本控制系统。 具体来说，Git是一个分布式版本控制系统，这意味着每个开发人员的计算机上都可以使用整个代码库和历史记录，这样可以轻松进行分支和合并。 根据Stack Overflow开发人员调查，超过87％的开发人员使用Git。 GitHub GitHub是一家营利性公司，提供基于云的Git存储库托管服务。从本质上讲，它使个人和团队更容易使用Git进行版本控制和协作。 GitHub的界面足够用户友好，所以即使是新手编程也可以利用Git。如果没有GitHub，使用Git通常需要更多娴熟技术并使用命令行。 GitHub是如此用户友好，有些人甚至使用GitHub来管理其他类型的项目 - 比如写书。 此外，任何人都可以免费注册和托管公共代码存储库，这使得GitHub特别受开源项目的欢迎。 作为一家公司，GitHub通过销售托管私有代码存储库以及其他以业务为中心的计划来赚钱，这些计划使组织更容易管理团队成员和安全性。 探索GitHub接口 为了让您基本了解GitHub接口的外观，这里是GitHub存储库中托管的WordPress源代码： 从这里，您可以查看正在处理的各个分支，以及有人进行提交时（这有点像“保存”文件）。根据存储库的设置方式，您也可以创建自己的分支并在那里进行自己的提交。 一旦进行了一些更改，您就可以通过发出拉取请求将该代码提交回分支。拉取请求基本上是要求分支机构的负责人包含您的代码。它还可以帮助那个人准确地看到你在代码中改变了什么。 如果你想更长久地在你自己的帐户上编辑部分或全部WordPress源代码，你也可以通过单击Fork按钮来叉它（叉子在概念上类似于分支，但是fork更永久）： 使用Git和GitHub与WordPress 许多WordPress主题和插件开发人员在GitHub上托管他们项目的源代码。例如，您可以查看Elementor页面构建器代码，Zerif Lite主题源代码等等。 但也有WordPress插件可以帮助您更直接地使用Git和WordPress。 例如，VersionPress旨在将Git的强大功能引入常规的WordPress操作，例如更新帖子或安装插件。VersionPress为您的WordPress文件和数据库添加版本控制。 WP Pusher是另一个基于Git的插件，可让您直接从GitHub将主题和插件部署到WordPress网站。 开始使用GitHub 要开始使用GitHub： 注册一个免费的GitHub帐户 按照GitHub Hello World指南了解您可能想要采取的最受欢迎的操作。 官网地址：https://github.com/ ","link":"https://littlebuzi.github.io/github"},{"title":"阿尔法狗的工作原理及核心技术","content":"阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能程序，由谷歌（Google）旗下DeepMind公司戴密斯·哈萨比斯领衔的团队开发。 那么阿尔法狗的工作原理是什么？相关技术又有哪些呢？下面让我们一起来看看。 工作原理 阿尔法围棋（AlphaGo）为了应对围棋的复杂性，结合了监督学习和强化学习的优势。它通过训练形成一个策略网络（policynetwork），将棋盘上的局势作为输入信息，并对所有可行的落子位置生成一个概率分布。然后，训练出一个价值网络（valuenetwork）对自我对弈进行预测，以-1（对手的绝对胜利）到1（AlphaGo的绝对胜利）的标准，预测所有可行落子位置的结果。这两个网络自身都十分强大，而阿尔法围棋将这两种网络整合进基于概率的蒙特卡罗树搜索（MCTS）中，实现了它真正的优势。新版的阿尔法围棋产生大量自我对弈棋局，为下一代版本提供了训练数据，此过程循环往复。 在获取棋局信息后，阿尔法围棋会根据策略网络（policynetwork）探索哪个位置同时具备高潜在价值和高可能性，进而决定最佳落子位置。在分配的搜索时间结束时，模拟过程中被系统最频繁考察的位置将成为阿尔法围棋的最终选择。在经过先期的全盘探索和过程中对最佳落子的不断揣摩后，阿尔法围棋的搜索算法就能在其计算能力之上加入近似人类的直觉判断 围棋棋盘是19x19路，所以一共是361个交叉点，每个交叉点有三种状态，可以用1表示黑子，-1表示白字，0表示无子，考虑到每个位置还可能有落子的时间、这个位置的气等其他信息，我们可以用一个361*n维的向量来表示一个棋盘的状态。我们把一个棋盘状态向量记为s。 当状态s下，我们暂时不考虑无法落子的地方，可供下一步落子的空间也是361个。我们把下一步的落子的行动也用361维的向量来表示，记为a。 这样，设计一个围棋人工智能的程序，就转换成为了，任意给定一个s状态，寻找最好的应对策略a，让你的程序按照这个策略走，最后获得棋盘上最大的地盘。 三大核心技术 AlphaGo结合了3大块技术：先进的搜索算法、机器学习算法（即强化学习），以及深度神经网络。这三者的关系大致可以理解为： 1、蒙特卡洛树搜索（MCTS）是大框架 实质上可以看成一种增强学习 蒙特卡罗树搜索（MCTS）会逐渐的建立一颗不对称的树。可以分为四步并反复迭代： （1）选择 从根节点，也就是要做决策的局面R出发向下选择一个最急迫需要被拓展的节点T；局面R是第一个被检查的节点，被检查的节点如果存在一个没有被评价过的招式m，那么被检查的节点在执行m后得到的新局面就是我们所需要展开的T；如果被检查的局面所有可行的招式已经都被评价过了，那么利用ucb公式得到一个拥有最大ucb值的可行招式，并且对这个招式产生的新局面再次进行检查；如果被检查的局面是一个游戏已经结束的游戏局面，那么直接执行步骤4；通过反复的进行检查，最终得到一个在树的最底层的最后一次被检查的局面c和它的一个没有被评价过的招式m，执行步骤2。 （2）拓展 对于此时存在于内存中的局面c，添加一个它的子节点。这个子节点由局面c执行招式m而得到，也就是T。 （3）模拟 从局面T出发，双方开始随机的落子。最终得到一个结果（win/lost），以此更新T节点的胜利率。 （4）反向传播 在T模拟结束之后，它的父节点c以及其所有的祖先节点依次更新胜利率。一个节点的胜利率为这个节点所有的子节点的平均胜利率。并从T开始，一直反向传播到根节点R，因此路径上所有的节点的胜利率都会被更新。 之后，重新从第一步开始，不断地进行迭代。使得添加的局面越来越多，则对于R所有的子节点的胜利率也越来越准。最后，选择胜利率最高的招式。 实际应用中，mcts还可以伴随非常多的改进。我描述的这个算法是mcts这个算法族中最出名的uct算法，现在大部分著名的ai都在这个基础上有了大量的改进了。 2、强化学习（RL）是学习方法，用来提升AI的实力。 2、强化学习 （RL） 是学习方法，用来提升AI的实力 强化学习是从动物学习、参数扰动自适应控制等理论发展而来，其基本原理是： 如果Agent的某个行为策略导致环境正的奖赏（强化信号），那么Agent以后产生这个行为策略的趋势便会加强。Agent的目标是在每个离散状态发现最优策略以使期望的折扣奖赏和最大。 强化学习把学习看作试探评价过程，Agent选择一个动作用于环境，环境接受该动作后状态发生变化，同时产生一个强化信号（奖或惩）反馈给Agent，Agent根据强化信号和环境当前状态再选择下一个动作，选择的原则是使受到正强化（奖）的概率增大。选择的动作不仅影响立即强化值，而且影响环境下一时刻的状态及最终的强化值。 强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是Agent对所产生动作的好坏作一种评价（通常为标量信号），而不是告诉Agent如何去产生正确的动作。由于外部环境提供了很少的信息，Agent必须靠自身的经历进行学习。通过这种方式，Agent在行动一一评价的环境中获得知识，改进行动方案以适应环境。 强化学习系统学习的目标是动态地调整参数，以达到强化信号最大。若已知r/A梯度信息，则可直接可以使用监督学习算法。因为强化信号r与Agent产生的动作A没有明确的函数形式描述，所以梯度信息r/A无法得到。因此，在强化学习系统中，需要某种随机单元，使用这种随机单元，Agent在可能动作空间中进行搜索并发现正确的动作。 3、深度神经网络（DNN）是工具，用来拟合局面评估函数和策略函数 深度神经网络，也被称为深度学习，是人工智能领域的重要分支，根据麦卡锡（人工智能之父）的定义，人工智能是创造像人一样的智能机械的科学工程。 通过比较当前网络的预测值和我们真正想要的目标值，再根据两者的差异情况来更新每一层的权重矩阵（比如，如果网络的预测值高了，就调整权重让它预测低一些，不断调整，直到能够预测出目标值）。因此就需要先定义“如何比较预测值和目标值的差异”，这便是损失函数或目标函数（lossfuncTIonorobjecTIvefuncTIon），用于衡量预测值和目标值的差异的方程。lossfuncTIon的输出值（loss）越高表示差异性越大。那神经网络的训练就变成了尽可能的缩小loss的过程。 所用的方法是梯度下降（Gradientdescent）：通过使loss值向当前点对应梯度的反方向不断移动，来降低loss。一次移动多少是由学习速率（learningrate）来控制的。 总结 这三大技术都不是AlphaGo或者DeepMind团队首创的技术。但是强大的团队将这些结合在一起，配合Google公司强大的计算资源，成就了历史性的飞跃。 ","link":"https://littlebuzi.github.io/AlphaGo"},{"title":"emoji表情大全😁","content":"表情 😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠 人物 👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪 手势 💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍ 日常 👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂 手机 📱📲📶📳📴☎📞📟📠 公共 ♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈 动物 🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋 植物 💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃 自然 🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊 饮食 🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴 文体 🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬 恐怖 😈👿👹👺💀☠👻👽👾💣 旅游 🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅 物品 💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨 标志 ♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵 生肖 🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖 星座 ♈♉♊♋♌♍♎♏♐♑♒♓⛎ 钟表 🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰 心形 💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣ 花草 💐🌸💮🌹🌺🌻🌼🌷🌱🌿🍀 树叶 🌿🍀🍁🍂🍃 月亮 🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝 水果 🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓 钱币 💴💵💶💷💰💸💳 交通 🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀 建筑 🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🌆🌇🌉 办公 📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑 箭头 ⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝 ","link":"https://littlebuzi.github.io/emoji"}]}