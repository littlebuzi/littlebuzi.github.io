<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>buzi</title>
<meta name="description" content="记录平凡的修炼之路" />
<link rel="shortcut icon" href="https://littlebuzi.github.io//favicon.ico?v=1590852741451">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://littlebuzi.github.io//styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://littlebuzi.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://littlebuzi.github.io//images/avatar.png?v=1590852741451" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">buzi</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li>
<li><a href="#%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF">三大核心技术</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          时间线
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          分类
        </a>
      
    
      
        <a href="https://littlebuzi.github.io/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://littlebuzi.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">阿尔法狗的工作原理及核心技术</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-07-29 / 8 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1565870241986&amp;di=383ccd2d847fedd599e3da0101ad465b&amp;imgtype=0&amp;src=http%3A%2F%2Fimg1.mydrivers.com%2Fimg%2F20170517%2F1cc234d8d8374d52af0041518537835a.jpg" alt="">
        
        <div class="post-content yue">
          <p>阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能程序，由谷歌（Google）旗下DeepMind公司戴密斯·哈萨比斯领衔的团队开发。</p>
<figure data-type="image" tabindex="1"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1565869684301&amp;di=ccccf3de2ab4799226a3d04d675c2b02&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D857300518%2C626260855%26fm%3D214%26gp%3D0.jpg" alt="img" loading="lazy"></figure>
<p>那么阿尔法狗的工作原理是什么？相关技术又有哪些呢？下面让我们一起来看看。</p>
<h1 id="工作原理">工作原理</h1>
<p>阿尔法围棋（AlphaGo）为了应对围棋的复杂性，结合了监督学习和强化学习的优势。它通过训练形成一个策略网络（policynetwork），将棋盘上的局势作为输入信息，并对所有可行的落子位置生成一个概率分布。然后，训练出一个价值网络（valuenetwork）对自我对弈进行预测，以-1（对手的绝对胜利）到1（AlphaGo的绝对胜利）的标准，预测所有可行落子位置的结果。这两个网络自身都十分强大，而阿尔法围棋将这两种网络整合进基于概率的蒙特卡罗树搜索（MCTS）中，实现了它真正的优势。新版的阿尔法围棋产生大量自我对弈棋局，为下一代版本提供了训练数据，此过程循环往复。</p>
<p>在获取棋局信息后，阿尔法围棋会根据策略网络（policynetwork）探索哪个位置同时具备高潜在价值和高可能性，进而决定最佳落子位置。在分配的搜索时间结束时，模拟过程中被系统最频繁考察的位置将成为阿尔法围棋的最终选择。在经过先期的全盘探索和过程中对最佳落子的不断揣摩后，阿尔法围棋的搜索算法就能在其计算能力之上加入近似人类的直觉判断</p>
<figure data-type="image" tabindex="2"><img src="https://littlebuzi.github.io//post-images/1564405131415.jpg" alt="" loading="lazy"></figure>
<p>围棋棋盘是19x19路，所以一共是361个交叉点，每个交叉点有三种状态，可以用1表示黑子，-1表示白字，0表示无子，考虑到每个位置还可能有落子的时间、这个位置的气等其他信息，我们可以用一个361*n维的向量来表示一个棋盘的状态。我们把一个棋盘状态向量记为s。</p>
<p>当状态s下，我们暂时不考虑无法落子的地方，可供下一步落子的空间也是361个。我们把下一步的落子的行动也用361维的向量来表示，记为a。</p>
<p>这样，设计一个围棋人工智能的程序，就转换成为了，任意给定一个s状态，寻找最好的应对策略a，让你的程序按照这个策略走，最后获得棋盘上最大的地盘。</p>
<h1 id="三大核心技术">三大核心技术</h1>
<p>AlphaGo结合了3大块技术：先进的搜索算法、机器学习算法（即强化学习），以及深度神经网络。这三者的关系大致可以理解为：</p>
<p>1、蒙特卡洛树搜索（MCTS）是大框架</p>
<figure data-type="image" tabindex="3"><img src="https://littlebuzi.github.io//post-images/1564405159769.jpg" alt="" loading="lazy"></figure>
<p>实质上可以看成一种增强学习</p>
<p>蒙特卡罗树搜索（MCTS）会逐渐的建立一颗不对称的树。可以分为四步并反复迭代：</p>
<p>（1）选择</p>
<p>从根节点，也就是要做决策的局面R出发向下选择一个最急迫需要被拓展的节点T；局面R是第一个被检查的节点，被检查的节点如果存在一个没有被评价过的招式m，那么被检查的节点在执行m后得到的新局面就是我们所需要展开的T；如果被检查的局面所有可行的招式已经都被评价过了，那么利用ucb公式得到一个拥有最大ucb值的可行招式，并且对这个招式产生的新局面再次进行检查；如果被检查的局面是一个游戏已经结束的游戏局面，那么直接执行步骤4；通过反复的进行检查，最终得到一个在树的最底层的最后一次被检查的局面c和它的一个没有被评价过的招式m，执行步骤2。</p>
<p>（2）拓展</p>
<p>对于此时存在于内存中的局面c，添加一个它的子节点。这个子节点由局面c执行招式m而得到，也就是T。</p>
<p>（3）模拟</p>
<p>从局面T出发，双方开始随机的落子。最终得到一个结果（win/lost），以此更新T节点的胜利率。</p>
<p>（4）反向传播</p>
<p>在T模拟结束之后，它的父节点c以及其所有的祖先节点依次更新胜利率。一个节点的胜利率为这个节点所有的子节点的平均胜利率。并从T开始，一直反向传播到根节点R，因此路径上所有的节点的胜利率都会被更新。</p>
<p>之后，重新从第一步开始，不断地进行迭代。使得添加的局面越来越多，则对于R所有的子节点的胜利率也越来越准。最后，选择胜利率最高的招式。</p>
<p>实际应用中，mcts还可以伴随非常多的改进。我描述的这个算法是mcts这个算法族中最出名的uct算法，现在大部分著名的ai都在这个基础上有了大量的改进了。　　2、强化学习（RL）是学习方法，用来提升AI的实力。</p>
<p>2、强化学习 （RL） 是学习方法，用来提升AI的实力</p>
<figure data-type="image" tabindex="4"><img src="https://littlebuzi.github.io//post-images/1564405201806.jpg" alt="" loading="lazy"></figure>
<p>强化学习是从动物学习、参数扰动自适应控制等理论发展而来，其基本原理是：</p>
<p>如果Agent的某个行为策略导致环境正的奖赏（强化信号），那么Agent以后产生这个行为策略的趋势便会加强。Agent的目标是在每个离散状态发现最优策略以使期望的折扣奖赏和最大。</p>
<p>强化学习把学习看作试探评价过程，Agent选择一个动作用于环境，环境接受该动作后状态发生变化，同时产生一个强化信号（奖或惩）反馈给Agent，Agent根据强化信号和环境当前状态再选择下一个动作，选择的原则是使受到正强化（奖）的概率增大。选择的动作不仅影响立即强化值，而且影响环境下一时刻的状态及最终的强化值。</p>
<p>强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是Agent对所产生动作的好坏作一种评价（通常为标量信号），而不是告诉Agent如何去产生正确的动作。由于外部环境提供了很少的信息，Agent必须靠自身的经历进行学习。通过这种方式，Agent在行动一一评价的环境中获得知识，改进行动方案以适应环境。</p>
<p>强化学习系统学习的目标是动态地调整参数，以达到强化信号最大。若已知r/A梯度信息，则可直接可以使用监督学习算法。因为强化信号r与Agent产生的动作A没有明确的函数形式描述，所以梯度信息r/A无法得到。因此，在强化学习系统中，需要某种随机单元，使用这种随机单元，Agent在可能动作空间中进行搜索并发现正确的动作。</p>
<p>3、深度神经网络（DNN）是工具，用来拟合局面评估函数和策略函数</p>
<figure data-type="image" tabindex="5"><img src="https://littlebuzi.github.io//post-images/1564405219777.jpg" alt="" loading="lazy"></figure>
<p>深度神经网络，也被称为深度学习，是人工智能领域的重要分支，根据麦卡锡（人工智能之父）的定义，人工智能是创造像人一样的智能机械的科学工程。</p>
<p>通过比较当前网络的预测值和我们真正想要的目标值，再根据两者的差异情况来更新每一层的权重矩阵（比如，如果网络的预测值高了，就调整权重让它预测低一些，不断调整，直到能够预测出目标值）。因此就需要先定义“如何比较预测值和目标值的差异”，这便是损失函数或目标函数（lossfuncTIonorobjecTIvefuncTIon），用于衡量预测值和目标值的差异的方程。lossfuncTIon的输出值（loss）越高表示差异性越大。那神经网络的训练就变成了尽可能的缩小loss的过程。</p>
<p>所用的方法是梯度下降（Gradientdescent）：通过使loss值向当前点对应梯度的反方向不断移动，来降低loss。一次移动多少是由学习速率（learningrate）来控制的。</p>
<h1 id="总结">总结</h1>
<p>这三大技术都不是AlphaGo或者DeepMind团队首创的技术。但是强大的团队将这些结合在一起，配合Google公司强大的计算资源，成就了历史性的飞跃。</p>
<figure data-type="image" tabindex="6"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1565870222258&amp;di=a20450ac8a150317128e91ab4319cbea&amp;imgtype=0&amp;src=http%3A%2F%2Fe-images.juwaistatic.com%2F2017%2F10%2Falphago-zero-e1508483004369.jpg" alt="img" loading="lazy"></figure>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://littlebuzi.github.io/N4SH6d1dT">
            <span class="flex-auto">科学</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://littlebuzi.github.io/github">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  GitHub
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://littlebuzi.github.io/emoji">
                <h3 class="post-title">
                  emoji表情大全😁
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'e7c2b33da7e627d57c5a',
    clientSecret: '70bd30bae9adc0e0559d863df193af430483bcd1',
    repo: 'littlebuzi.github.io',
    owner: 'littlebuzi',
    admin: ['littlebuzi'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://littlebuzi.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
