<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://littlebuzi.github.io/</id>
    <title>buzi</title>
    <updated>2020-04-12T15:22:59.040Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://littlebuzi.github.io/"/>
    <link rel="self" href="https://littlebuzi.github.io/atom.xml"/>
    <subtitle>记录平凡的修炼之路</subtitle>
    <logo>https://littlebuzi.github.io/images/avatar.png</logo>
    <icon>https://littlebuzi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, buzi</rights>
    <entry>
        <title type="html"><![CDATA[PHP基础学习笔记(下)]]></title>
        <id>https://littlebuzi.github.io/learn_php_2</id>
        <link href="https://littlebuzi.github.io/learn_php_2">
        </link>
        <updated>2020-04-11T04:27:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文章是继PHP基础学习笔记（上）的下篇，主要记录php基础知识，资源整合自慕课网。</p>
</blockquote>
<hr>
<h1 id="一-数组定义">一、数组定义</h1>
<p>数组就是一个键值对组成的语言结构，键类似于酒店的房间号，值类似于酒店房间里存储的东西。</p>
<pre><code class="language-php">$arr = array();
</code></pre>
<p>表示创建一个空数组，并把创建的空数组赋值给变量$arr。</p>
<h2 id="索引数组初始化">索引数组初始化</h2>
<p>PHP有两种数组：索引数组、关联数组。<br>
索引和关联两个词都是针对数组的键而言的。</p>
<p>索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。</p>
<pre><code class="language-php">fruit
|香蕉|苹果|雪梨|
|:-|:-:|-:|
|0|1|2|

$fruit = array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;); 
print_r($fruit);
</code></pre>
<h2 id="索引数组赋值">索引数组赋值</h2>
<p>赋值有三种方式:</p>
<pre><code class="language-php">$arr[0]='苹果';
array('0'=&gt;'苹果');
$arr = array('0'=&gt;'苹果');
if( isset($arr) ) {print_r($arr);}
</code></pre>
<p>isset（） 函数是检查 括号内的是否被定义了，定义为null 也表示true。</p>
<h2 id="索引数组内容">索引数组内容</h2>
<pre><code class="language-php">$fruit = array('苹果','香蕉');
$fruit0 = $fruit['0'];
print_r($fruit0);//结果为苹果
</code></pre>
<h2 id="循环访问索引数组里的值">循环访问索引数组里的值</h2>
<pre><code class="language-php">$fruit=array('苹果','香蕉','菠萝');

// for循环
for($i=0; $i&lt;3; $i++){
    echo '&lt;br&gt;数组第'.$i.'值是：'.$fruit[$i];
}

//foreach循环
foreach($fruit as $key=&gt;$value){
    echo '&lt;br&gt;第'.$key.'值是：';
}
</code></pre>
<h2 id="关联数组初始化">关联数组初始化</h2>
<pre><code class="language-php">// 创建一个关联数组，关联数组的键“orange”，值是“橘子”
$fruit = array(
    // 关联数组赋值
    'apple'=&gt;&quot;苹果&quot;,
    'banana'=&gt;&quot;香蕉&quot;,
    'pineapple'=&gt;&quot;菠萝&quot;
); 

// 访问关联数组内容
$fruit0 = $fruit['banana'];
print_r($fruit0);

// foreach循环访问关联数组里的值
foreach($fruit as $k=&gt;$v){
    echo '&lt;br&gt;水果的英文键名：'.$k.'，对应的值是：'.$v;
</code></pre>
<h1 id="二-类和对象">二、类和对象</h1>
<p>类是面向对象程序设计的基本概念，通俗的理解类就是对现实中某一个种类的东西的抽象。<br>
如汽车可以抽象为一个类，<br>
属性：名字、轮胎、速度、重量等，<br>
操作方法：换挡、前进、后退等。</p>
<pre><code class="language-php">// 定义一个汽车类的方法为
class Car {
    $name = '汽车'; //定义属性
    function getName() { //定义方法
        return $this-&gt;name; //方法内部可以使用$this伪变量调用对象的属性或者方法
    }
}
// 类是一类东西的结构描述，而对象则是一类东西的一个具体实例，
// 例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。

// 对象通过new关键字进行实例化：
$car = new Car();
$car-&gt;name = '奥迪A6'; //设置对象的属性值
echo $car-&gt;getName();  //调用对象的方法 输出对象的名字

//也可以采用变量来创建
$className = 'Car';
$car = new $className();

//类与对象看起来比较相似，但实际上有本质的区别，
//类是抽象的概念，对象是具体的实例。
//类可以使程序具有可重用性。
</code></pre>
<h2 id="对象之类的属性">对象之类的属性</h2>
<p>在类中定义的变量称之为属性，<br>
通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。<br>
属性声明是由以下关键字开头。<br>
<code>public：公开的</code><br>
<code>protected：受保护的</code><br>
<code>private：私有的</code></p>
<pre><code class="language-php">class Car {
    //定义公共属性
    public $name = '汽车';

    //定义受保护的属性
    protected $color = '白色';

    //定义私有属性
    private $price = '100000';
}
</code></pre>
<p>默认都为public，外部可以访问。<br>
一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。<br>
当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。</p>
<pre><code class="language-php">$car = new Car();
echo $car-&gt;name;   //调用对象的属性
echo $car-&gt;color;  //错误 受保护的属性不允许外部调用
echo $car-&gt;price;  //错误 私有属性不允许外部调用

受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。

class Car{
    private $price = '1000';
    public function getPrice() {
        return $this-&gt;price; //内部访问私有属性
​    }
}
</code></pre>
<h2 id="定义类的方法">定义类的方法</h2>
<p>方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，<br>
在面向过程的程序设计中function叫做<code>函数</code>，在面向对象中function则被称之为<code>方法</code>。</p>
<p>同属性一样，类的方法也具有public，protected 以及 private 的访问控制。</p>
<p>被定义为公有的类成员可以在任何地方被访问。<br>
被定义为受保护的类成员则可以被其自身以及其子类和父类访问。<br>
被定义为私有的类成员则只能被其定义所在的类访问。</p>
<pre><code class="language-php">class Car {
    public function getName() {
        return '汽车';
    }
​}
$car = new Car();
echo $car-&gt;getName();
</code></pre>
<p>使用关键字static修饰的，称之为静态方法。<br>
静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。</p>
<pre><code class="language-php">class Car {
    public static function getName() {
        return '汽车';
    }
​}
echo Car::getName(); //结果为“汽车”

// 静态方法也可以通过变量来进行动态调用

$func = 'getSpeed';
$className = 'Car';
echo $className::$func();  //动态调用静态方法

静态方法中，$this伪变量不允许使用。
可以使用self，parent，static在内部调用静态方法与属性。

class Car {
    private static $speed = 10;
    
    public static function getSpeed() {
        return self::$speed;
    }
    
    public static function speedUp() {
        return self::$speed+=10;
    }
}
class BigCar extends Car {
    public static function start() {
        parent::speedUp();
    }
}

BigCar::start();
echo BigCar::getSpeed();

车辆加速

class Car {
    private static $speed = 10;
    
    public function getSpeed() {
        return self::$speed;
    }
    
    //在这里定义一个静态方法，实现速度累加10

public static function speedUp() {
    return self::$speed+=10;
}

}

$car = new Car();
Car::speedUp();  //调用静态方法加速
echo $car-&gt;getSpeed();  //调用共有方法输出当前的速度值
</code></pre>
<h2 id="构造函数和析构函数">构造函数和析构函数</h2>
<p>__construct()定义一个构造函数，具有构造函数的类，<br>
会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些<code>初始化工作</code>。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;构造函数被调用\n&quot;;
   }
}
$car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串
</code></pre>
<p>在子类中如果定义了__construct则不会调用父类的__construct，<br>
如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;父类构造函数被调用\n&quot;;
   }
}
class Truck extends Car {
   function __construct() {
       print &quot;子类构造函数被调用\n&quot;;
       parent::__construct();
   }
}
$car = new Truck();
</code></pre>
<p>同样，PHP5支持析构函数，使用__destruct()进行定义,<br>
析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;构造函数被调用 \n&quot;;
   }
   function __destruct() {
       print &quot;析构函数被调用 \n&quot;;
   }
}
$car = new Car(); //实例化时会调用构造函数
echo '使用后，准备销毁car对象 \n';
unset($car); //销毁时会调用析构函数
</code></pre>
<p>当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。</p>
<h2 id="访问控制">访问控制</h2>
<p>类属性必须定义为公有、受保护、私有之一。<br>
为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。</p>
<pre><code class="language-php">class Car {
    $speed = 10; //错误 属性必须定义访问控制
    public $name;   //定义共有属性
}
</code></pre>
<p>类中的方法可以被定义为公有、私有或受保护。<br>
如果没有设置这些关键字，则该方法默认为<code>公有</code>。</p>
<pre><code class="language-php">class Car {
​    //默认为共有方法
    function turnLeft() {
    }
}
</code></pre>
<p>如果构造函数定义成了私有方法，则不允许直接实例化对象了，<br>
这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，<br>
比如单例模式只允许有一个全局唯一的对象。</p>
<pre><code class="language-php">class Car {
    private function __construct() {
        echo 'object create';
    }

    private static $_object = null;
    public static function getInstance() {
        if (empty(self::$_object)) {
            self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象
        }
        return self::$_object;
    }
}
//$car = new Car(); //这里不允许直接实例化对象
$car = Car::getInstance(); //通过静态方法来获得一个实例
</code></pre>
<h2 id="对象继承">对象继承</h2>
<p>继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，<br>
除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，<br>
可以采用继承汽车类来共享这些属性与方法，实现代码的复用。</p>
<pre><code class="language-php">class Car {
    public $speed = 0; //汽车的起始速度是0
    
    public function speedUp() {
        $this-&gt;speed += 10;
        return $this-&gt;speed;
    }
}
//定义继承于Car的Truck类
class Truck extends Car {
    public function speedUp(){
        $this-&gt;speed = parent::speedUp() + 50;
    }
}

$car = new Truck();
$car-&gt;speedUp();
echo $car-&gt;speed;

//结果：60
</code></pre>
<h2 id="重载">重载</h2>
<p>PHP中的重载指的是<code>动态</code>的创建属性与方法，是通过魔术方法来实现的。</p>
<p>__set，对不存在属性赋值<br>
__get，对不存在属性读取<br>
__isset，判断属性是否设置<br>
__unset，销毁属性</p>
<p>方法的重载通过__call来实现，当调用不存在的方法的时候，<br>
将会转为参数调用__call方法，当调用不存在的静态方法时会使用__callStatic重载。</p>
<p>class Car {<br>
public $speed = 10;</p>
<pre><code>//在这里使用重载实现speedDown方法
public function __call($name, $args) {
    if ($name == 'speedDown') {
        $this-&gt;speed -= 10;
    }
}
</code></pre>
<p>}<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>a</mi><mi>r</mi><mo>=</mo><mi>n</mi><mi>e</mi><mi>w</mi><mi>C</mi><mi>a</mi><mi>r</mi><mo>(</mo><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">car = new Car();
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span>car-&gt;speedDown(); //调用不存在的speedDown方法<br>
echo $car-&gt;speed;</p>
<p>// $name 参数是要调用的方法名称。<br>
// $arg 参数是一个枚举数组，包含着要传递给方法 $name 的参数。<br>
// 所有的重载方法都必须被声明为 public。<br>
//这些魔术方法的参数都不能通过引用传递。<br>
//属性重载只能在对象中进行。在静态方式中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。</p>
<p>详细：https://www.imooc.com/code/546</p>
<h2 id="高级特性">高级特性</h2>
<pre><code class="language-php">class Car {
    public $name = 'car';
    
    public function __clone() {
        $obj = new Car();
        $obj-&gt;name = $this-&gt;name;
    }
}
$a = new Car();
$a-&gt;name = 'new car';
$b = clone $a;
if ($a == $b) echo '==';   //true
if ($a === $b) echo '==='; //false

$str = serialize($a); //对象序列化成字符串
echo $str.'&lt;br&gt;';
$c = unserialize($str); //反序列化为对象
var_dump($c);
</code></pre>
<p>详细：https://www.imooc.com/code/547</p>
<hr>
<h1 id="三-正则表达式">三、正则表达式</h1>
<p>正则表达式是对字符串进行操作的一种逻辑公式，<br>
就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。</p>
<pre><code class="language-php">$p = '/apple/';
$str = &quot;apple banna&quot;;
if (preg_match($p, $str)) {
    echo 'matched';
}
</code></pre>
<p>其中字符串'/apple/'就是一个正则表达式，用于匹配源字符串中是否存在apple字符串。</p>
<p>PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，<br>
常用来判断一类字符模式是否存在。</p>
<h2 id="基本语法">基本语法</h2>
<p>PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：</p>
<pre><code class="language-php">/foo bar/
#^[^0-9]$#
~php~

//如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。

/http:\/\//

//如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。

$p = 'http://';
$p = '/'.preg_quote($p, '/').'/';
echo $p;

//分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，
//例如使用i修饰符可以忽略大小写匹配：

$str = &quot;Http://www.imooc.com/&quot;;
if (preg_match('/http/i', $str)) {
    echo '匹配成功';
}

// 忽略大小写匹配BBC
$p = '/bbc/i';
$str = &quot;BBC是英国的一个电视台&quot;;
if (preg_match($p, $str)) {
    echo '匹配成功';
}

</code></pre>
<h2 id="元字符与转义">元字符与转义</h2>
<p>正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有：</p>
<p>\ 一般用于转义字符<br>
^ 断言目标的开始位置(或在多行模式下是行首)<br>
$ 断言目标的结束位置(或在多行模式下是行尾)<br>
. 匹配除换行符外的任何字符(默认)<br>
[ 开始字符类定义<br>
] 结束字符类定义<br>
| 开始一个可选分支<br>
( 子组的开始标记<br>
) 子组的结束标记<br>
? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)</p>
<ul>
<li>量词，0 次或多次匹配</li>
</ul>
<ul>
<li>量词，1 次或多次匹配<br>
{ 自定义量词开始标记<br>
} 自定义量词结束标记</li>
</ul>
<p>//下面的\s匹配任意的空白符，包括空格，制表符，换行符。[<sup>\s]代表非空白符。[</sup>\s]+表示一次或多次匹配非空白符。</p>
<pre><code class="language-php">$p = '/^我[^\s]+(苹果|香蕉)$/';
$str = &quot;我喜欢吃苹果&quot;;
if (preg_match($p, $str)) {
    echo '匹配成功';
}
</code></pre>
<p>元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有：</p>
<p>\ 转义字符<br>
^ 仅在作为第一个字符(方括号内)时，表明字符类取反</p>
<ul>
<li>标记字符范围</li>
</ul>
<p>其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。</p>
<pre><code class="language-php">//下面的\w匹配字母或数字或下划线。
$p = '/[\w\.\-]+@[a-z0-9\-]+\.(com|cn)/';
$str = &quot;我的邮箱是Spark.eric@imooc.com&quot;;
preg_match($p, $str, $match);
echo $match[0];

//匹配str中的电话
$p = '/\d+\-\d+/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0];
</code></pre>
<h2 id="贪婪模式与懒惰模式">贪婪模式与懒惰模式</h2>
<p>正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，<br>
但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。</p>
<p>贪婪模式：在可匹配与可不匹配的时候，优先匹配</p>
<pre><code class="language-php">//下面的\d表示匹配数字
$p = '/\d+\-\d+/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0]; //结果为：010-12345678
</code></pre>
<p>懒惰模式：在可匹配与可不匹配的时候，优先不匹配</p>
<pre><code class="language-php">$p = '/\d?\-\d?/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0];  //结果为：0-1
</code></pre>
<p>当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数</p>
<pre><code class="language-php">$p = '/\d{3}\-\d{8}/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0]; //结果为：010-12345678
</code></pre>
<p>匹配str中的姓名</p>
<pre><code class="language-php">$p = '/name:([\w\s]+)/';
$str = &quot;name:steven jobs&quot;;
preg_match($p, $str, $match);
echo $match[1]; //结果为：steven jobs
</code></pre>
<h2 id="正则表达式匹配">正则表达式匹配</h2>
<pre><code class="language-php">//正则匹配，并输出邮箱地址,匹配email的方法还有有很多
$subject = &quot;my email is spark@imooc.com&quot;;
$pattern = '/[\w\-]+@\w+\.\w+/';
preg_match($pattern, $subject, $matches);
echo $matches[0];
</code></pre>
<p>详细：https://www.imooc.com/code/562</p>
<h2 id="查找所有匹配结果">查找所有匹配结果</h2>
<p>preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，<br>
preg_match_all可以循环获取一个列表的匹配结果数组。</p>
<pre><code class="language-php">$str = &quot;&lt;ul&gt;
            &lt;li&gt;item 1&lt;/li&gt;
            &lt;li&gt;item 2&lt;/li&gt;
        &lt;/ul&gt;&quot;;
//在这里补充代码，实现正则匹配所有li中的数据

$p = &quot;/&lt;li&gt;(.*)&lt;\/li&gt;/i&quot;;//解释下这个正则：
//后面的i表示不区分大小写，&lt;li&gt;(.*?)&lt;\/li&gt;表示li标签内的匹配的()内的值有多少，
括号内的.表示所有单字符,*表示数量为0个或者多个。也就是li标签内有字符就显示出来
preg_match_all($p, $str, $matches);
print_r($matches[1]);

结果：
Array
(
    [0] =&gt; item 1
    [1] =&gt; item 2
)
</code></pre>
<p>详细：https://www.imooc.com/code/563</p>
<h2 id="正则表达式的搜索和替换">正则表达式的搜索和替换</h2>
<pre><code class="language-php">$str = '主要有以下几个文件：index.php, style.css, common.js';
//将目标字符串$str中的文件名替换后增加em标签

$p = '/\w+\.\w+/i';
$str = preg_replace($p, '&lt;em&gt;$0&lt;/em&gt;', $str);
echo $str;
结果：
主要有以下几个文件：index.php, style.css, common.js
</code></pre>
<h2 id="常用案例">常用案例</h2>
<pre><code class="language-php">$user = array(
    'name' =&gt; 'spark1985',
    'email' =&gt; 'spark@imooc.com',
    'mobile' =&gt; '13312345678'
);
//进行一般性验证
if (empty($user)) {
    die('用户信息不能为空');
}
if (strlen($user['name']) &lt; 6) {
    die('用户名长度最少为6位');
}
//用户名必须为字母、数字与下划线
if (!preg_match('/^\w+$/i', $user['name'])) {
    die('用户名不合法');
}
//验证邮箱格式是否正确
if (!preg_match('/^[\w\.]+@\w+\.\w+$/i', $user['email'])) {
    die('邮箱不合法');
}
//手机号必须为11位数字，且为1开头
if (!preg_match('/^1\d{10}$/i', $user['mobile'])) {
    die('手机号不合法');
}
echo '用户信息验证成功';
</code></pre>
<hr>
<h1 id="四-cookie">四、cookie</h1>
<p>Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。<br>
一般情况下，Cookie通过HTTP headers从服务端返回到客户端。<br>
多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，<br>
所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。</p>
<p>PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>C</mi></msub><mi>O</mi><mi>O</mi><mi>K</mi><mi>I</mi><mi>E</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">全</mi><mi mathvariant="normal">局</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">此</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi></mrow><annotation encoding="application/x-tex">_COOKIE的全局变量之中，因此我们可以通过</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span></span></span></span>_COOKIE['key']的形式来读取某个Cookie值。</p>
<p>PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。</p>
<pre><code class="language-php">setcookie('test', time());
ob_start();
print_r($_COOKIE); 
$content = ob_get_contents();
$content = str_replace(&quot; &quot;, '&amp;nbsp;', $content);
ob_clean();
header(&quot;content-type:text/html; charset=utf-8&quot;);
echo '当前的Cookie为：&lt;br&gt;';
echo nl2br($content);
</code></pre>
<h2 id="设置cookie">设置cookie</h2>
<p>PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，</p>
<p>我们常用到的为前5个：</p>
<p>name（ Cookie名）可以通过$_COOKIE['name'] 进行访问<br>
value（Cookie的值）<br>
expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效<br>
path（有效路径）如果路径设置为'/'，则整个网站都有效<br>
domain（有效域）默认整个域名都有效，如果设置了'www.imooc.com',则只在www子域中有效</p>
<pre><code class="language-php">$value = 'test';
setcookie(&quot;TestCookie&quot;, $value);
setcookie(&quot;TestCookie&quot;, $value, time()+3600);  //有效期一小时
setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域
</code></pre>
<p>PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，<br>
唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。</p>
<pre><code class="language-php">setrawcookie('cookie_name', rawurlencode($value), time()+60*60*24*365); 
</code></pre>
<p>因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。</p>
<pre><code class="language-php">header(&quot;Set-Cookie:cookie_name=value&quot;);
</code></pre>
<p>设置一个名为test的Cookie</p>
<pre><code class="language-php">$value = time();
setcookie('test', $value); 
if (isset($_COOKIE['test'])) {
    echo 'success';
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP基础学习笔记(上)]]></title>
        <id>https://littlebuzi.github.io/learn_php_1</id>
        <link href="https://littlebuzi.github.io/learn_php_1">
        </link>
        <updated>2020-04-07T10:02:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习一门新的计算机语言，对于基础基础不能丢三落四、模凌两可，这是一定要过关的。这对于以后遇到问题，能事半功倍，快人一步。不然会处处碰壁，事倍功半。假如你不是特别优秀的人，那可以选择像我一样，重复再重复吧，加油💪~</p>
</blockquote>
<hr>
<h1 id="一-符号">一、符号</h1>
<h2 id="单引号括双引号都可以用">单引号括，双引号都可以用:</h2>
<pre><code class="language-php">&lt;?php echo &quot;Hi,imooc！&quot;;?&gt;
&lt;?php echo 'Hi,imooc！';?&gt;
</code></pre>
<h2 id="连接符">连接符（.）：</h2>
<pre><code class="language-php">&lt;?php echo 'Hi,'.'imooc!';?&gt;
</code></pre>
<p>php在这一点比较特殊，其它语言中是用加号（+）来表示的，比如：JavaScirpt、Asp、C。</p>
<h2 id="结尾要加分号">结尾要加分号：</h2>
<p>（;）分号;一定在<a href="https://jingyan.baidu.com/article/c85b7a6401a3d3003bac9504.html">半角状态</a>下输入。</p>
<h2 id="注释语句">注释语句:</h2>
<pre><code class="language-php">PHP：// 注释语句
Html：&lt;!--注释语句--&gt;
CSS：/*注释语句*/
</code></pre>
<p>注释语句可以在PHP程序的任意位置（但注释语句一定要写在<?php ?>之间）。</p>
<hr>
<h1 id="二-变量">二、变量</h1>
<h2 id="定义输出">定义&amp;输出：</h2>
<pre><code class="language-php">$var_name = &quot;苹果&quot;;
$n = 10;
var_dump($var_name);
var_dump($n);
</code></pre>
<h2 id="命名规则">命名规则</h2>
<p>1.变量名必须以<a href="#">字母</a>或<a href="#">下划线 “_”</a>开头，</p>
<p><code>&quot;$_name&quot;</code>√<br>
<code>&quot;$name&quot;</code> √<br>
<code>&quot;$name2&quot;</code>√<br>
<code>&quot;$9name&quot;</code>×</p>
<p>2.由<a href="">字母</a>、<a href="">数字</a>、<a href="">“_”</a>、<a href="">汉字</a>组成。<br>
<code>&quot;$_qq&quot;</code>√<br>
<code>&quot;$qq308&quot;</code>√<br>
<code>&quot;$my_apple&quot;</code>√<br>
<code>&quot;$name我等&quot;</code> √<br>
<code>&quot;$name*&quot;</code>×  (不允许符号)<br>
<code>&quot;$666&quot;</code>×  (不允许纯数字)<br>
<code>&quot;$my apple&quot;</code>×   (不允许空格)</p>
<h2 id="格式">格式</h2>
<p>1.下划线法：<code>$my_apple</code><br>
2.驼峰命名法：<code>$myApple</code><br>
3.在PHP中变量名是区分大小写，<br>
<code>“$my_book”</code><br>
<code>“$my_Book”</code><br>
代表两个不同的变量。</p>
<h2 id="变量的数据类型">变量的数据类型</h2>
<p>php支持八种原始类型：</p>
<h2 id="1四种标量类型">1.四种标量类型：</h2>
<h2 id="boolean-布尔型">boolean 布尔型</h2>
<pre><code class="language-php">①只有两个值，一个是TRUE，另一个FALSE。即为是或否/真或假。
②不区分大小写， &quot;TRUE&quot; = &quot;true &quot;
③主要用在条件结构。
④用”echo”输出时，“true”则输出“1”，“false”不输出。
所以需要注意变量的类型，“1”可能是整型也可能是true，所以需要var_dump输出一下，
如：https://www.imooc.com/code/745
</code></pre>
<h2 id="integer-整型">integer 整型</h2>
<pre><code class="language-php">$data_int = 123;   // 十进制数  ，123
$data_int = -123;    // 一个负数  ，-123
$data_int = 0123;    // 八进制数（等于十进制的 83）  ，83
$data_int = 0x123;    // 十六进制数（等于十进制的 26）  ，291
// 十进制、八进制（数字前“0”）、十六进制（数字前“0x”）。(0是阿拉伯数字0，不是英文字母&quot;欧/o&quot;)
</code></pre>
<h2 id="float-浮点型也称double">float 浮点型（也称double）</h2>
<pre><code class="language-php">$num_float = 1.234;    //小数点  ，1.234
$num_float = 1.2e3;    //科学计数法，小写e  ，1200
$num_float = 7.0E-10;     //科学计数法，大写E ，0.007
// 支持小数点、科学计数法小写的e，大写的E表示。
</code></pre>
<h2 id="string-字符串">string (字符串)</h2>
<pre><code class="language-php">“$str_string1 = '我是字符串';”
// 字符和字节一样，所以一共有256种不同字符的可能性。
// 三种方法定义：单引号形式、双引号形式和Heredoc结构形式。

// 单双引号嵌入与转义符“\”
$str_string1 = '甲问：&quot;你在哪里学的PHP？&quot;';
$str_string2 = &quot;乙毫不犹豫地回答：'当然是慕课网咯！'&quot;;
$str_string3 = '甲问:\'能告诉我网址吗？\'';
$str_string4 = &quot;乙答道:\&quot;www.imooc.com\&quot;&quot;;

// 美元符号标识的变量与单双引号
$love = &quot;I love you!&quot;; 
$string1 = &quot;慕课网,$love&quot;;    输出：慕课网,I love you!
$string2 = '慕课网,$love';     输出：慕课网,$love

// Heredoc结构形式，很长的字符串
$string1 = &lt;&lt;&lt;GOD
我有一只小毛驴，我从来也不骑。
有一天我心血来潮，骑着去赶集。
我手里拿着小皮鞭，我心里正得意。
不知怎么哗啦啦啦啦，我摔了一身泥.
GOD;

</code></pre>
<h2 id="2两种符合类型">2.两种符合类型：</h2>
<h2 id="array-数组">array 数组</h2>
<h2 id="object-对象">object 对象</h2>
<h2 id="3特殊类型">3.特殊类型：</h2>
<h2 id="resource-资源">resource 资源</h2>
<p>资源是由专门的函数来建立和使用的，</p>
<pre><code class="language-php">// 例如打开文件、数据连接、图形画布。
$file=fopen(&quot;f.txt&quot;,&quot;r&quot;);   //打开文件
$con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);  //连接数据库
$img=imagecreate(100,100);//图形画布

// 对资源进行创建、使用和释放
$file_handle = fopen(&quot;/data/webroot/resource/php/f.txt&quot;,&quot;r&quot;);
if ($file_handle){
    //接着采用while循环（后面语言结构语句中的循环结构会详细介绍）一行行地读取文件，然后输出每行的文字
    while (!feof($file_handle)) { //判断是否到最后一行
        $line = fgets($file_handle); //读取一行文本
        echo $line; //输出一行文本
        echo &quot;&lt;br /&gt;&quot;; //换行
    }
}
fclose($file_handle);//关闭文件

// 任何资源，在不需要的时候应该被及时释放。
// 忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。

</code></pre>
<h2 id="null">null</h2>
<p>NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，<br>
①当被赋值为NULL：var1 = null;/var1 = NULL;<br>
②或者尚未被赋值：var_dump(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mn>2</mn><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">③</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">被</mi><mi>u</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">var2);
③或者被unset()：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">③</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">被</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">：</span></span></span></span>var3 = &quot;节日快乐！&quot;;unset($var3);<br>
这三种情况下变量被认为为NULL。</p>
<h2 id="变量占用内存">变量占用内存</h2>
<pre><code class="language-php">echo $m1 = memory_get_usage(); 
// 获取当前PHP消耗的内存，结果：624432，
// 在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），分成几种数据类型。
</code></pre>
<p>详见：<a href="https://www.imooc.com/code/743">https://www.imooc.com/code/743</a></p>
<hr>
<h1 id="三-常量">三、常量</h1>
<p>常量可以理解为值不变的量（如圆周率）；<br>
或者是常量值被定义后，在脚本的其他任何地方都不可以被改变。分为自定义常量和系统常量</p>
<h2 id="自定义常量">自定义常量</h2>
<p>根据我们开发的需要，而定义的常量，它通过使用PHP中的函数define()定义。<br>
（注：函数，我们可以理解为一个混凝土搅拌机，亦或是一个筛子，通过入口提供原料，然后出口产出结果，在函数中也允许入口不提供任何数据，出口也允许不返回任何值。）</p>
<pre><code class="language-php">// define()函数的语法格式为(3个参数)：
bool define(string $constant_name, mixed $value[, $case_sensitive = true])
//“constant_name”为必选参数，常量名称,即标志符，常量的命名规则与变量的一致，但是要注意哦，它可不带美元符号哦。
//“value”为必选参数，它是常量的值。
//“case_sensitive”为可选参数，指定是否大小写敏感，设定为true表示不敏感，一般不指定第三个参数的情况下，默认第三个参数的值为false。

注：
 string表示参数类型为字符串类型，
mixed表示参数类型可以接受为多种不同的类型，
case_sensitive = true表示默认为布尔类型TRUE

如：
$p = &quot;PII&quot;;
define(&quot;PI&quot;,3.14);
define($p,3.14);
echo PI;
echo &quot;&lt;br /&gt;&quot;;
echo PII;

结果：
3.14
3.14

</code></pre>
<h2 id="常量的作用">常量的作用</h2>
<p>常量主要功效是可以避免重复定义，篡改变量值。在我们进行团队开发时，或者代码量很大的时候，对于一些第一次定义后不改变的量，如果我们使用变量，在不知情的情况下，使用同一变量名时，变量值就会被替换掉，从而会引发服务器执行错误的任务。</p>
<p>此外，使用常量还能提高代码的可维护性。如果由于某些原因，常量的值需要变更时候，我们只需要修改一个地方。例如在做计算中，起初我们取圆周率为3.14，于是很多计算中我们都使用3.14进行计算，当要求计算精度提高，圆周率需要取3.142的时候，我们不得不修改所有使用3.14的代码，倘若代码量比较多时，不仅工作量大，还可能遗漏。</p>
<h2 id="系统常量">系统常量</h2>
<p>系统常量是PHP已经定义好的常量，我们可以直接拿来使用，常见的系统常量有：</p>
<pre><code class="language-php">echo __FILE__;
// php程序文件名。它可以帮助我们获取&quot;当前文件在服务器的物理位置&quot;。

echo __LINE__;
// PHP程序文件行数。它可以告诉我们，&quot;当前代码在第几行&quot;。

echo PHP_VERSION;
// 当前解析器的版本号。可以提前知道&quot;PHP代码是否可被该PHP解析器解析&quot;。

echo PHP_OS;
// 执行当前PHP版本的操作系统名称。&quot;服务器所用的操作系统名称&quot;，可以根据该操作系统优化我们的代码。
</code></pre>
<h2 id="常量取值">常量取值</h2>
<p>获取常量值的有两种方法取值。<br>
第一种是使用常量名直接获取值；例如计算圆周率的面积：</p>
<pre><code class="language-php">define(&quot;PI&quot;,3.14);
$r=1;
$area = PI*$r*$r; //计算圆的面积
</code></pre>
<p>第二种是使用constant()函数。它和直接使用常量名输出的效果是一样的，<br>
但函数可以动态的输出不同的常量，在使用上要灵活、方便，其语法格式如下：</p>
<pre><code class="language-php">$p=&quot;&quot;;
//定义圆周率的两种取值
define(&quot;PI1&quot;,3.14);
define(&quot;PI2&quot;,3.142);
//定义值的精度
$height = &quot;中&quot;;
//根据精度返回常量名，将常量变成了一个可变的常量
if($height == &quot;中&quot;){
    $p = &quot;PI1&quot;;
}else if($height == &quot;低&quot;){
	$p = &quot;PI2&quot;;
}
$r=1;
echo $p; // 若不使用constant，输出的就是Pi1
$area= constant($p)*$r*$r;
echo $area;
</code></pre>
<p>mixed constant(string constant_name)<br>
第一个参数constant_name为要获取常量的名称，也可为存储常量名的变量。<br>
如果成功则返回常量的值，失败则提示错误信息常量没有被定义。<br>
（注：mixed表示函数返回值类型为多种不同的类型，string表示参数类型为字符串类型）</p>
<h2 id="判定常量是否被定义">判定常量是否被定义</h2>
<p>如果常量被重复定义以后，PHP解析器会发出“Constant XXX already defined”的警告，<br>
提醒我们该常量已经被定义过。在团队开发，或代码量很大的情况下，如何去判定一个常量是否被定义呢？</p>
<p>defined()函数可以帮助我们判断一个常量是否已经定义，其语法格式为：</p>
<pre><code class="language-php">define(&quot;PI1&quot;,3.14);
$p = &quot;PI1&quot;;
$is1 = defined($p);
$is2 = defined(&quot;PI2&quot;);
var_dump($is1);
var_dump($is2);
结果：
bool(true)
bool(false)

//其中，赋值给$p目的就是间接来表明PI1已经被定义，所以$is1 = defined(PI1);亦可行。

// define方法是定义一个常量的方法，返回的是该已定义的常量；
// defined方法是判断一个常量是否定义，返回的是一个bool值（true/false）。
</code></pre>
<p>bool defined(string constants_name)<br>
它只有参数constant_name，指的是要获取常量的名称，若存在则返回布尔类型true，否则返回布尔类型false; （注：bool表示函数返回值类型为布尔类型）</p>
<hr>
<h1 id="四-运算符">四、运算符</h1>
<p>分为算术运算符、赋值运算符、比较运算符、三元运算符、逻辑运算符、字符串连接运算符、错误控制运算符。</p>
<h2 id="算术运算符">算术运算符：</h2>
<p>加法运算、减法运算、乘法运算、除法运算</p>
<h2 id="赋值运算符">赋值运算符：</h2>
<p>(1)“=”：把右边表达式的值赋给左边的运算数。它将右边表达式值复制一份，交给左边的运算数。<br>
换而言之，首先给左边的运算数申请了一块内存，然后把复制的值放到这个内存中。</p>
<p>(2)“&amp;”：引用赋值，意味着两个变量都指向同一个数据。<br>
它将使两个变量共享一块内存，如果这个内存存储的数据变了，那么两个变量的值都会发生变化。</p>
<pre><code class="language-php">$a = &quot;学习PHP！&quot;;
$b = $a;
$c = &amp;$a;
$a = &quot;我天天在学习PHP！&quot;;
echo $b.&quot;&lt;br /&gt;&quot;;
echo $c.&quot;&lt;br /&gt;&quot;;

结果：
学习PHP！
我天天在学习PHP！
</code></pre>
<h2 id="比较运算符">比较运算符</h2>
<figure data-type="image" tabindex="1"><img src="https://littlebuzi.github.io//post-images/1586501035649.jpg" alt="" loading="lazy"></figure>
<h2 id="三元运算符">三元运算符</h2>
<p>(“?:”)三元运算符也是一个比较运算符，<br>
对于表达式(expr1)?(expr2):(expr3)，如果expr1的值为true，则此表达式的值为expr2，否则为expr3。</p>
<pre><code class="language-php">$a = 78;//成绩
	$b = $a &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;; 
	echo $b;

结果：及格
</code></pre>
<h2 id="逻辑运算符">逻辑运算符</h2>
<figure data-type="image" tabindex="2"><img src="https://littlebuzi.github.io//post-images/1586502150083.jpg" alt="" loading="lazy"></figure>
<p>1、逻辑与：要求所有人都投票同意，才会通过某协议；<br>
2、逻辑或：只要求一个人投票同意就行；<br>
3、逻辑异或：只能有且只能有一个人投票同意；<br>
4、逻辑非：某个人要反对，但是通过逻辑非，使其反对无效；</p>
<p>“与”和“或”有两种不同形式运算符的原因是它们运算的优先级（就是运算的有限顺序，比如我们小学的时候学习四则运算，加减乘除混合在一起啦，优先计算乘除，再计算加减）不同。</p>
<figure data-type="image" tabindex="3"><img src="https://littlebuzi.github.io//post-images/1586502214728.jpg" alt="" loading="lazy"></figure>
<h2 id="字符串连接运算符">字符串连接运算符</h2>
<p>（1）连接运算符(“.”)：它返回将右参数附加到左参数后面所得的字符串。</p>
<pre><code class="language-php">$a = &quot;张先生&quot;;
$tip = $a.&quot;,欢迎您在慕课网学习PHP！&quot;;
echo  $tip.&quot;&lt;br /&gt;&quot;;

结果：
张先生,欢迎您在慕课网学习PHP！

</code></pre>
<p>（2）连接赋值运算符(“.=”)：它将右边参数附加到左边的参数后。</p>
<pre><code class="language-php">$b = &quot;东边日出西边雨&quot;;	
$b .= &quot;,道是无晴却有晴&quot;;
$c = &quot;东边日出西边雨&quot;;	
$c = $c.&quot;,道是无晴却有晴&quot;;
echo  $b.&quot;&lt;br /&gt;&quot;;
echo  $c.&quot;&lt;br /&gt;&quot;;

结果：
东边日出西边雨,道是无晴却有晴
东边日出西边雨,道是无晴却有晴

</code></pre>
<h2 id="错误控制运算符">错误控制运算符</h2>
<p>PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉；</p>
<p>如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查。</p>
<p>需要注意的是：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。</p>
<pre><code class="language-php">$conn = @mysql_connect(&quot;localhost&quot;,&quot;username&quot;,&quot;password&quot;);
// 这样就不会报错并打印出来
</code></pre>
<h2 id="取整函数">取整函数</h2>
<p>ceil() 函数向上舍入为最接近的整数。</p>
<pre><code class="language-php">echo(ceil(0.60);
echo(ceil(0.40);
echo(ceil(5);
echo(ceil(5.1);
echo(ceil(-5.1);
echo(ceil(-5.9));

输出：
1
1
5
6
-5
-5

</code></pre>
<hr>
<h1 id="五-顺序结构">五、顺序结构</h1>
<p>顺序结构就像一条直线，按着顺序一直往下执行。我们编写的代码默认都是按照顺序结构执行的。</p>
<h2 id="条件结构">条件结构:</h2>
<h2 id="ifelse">if…else…</h2>
<pre><code class="language-php">if(条件){
     //分配服务器干的任务A
}else{
     //分配服务器干的任务B
}
</code></pre>
<h2 id="ifelse-if">if…else if…</h2>
<pre><code class="language-php">if(条件一){
     //分配服务器干的任务A
}else if(条件二){
     //分配服务器干的任务B
}
</code></pre>
<h2 id="ifelse-ifelse">if…else if…else…</h2>
<pre><code class="language-php">if(条件一){
     //分配服务器干的任务A
}else if(条件二){
     //分配服务器干的任务B
}else{
     //分配服务器干的任务C
}
</code></pre>
<p>当两个条件对立时用if…else，当两个条件不存在对立关系时用if…else if…</p>
<h2 id="switchcase">switch…case…</h2>
<pre><code class="language-php">switch (条件)
{
case 条件值一:
  //任务一
  break; 
case 条件值二:
  //任务二
  break;
default:
  //默认任务
}
</code></pre>
<p>switch…case…中的break：<br>
break的作用是结束switch，亦可以避免冗长的 “if..else if..else”代码块。</p>
<pre><code class="language-php">
//A例子
$num = 2;
$sum  = 10; 
switch($num){
    case 1:
		$sum = $sum  + 10;
		break;
	case 2:
		$sum = $sum  + 10;
		break;
 	case 3:
		$sum = $sum  + 10;
		break;
	default:
		$sum = $sum  + 10;
}
 echo &quot;A例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;;

 结果：A例子的值是：20
 // 直接查询到num为2，sum加10后即刻break，跳出查找。

//B例子
$num = 2;
$sum  = 10; 
switch($num){
	case 1:
		$sum = $sum  + 10;
	case 2:
		$sum = $sum  + 10;
	case 3:
		$sum = $sum  + 10;
	default:
		$sum = $sum  + 10;
}
 echo &quot;B例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;;

 结果：B例子的值是：40
//查询到num为2后，sum加10，因为没break，继续执行case3，加了10，再执行了defailt。 

</code></pre>
<h2 id="while循环语句">while循环语句</h2>
<pre><code class="language-php">while(条件){ 
     //执行任务
}
</code></pre>
<p>首先判断某个条件是否符合（条件返回值是否为TRUE），<br>
若符合则执行任务，执行完毕任务，再判断条件是否满足要求，符合则重复执行此任务，否则结束任务。</p>
<h2 id="do-while循环语句">do while循环语句</h2>
<pre><code class="language-php">do{ 
     //执行任务
}while(条件)
</code></pre>
<p>首先执行任务（while语句是先判断条件是否成立，再执行任务），执行任务完毕，判断某个条件是否符合（条件返回值是否为TRUE），若符合则再次执行任务，执行完毕任务，继续判定条件。</p>
<p>while与do…while循环语句的区别：<br>
while先判断条件是否成立，后执行循环，do...while先执行一次任务，再判断是否继续执行循环，也就是说do...while至少会执行一次任务。当条件为FALSE时，while中的任务会一次也不执行，do...while中的任务会执行1次。</p>
<h2 id="for循环语句">for循环语句</h2>
<pre><code class="language-php">for(初始化;循环条件;递增项){
      //执行任务
}

for($i = 1,$i&lt;=100;$i++){
    echo &quot;666&quot;;
}
</code></pre>
<p>for 语句中，“初始化”在循环开始前无条件求值一次，“循环条件”在每次循环开始前求值。如果值为 TRUE，则继续循环，执行循环体语句（执行任务）。如果值为 FALSE，则终止循环。“递增项”在每次循环之后被求值（执行）。其常用于循环执行代码块指定的次数。</p>
<h2 id="foreach循环语句">foreach循环语句</h2>
<p>常用于遍历数组，一般有两种使用方式:不取下标、取下标。</p>
<pre><code class="language-php">
//eg
$students = array(
'2010'=&gt;'令狐冲',
... ...
... ...
'2019'=&gt;'宁中则',
);//10个学生的学号和姓名，用数组存储

（1）只取值，不取下标

 foreach (数组 as 值){
//执行的任务
}

//使用循环结构遍历数组,获取学号和姓名  
foreach($students as  $v)
{ 
    echo $v;//输出（打印）姓名
	echo &quot;&lt;br /&gt;&quot;;
}

（2）同时取下标和值

foreach (数组 as 下标 =&gt; 值){
 //执行的任务
}

//使用循环结构遍历数组,获取学号和姓名  
foreach($students as $key =&gt;$v)
{ 
    echo $key.&quot;:&quot;.$v;//输出（打印）学号：姓名
	echo &quot;&lt;br /&gt;&quot;;
}
?&gt;

</code></pre>
<h2 id="结构嵌套">结构嵌套</h2>
<h2 id="条件嵌套">条件嵌套</h2>
<p>if里加if，<br>
if($sex == &quot;男&quot;)</p>
<p>if($noHouse)</p>
<p>else if($sex == &quot;女&quot;)<br>
4、第20行输入：</p>
<p>if($isPregnancy)</p>
<h2 id="循环嵌套">循环嵌套</h2>
<p>常用于遍历二维数组。</p>
<pre><code class="language-php">
 $students = array(
'2010'=&gt;array('令狐冲',&quot;59&quot;),
... ...
... ...
'2019'=&gt;array('宁中则',&quot;90&quot;),
);//10个学生的学号、姓名、分数，用数组存储
 
foreach($students as $key=&gt;$val)
{ //使用循环结构遍历数组,获取学号 
     echo $key; //输出学号
	 echo &quot;:&quot;;
	 //循环输出姓名和分数
    foreach($val as $v)
	{
		echo $v; 
	 }
	 echo &quot;&lt;br /&gt;&quot;;
}

</code></pre>
<p>#循环结构与条件结构嵌套</p>
<pre><code class="language-php"> $students = array(
'2010'=&gt;'令狐冲',
... ...
... ...
'2019'=&gt;'宁中则',
);//10个学生的学号和姓名，用数组存储
$query = '2014';
//使用循环结构遍历数组,获取学号和姓名
foreach($students as $key =&gt;$v)
{ 
    //使用条件结构，判断是否为该学号
	if($key == $query)
	{ 
		echo $v;//输出（打印）姓名
		break;//结束循环（跳出循环）
	}
}

</code></pre>
<p>在执行任务时，对于一些特殊的任务进行额外处理。</p>
<p>来源：慕课网，内容持续更新中...</p>
<hr>
<blockquote>
<p>为什么有了这么完备的“慕课网学习系统”，还要做个复制粘贴呢？<br>
1.这是一个笔记，是慕课课程的提炼，为学精一门语言而开辟的一个学习笔记文章。<br>
2.再好的学习平台，也可能会有结束的一天，所以我现在做的事情，可能可以为优秀的平台在茫茫的互联网长河中留下一点点痕迹。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目前流行的9大前端框架]]></title>
        <id>https://littlebuzi.github.io/前端_1</id>
        <link href="https://littlebuzi.github.io/前端_1">
        </link>
        <updated>2020-03-15T09:52:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue">Vue</h1>
<p>https://cn.vuejs.org</p>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h2 id="php">php</h2>
<p>https://www.cnblogs.com/cc1997/p/10522678.html<br>
[Vuejs+php] MySQL数据转JSON传值到前端</p>
<h1 id="react">React</h1>
<p>https://react.docschina.org/</p>
<p>React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>
<h1 id="angular">Angular</h1>
<p>https://angular.io</p>
<p>AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p>
<h1 id="qucikui">QucikUI</h1>
<p>http://www.uileader.com/product_quickui</p>
<p>QucikUI 4.0是一套完整的企业级web前端开发解决方案，由基础框架、UI组件库、皮肤包、示例工程和文档等组成。底层基于jquery构建。使用QucikUI 开发者可以极大地减少工作量，提高开发效率，快速构建功能强大、美观、兼容的web应用系统。</p>
<h1 id="layui">Layui</h1>
<p>https://www.layui.com/</p>
<p>layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>
<h2 id="入门">入门：</h2>
<p>开始使用：https://www.layui.com/doc/<br>
组件：https://www.layui.com/demo/<br>
详细说明：https://www.layui.com/doc/element/layout.html</p>
<h2 id="cdn">CDN</h2>
<p>https://www.layuicdn.com/<br>
为 Layui 的广大用户提供免费的CDN静态库，非常稳定、快速、免费的 Layui开源组件项目 国内CDN加速服务：</p>
<h2 id="php-2">PHP</h2>
<p>https://fly.layui.com/jie/32688/<br>
PHP后台怎么写才能使返回的数据渲染layui表格呢</p>
<h1 id="avalon">Avalon</h1>
<p>http://avalonjs.coding.me/</p>
<p>avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。</p>
<h1 id="dojo">Dojo</h1>
<p>https://dojo.io/</p>
<p>Dojo致力于实现最大的互操作性。Web组件提供了一种机制，可以在Dojo应用程序中利用非Dojo组件，并在非Dojo应用程序中轻松使用基于Dojo的小部件。Dojo为Web组件提供一流的支持。您今天做出的决定不应该将您锁定在未来的决策中。</p>
<h1 id="ember">Ember</h1>
<p>https://emberjs.com/</p>
<p>Ember.js可能是最固执己见的主流框架，这也是其最大的优势。它有创建Ember.js应用程序的正确方法，通常只有一种方法来创建应用程序。Ember.js更类似于一个产品或平台，在那里你会到一个供应商的长期支持和维护。Ember.js提供了对其平台的全面版本管理，升级工具以及对API升级的强大指导和工具。成熟，是对Ember.js的一个很好的总结。</p>
<h1 id="aurelia">Aurelia</h1>
<p>https://aurelia.io/</p>
<p>Aurelia是一个令人惊叹的框架，它在不牺牲功能的情况下采用简单而干净的代码。在本教程中，我们将通过构建“Todo”应用程序向您介绍Aurelia的简单性。您将看到应用程序代码的简洁程度，您将学习Aurelia的几个基本概念和功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch预训练的Resnet模型 Danbooru2018]]></title>
        <id>https://littlebuzi.github.io/face_4</id>
        <link href="https://littlebuzi.github.io/face_4">
        </link>
        <updated>2020-03-12T15:39:33.000Z</updated>
        <content type="html"><![CDATA[<p>原作者：https://github.com/RF5/danbooru-pretrained</p>
<h1 id="准备环境">准备环境</h1>
<p>Pytorch (&gt;1.0)</p>
<h1 id="提取图片的以下特征">提取图片的以下特征：</h1>
<figure data-type="image" tabindex="1"><img src="" alt="https://gitee.com/littlebuzi/danbooru-pretrained/raw/master/img/danbooru_resnet2.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二次元识图工具网站]]></title>
        <id>https://littlebuzi.github.io/amine_reg_1</id>
        <link href="https://littlebuzi.github.io/amine_reg_1">
        </link>
        <updated>2020-03-09T10:57:23.000Z</updated>
        <content type="html"><![CDATA[<p>1、 https://trace.moe/ 找番剧网站，有大量日番资源<br>
优点：找到图片番剧后可实时预览<br>
缺点：只能识别番剧，魔改、加水印、模糊等图片不可用<br>
2、 https://saucenao.com/ 找画网站，接入p站等数据<br>
优点：识别很多画师原创图及同人图<br>
缺点：查找结果为英文、日文、罗马音等。需要借助翻译工具<br>
3、 https://www.baidu.com/ 搜索引擎类，百度谷歌等<br>
优点：可找的范围很广，包括但不限于：动漫、各类MV、影视剧等等，全中文<br>
缺点：结果并不是很精确需要进一步搜索，可能出现奇怪的结果<br>
4、人肉识别@凉风Kaze[doge]<br>
优点：快 准 狠<br>
缺点：消耗一个三连（误）<br>
6.各种搜索引擎，某度，某狗，某歌等等……<br>
优点：谷歌搜索更广更专业<br>
缺点：国内没有，可尝试这个第三方国内版https://gfsoso.fcczp.com/image.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动漫人物数据集]]></title>
        <id>https://littlebuzi.github.io/dongman_1</id>
        <link href="https://littlebuzi.github.io/dongman_1">
        </link>
        <updated>2020-03-09T10:57:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="danbooru"><a href="https://safebooru.donmai.us/">Danbooru</a> :</h1>
<blockquote>
<p>Danbooru2019：<br>
<a href="https://www.gwern.net/Danbooru2019">https://www.gwern.net/Danbooru2019</a></p>
</blockquote>
<p>A LARGE-SCALE CROWDSOURCED AND TAGGED ANIME ILLUSTRATION DATASET<br>
一个大规模的众包和标记动画插图数据集</p>
<p>Danbooru2017：<br>
https://www.gwern.net/Danbooru2019#danbooru2017</p>
<p>Danbooru2018：<br>
https://www.gwern.net/Danbooru2019#danbooru2018</p>
<h1 id="getchu"><a href="https://www.getchu.com/">Getchu</a> : (原址需科学上网访问)</h1>
<blockquote>
<p>百度云：<br>
<a href="https://pan.baidu.com/s/1bTWoEcJRzXJaMM8jELPCBA">https://pan.baidu.com/s/1bTWoEcJRzXJaMM8jELPCBA</a></p>
</blockquote>
<p>CSDN：<br>
https://blog.csdn.net/ONE_SIX_MIX/article/details/95935010</p>
<p>github 仓库：<br>
https://github.com/One-sixth/getchu_character_picture_grabber</p>
<h1 id="niconico-仅限于学术目的的图">Niconico : (仅限于学术目的的图)</h1>
<p>需要科研机构申请才可以下载。【放弃~】<br>
nico-opendata：<a href="https://nico-opendata.jp/en/index.html">https://nico-opendata.jp/en/index.html</a><br>
At Niconico, we are providing a wide variety of data from our services,<br>
to be used for academic purposes. 仅限用于学术目的。<br>
包含：<br>
Nico-Illust    超过40万张图像（插图）<br>
This dataset contains over 400,000 images (illustraions) from Niconico Seiga and Niconico Shunga.<br>
<a href="http://seiga.nicovideo.jp/">Niconico Seiga</a> is a community for posting illustrations.  一个发布插图的社区。<br>
<a href="http://seiga.nicovideo.jp/shunga/">Niconico Shunga</a> is a community for posting illustrations, where submission of explicit content is allowed. Viewers under age 18 are prohibited in this website.  本网站禁止18岁以下观众观看。</p>
<h1 id="其他">其他：</h1>
<p>IIIT-CFW<br>
https://zhuanlan.zhihu.com/p/25138563<br>
集合了各种类型的数据集（好多没见过的，感觉很全？可能有用，得再看看。），<br>
比较麻烦的就是得登陆某个网站、再用度盘下载。<br>
各领域公开数据集下载<br>
“整理了一些网上的免费数据集，分类下载地址如下，希望能节约大家找数据的时间。”</p>
<p>真实人脸：<br>
VGGFace2 : A large scale image dataset for face recognition<br>
http://www.robots.ox.ac.uk/~vgg/data/vgg_face2/index.html#about<br>
9000+身份，330w+图像</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP、JS、CSS基操]]></title>
        <id>https://littlebuzi.github.io/php_jicao_1</id>
        <link href="https://littlebuzi.github.io/php_jicao_1">
        </link>
        <updated>2020-02-18T06:23:45.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h1 id="php">PHP</h1>
<p>免费快速学习php<br>
PHP入门篇：https://www.imooc.com/learn/54<br>
PHP进阶篇：https://www.imooc.com/learn/26<br>
更多：https://www.imooc.com/search/?words=php</p>
<p>PHP环境LAMP/LNMP安装与配置<br>
https://www.imooc.com/learn/703</p>
<p>PHP+Mysql+Ajax实现分页<br>
https://www.imooc.com/learn/1117</p>
<p>PHP生成随机数的几种方法<br>
https://www.cnblogs.com/jjxhp/p/9601147.html</p>
<p>PHP 升级到5.5后MySQL的代替法<br>
https://blog.csdn.net/apple_llb/article/details/51406648</p>
<p>php调用exe一直加载怎么回事？<br>
https://ask.csdn.net/questions/231711</p>
<p>还有可能是在exec()后面给予了任务，导致一直加载。<br>
cmd命令语句还在后台运行中，没有黑框弹出来，需等待更长时间。</p>
<p>使用PHP实现用户注册登录的功能<br>
https://github.com/Micanss/PHP-Register-Login</p>
<p>... ...</p>
<hr>
<h1 id="javascript">JavaScript</h1>
<p>报错TypeError: $(...).live is not a function</p>
<p>解决：用  .on  代替  .live  , 旧的版本被替换了</p>
<p>https://blog.csdn.net/qq_36370731/article/details/79016451</p>
<p>报错TypeError: $(…).ajaxForm is not a function</p>
<p>可能：<br>
1.jquery版本和bootstrap冲突<br>
2.同时加载了两次jquery</p>
<p>https://stackoverflow.com/questions/35261239/ajaxform-is-not-a-function#</p>
<p>【JavaScript】按钮绑定点击事件-onCliek事件<br>
https://blog.csdn.net/kye055947/article/details/79619538</p>
<p>iframe 自适应高度，更改内容时iframe高度怎么根据新的内容高度自动改变<br>
https://blog.csdn.net/txqd1989/article/details/78551943</p>
<p>... ...</p>
<hr>
<h1 id="css-前端">CSS 前端</h1>
<p>css input[type=file] 样式美化，input上传按钮美化<br>
https://blog.csdn.net/cuilei210/article/details/78842231</p>
<p>菜鸟教程：CSS 按钮示范<br>
https://www.runoob.com/css3/css3-buttons.html</p>
<hr>
<h1 id="cmd">cmd</h1>
<p>##运行CMD里面，怎么把得到的结果数据保存为文本文件<br>
https://zhidao.baidu.com/question/596846191.html</p>
<h2 id="用批处理命令获取文件夹名称">用批处理命令获取文件夹名称</h2>
<p>创建test.bat，双击运行内容如下：</p>
<pre><code class="language-bat">@Echo off
dir /b&gt;test.txt
</code></pre>
<p>https://zhidao.baidu.com/question/936329819153763892.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tensorflow利用inception_v3模型和retrain实现图像分类训练]]></title>
        <id>https://littlebuzi.github.io/tensorflow2</id>
        <link href="https://littlebuzi.github.io/tensorflow2">
        </link>
        <updated>2020-02-15T09:22:17.000Z</updated>
        <content type="html"><![CDATA[<p>参考文献：<br>
https://blog.csdn.net/ZeyiRTangent/article/details/87886445</p>
<p>#准备：</p>
<p>1.五个分类好存有各自类别的文件夹【文件夹及其内图片的名称全小写，绝对路径名中不能包含中文】</p>
<p>2.inception_v3模型下载，无需解压【http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz】</p>
<p>3.克隆/下载 https://github.com/tensorflow/tensorflow &amp; https://github.com/tensorflow/hub （在~hub-master\examples\image_retraining中找到retrain.py文件，待会需要定位文件位置）</p>
<p>。。。</p>
<hr>
<h1 id="可能遇到的问题">可能遇到的问题：</h1>
<ol>
<li></li>
</ol>
<p>查看Windows下TensorFlow对python版本的要求<br>
https://blog.csdn.net/sinat_23619409/article/details/84202596</p>
<ol start="2">
<li></li>
</ol>
<p>windows10 conda python多版本切换<br>
https://www.cnblogs.com/simuhunluo/p/8540459.html</p>
<ol start="3">
<li></li>
</ol>
<p>windows 怎么更新 Python 版本（现有 Python 版本装了很多库）卸载重装，工作量就大了，有没有什么直接更新的方式，不会删库那种办法<br>
https://www.v2ex.com/amp/t/477473</p>
<ol start="4">
<li></li>
</ol>
<p>conda（anaconda）删除清华源，改回原源<br>
https://blog.csdn.net/qinglingLS/article/details/89363368</p>
<ol start="5">
<li></li>
</ol>
<p>PackagesNotFoundError: The following packages are not available from current channels:<br>
https://blog.csdn.net/miao0967020148/article/details/85230430</p>
<ol start="6">
<li></li>
</ol>
<p>迁移学习关于下载不了inception-v3，自己网络又加载不了的问题<br>
https://blog.csdn.net/nationalline450/article/details/82085007</p>
<p>原址：<br>
https://tfhub.dev/google/imagenet/inception_v3/feature_vector/3</p>
<ol start="7">
<li></li>
</ol>
<p>出现以下报错：</p>
<pre><code class="language-python">Warning! ***HDF5 library version mismatched error***
The HDF5 header files used to compile this application do not match
the version used by the HDF5 library to which this application is linked.
Data corruption or segmentation faults may occur if the application continues.
This can happen when an application was compiled by one version of HDF5 but
linked with a different version of static or shared HDF5 library.
You should recompile the application or check your shared library related
settings such as 'LD_LIBRARY_PATH'.
You can, at your own risk, disable this warning by setting the environment
variable 'HDF5_DISABLE_VERSION_CHECK' to a value of '1'.
Setting it to 2 or higher will suppress the warning messages totally.
Headers are 1.10.4, library is 1.10.5
        SUMMARY OF THE HDF5 CONFIGURATION
        =================================

General Information:
-------------------
                   HDF5 Version: 1.10.5
                  Configured on: 2019-03-04
  
... ... ... 
... ... ... 
 
          Function Stack Tracing: OFF
       Strict File Format Checks: OFF
    Optimization Instrumentation:
Bye...

</code></pre>
<p>（多版本导致冲突）pip uninstall h5py<br>
Ubuntu: HDF5报错: HDF5 header version与HDF5 library不匹配<br>
https://www.cnblogs.com/platero/p/4077934.html</p>
<p>Python环境中HDF5报错：HDF5 library version mismatched error<br>
https://blog.csdn.net/zhaoyin214/article/details/104095227</p>
<p>使用conda装完plt/pillow后，错误又出来了，详细看，conda在安装pillow时帮你安装hdf5版本了：<br>
再卸载一次h5py，然后可能提示：</p>
<p>ModuleNotFoundError: No module named 'matplotlib' ， python导入'matplotlib'包报错</p>
<p>解决：https://blog.csdn.net/weixin_43670105/article/details/87911820</p>
<p>【不能解决】 UserWarning: h5py is running against HDF5 1.10.2 when it was built against 1.10.3, this may ca...<br>
https://www.jianshu.com/p/c248bbea1da7</p>
<ol start="8">
<li></li>
</ol>
<p>tensorflow版本：2.0过高怎么办？</p>
<p>解决：</p>
<p>适当回退tensorflow版本：<br>
pip install tensorflow==1.13.1</p>
<p>安装Tensorflow 2.0后的坑has no attribute 'contrib'<br>
https://blog.51cto.com/cfy10/2446977?source=dra</p>
<p>ModuleNotFoundError: No module named 'tensorflow.contrib.rnn'<br>
https://blog.csdn.net/u014742995/article/details/86496292</p>
<ol start="9">
<li></li>
</ol>
<p>提示python版本过高、冲突（tensorflow版本）怎么办？</p>
<p>conda install python=3.6</p>
<p>Anaconda中将python 3.7版本退回python 3.6版本<br>
https://blog.csdn.net/Fhujinwu/article/details/85851587</p>
<p>遇到 label xxx no image found 类问题：<br>
如 提示：</p>
<pre><code>CRITICAL:tensorflow:Label 51 has no images in the category validation.
Tensorflow - No valid folders of images found at XXXXX #10104
ERROR:tensorflow:No valid folders of images found at
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://littlebuzi.github.io//post-images/1584022703568.PNG" alt="" loading="lazy"></figure>
<p>https://github.com/tensorflow/tensorflow/issues/10104<br>
http://www.codeclip.com/4141.html</p>
<h1 id="参考文献">参考文献：</h1>
<p>https://blog.csdn.net/ZeyiRTangent/article/details/87886445</p>
<h1 id="相似推荐有助思考">相似推荐，有助思考：</h1>
<p>https://blog.csdn.net/weixin_38663832/article/details/80555341<br>
https://blog.csdn.net/EZ_guachong/article/details/90048846<br>
https://github.com/sourcedexter/tfClassifier<br>
https://stackoverflow.com/questions/45076911/tensorflow-failed-to-create-a-newwriteablefile-when-retraining-inception</p>
<h2 id="迁移学习">迁移学习</h2>
<p>https://blog.csdn.net/chaipp0607/article/details/73380390<br>
https://blog.csdn.net/Night___Raid/article/details/102975023</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TensorFlow支持的动漫人物识别网站的存储库]]></title>
        <id>https://littlebuzi.github.io/tensorflow3</id>
        <link href="https://littlebuzi.github.io/tensorflow3">
        </link>
        <updated>2020-02-15T09:22:17.000Z</updated>
        <content type="html"><![CDATA[<p>开始：<br>
在知乎上偶然阅读到这位作者的文章：https://zhuanlan.zhihu.com/p/70511070</p>
<p>参考：<br>
https://gitee.com/littlebuzi/danbooru-pretrained<br>
https://github.com/freedomofkeima/MoeFlow<br>
https://github.com/freedomofkeima/transfer-learning-anime<br>
https://github.com/nagadomi/animeface-2009<br>
https://github.com/KichangKim/DeepDanbooru/releases/tag/v1-20191108-sgd-e30</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About Download]]></title>
        <id>https://littlebuzi.github.io/download1</id>
        <link href="https://littlebuzi.github.io/download1">
        </link>
        <updated>2020-02-13T05:15:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="下载">下载</h1>
<p>https://www.4kdownload.com/zh-cn/downloads</p>
<p>https://github.com/soimort/you-get</p>
]]></content>
    </entry>
</feed>