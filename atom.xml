<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://littlebuzi.github.io/</id>
    <title>buzi</title>
    <updated>2020-06-08T17:42:50.791Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://littlebuzi.github.io/"/>
    <link rel="self" href="https://littlebuzi.github.io/atom.xml"/>
    <subtitle>记录平凡的修炼之路</subtitle>
    <logo>https://littlebuzi.github.io/images/avatar.png</logo>
    <icon>https://littlebuzi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, buzi</rights>
    <entry>
        <title type="html"><![CDATA[Minecraft服务器]]></title>
        <id>https://littlebuzi.github.io/mc_online_1</id>
        <link href="https://littlebuzi.github.io/mc_online_1">
        </link>
        <updated>2020-06-01T07:29:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1crafting-dead-我的世界行尸走肉">1.Crafting Dead 我的世界行尸走肉</h1>
<p>模组官网：<a href="http://www.craftingdead.com/"><code>http://www.craftingdead.com/</code></a><br>
模组安装：<a href="https://www.technicpack.net/modpack/official-crafting-dead-mod.41792"><code>https://www.technicpack.net/modpack/official-crafting-dead-mod.41792</code></a></p>
<h2 id="玩法">玩法：</h2>
<p>岷叔合集：<a href="https://space.bilibili.com/686127/favlist?fid=761086911&amp;ftype=collect"><code>https://space.bilibili.com/686127/favlist?fid=761086911&amp;ftype=collect</code></a></p>
<h2 id="下载教程篇">下载教程篇:</h2>
<h3 id="没有mc正版账号或者不喜欢折腾">没有mc正版账号，或者不喜欢折腾：</h3>
<p>选择以下任一网页中的帖子，进群下载客户端，即可游玩</p>
<p><a href="https://tieba.baidu.com/f?kw=%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A1%8C%E5%B0%B8%E8%B5%B0%E8%82%89"><code>https://tieba.baidu.com/f?kw=我的世界行尸走肉</code></a><br>
<a href="https://www.secretmine.net/tag/xszr-fwq/"><code>https://www.secretmine.net/tag/xszr-fwq/</code></a><br>
<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A1%8C%E5%B0%B8%E8%B5%B0%E8%82%89%E6%9C%8D%E5%8A%A1%E5%99%A8"><code>https://www.baidu.com/s?ie=UTF-8&amp;wd=我的世界行尸走肉服务器</code></a></p>
<p>单人模式：<br>
进入单人游戏，创建新地图，世界类型选择，Crafting Dead，创建世界。<br>
多人模式：<br>
进入多人模式，双击进入已经输入好的服务器或输入ip地址。</p>
<h3 id="拥有mc正版账号喜欢精致研究">拥有mc正版账号，喜欢精致研究：</h3>
<p>科技启动器下载地址：<a href="https://www.technicpack.net/"><code>https://www.technicpack.net/</code></a><br>
整合包名称：Official Crafting Dead<br>
详见：<a href="https://www.bilibili.com/video/BV1Et411b7wn"><code>https://www.bilibili.com/video/BV1Et411b7wn</code></a></p>
<p>你可能会遇到：<br>
<img src="https://littlebuzi.github.io//post-images/1591624608447.png" alt="卡顿在这一步" loading="lazy"><br>
当你下载完<code>TechnicLauncher</code>，并找到 <code>official-crafting-dead</code>，然后开始下载安装Minecraft卡住 .... ...</p>
<p>第一步：<br>
你需要点击“整合包选项”，找到以下位置：<br>
<code>C:\Users\计算机登录帐户名\AppData\Roaming\.technic\modpacks</code><br>
<img src="https://littlebuzi.github.io//post-images/1591634492347.png" alt="" loading="lazy"><br>
进入<code>official-crafting-dead-mod</code>文件夹，“复制”红框所示文件夹，粘贴到<code>“.minecraft”</code>目录下，即文件夹<code>craftingdead</code>及<code>mods</code>：<br>
<img src="https://littlebuzi.github.io//post-images/1591634858213.png" alt="" loading="lazy"><br>
此目录即“正版我的世界”游戏部分文件目录，位于“我的文档”中：<br>
<code>C:\Users\计算机登录帐户名\AppData\Roaming\.minecraft</code><br>
<img src="https://littlebuzi.github.io//post-images/1591636108250.png" alt="" loading="lazy"><br>
因为 <code>official-crafting-dead</code>启动需要<code>craftingdead</code>文件夹里的<code>craftingdead.json</code>配置及<code>mods</code>文件夹里的<code>craftingdead-1.3.5-1.6.4-obf.jar</code>核心。</p>
<p>第二步：<br>
给<code>minecraft客户端</code>打<code>forge</code>,minecraft客户端至少运行过一次1.6.4版本。<br>
可参考：<a href="https://zhidao.baidu.com/question/1605006602578485307.html"><code>https://zhidao.baidu.com/question/1605006602578485307.html</code></a><br>
或者自行访问，下载win稳定安装版：<a href="http://files.minecraftforge.net/maven/net/minecraftforge/forge/index_1.6.4.html"><code>http://files.minecraftforge.net/maven/net/minecraftforge/forge/index_1.6.4.html</code></a><br>
<img src="https://littlebuzi.github.io//post-images/1591636404651.png" alt="" loading="lazy"><br>
下载完成后，双击运行，配置以下所示：<br>
<img src="https://littlebuzi.github.io//post-images/1591636506053.png" alt="" loading="lazy"><br>
红框地址为：<code>C:\Users\计算机登录帐户名\AppData\Roaming\.minecraft</code>，与步骤1位置一致。安装完成后，打开游戏，选择对于版本启动即可。</p>
<h3 id="没有mc正版账号但喜欢折腾">没有mc正版账号，但喜欢折腾：</h3>
<p>在网络上获取到文件夹<code>craftingdead</code>及<code>mods</code>里面的文件，再准备一个“1.6.4盗版启动器”，重复上面正版操作的第二步，给现有客户端打<code>forge</code>，启动游戏，它会自动下载，最后启动成功。<br>
<img src="https://littlebuzi.github.io//post-images/1591638139009.png" alt="" loading="lazy"></p>
<hr>
<br>
<center>喜欢作者，感谢、支持作者一波，可以扫下方二维码，请小弟喝杯茶~</center>
<figure data-type="image" tabindex="1"><img src="https://littlebuzi.github.io//post-images/1591637716105.png" alt="" loading="lazy"></figure>
<center>还有疑问可直接评论回复或发送邮件到作者邮箱~</center>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拥有一个浏览器干净的主页]]></title>
        <id>https://littlebuzi.github.io/HomePage</id>
        <link href="https://littlebuzi.github.io/HomePage">
        </link>
        <updated>2020-05-31T08:20:27.000Z</updated>
        <content type="html"><![CDATA[<p>为什么要设置一个干净的主页咋就不说了，饱受其苦，<br>
那么如何设置一个干净的主页呢？主要通过设置默认主页的方式来设置</p>
<p>加载迅速简洁：<br>
百度搜索：https://m.baidu.com/?wpo=btmfast&amp;pu=sz%401321_480&amp;from=1013843a<br>
百度搜索(虽然logo是谷歌)：https://leftshine.gitee.io/viaindex/2/One/index.html<br>
https://leftshine.gitee.io/viaindex/quarklike1_43/index.html<br>
https://leftshine.gitee.io/viaindex/via-ningjing-3.5/index.html<br>
https://leftshine.gitee.io/viaindex/GoodEvening/Good%20evening.html<br>
https://leftshine.gitee.io/viaindex/Lazy_Simple/index.html<br>
https://leftshine.gitee.io/viaindex/Ya_ke+mod/index.html<br>
https://leftshine.gitee.io/viaindex/Star0726/indexDark.html<br>
樱花背景，首次加载较长：https://leftshine.gitee.io/viaindex/2/AniBg/index.html<br>
恶龙：https://leftshine.gitee.io/viaindex/2/mengmeizi/index.html<br>
超简洁：https://leftshine.gitee.io/viaindex/2/One/index.html</p>
<p>新鲜内容：<br>
https://www.zhihu.com/question/21744542/answer/292104008</p>
<p>功能强大：<br>
小呆导航：https://www.webjike.com/index.html</p>
<p>关于构想 123</p>
<ol>
<li>
<p>js jquery html</p>
</li>
<li>
<p>python pyqt exe gui</p>
</li>
<li>
<p>java gui</p>
</li>
<li></li>
</ol>
<p>js读入json<br>
输出html<br>
做出修改后<br>
js读入变量<br>
保存输出文件</p>
<p>https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js</p>
<ol start="2">
<li></li>
</ol>
<p>Python-Tkinter图形化界面设计（详细教程）：https://blog.csdn.net/RNG_uzi_/article/details/89792518</p>
<hr>
<p>参考文献：<br>
自定义简洁浏览器主页：https://www.cnblogs.com/thgpddl/p/12684475.html<br>
有哪些网站适合做浏览器主页：https://www.zhihu.com/question/21744542<br>
页面自动执行（加载）js的几种方法：https://www.cnblogs.com/2huos/p/js-autorun.html<br>
浏览器报错 CORS 请求不是 http：https://blog.csdn.net/zeduan/article/details/104165628/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP学习路线]]></title>
        <id>https://littlebuzi.github.io/learn_php</id>
        <link href="https://littlebuzi.github.io/learn_php">
        </link>
        <updated>2020-04-16T12:03:49.000Z</updated>
        <content type="html"><![CDATA[<p>免费php学习课程：<br>
https://www.imooc.com/course/list?c=php</p>
<p>PHP基础篇上、中、下（归纳编辑于）：<br>
已收录：<br>
1.PHP入门篇：https://www.imooc.com/view/54<br>
2.PHP进阶篇：https://www.imooc.com/view/26<br>
未收录：<br>
PHP7的基本变量：https://www.imooc.com/learn/1085<br>
PHP+Mysql+Ajax实现分页：https://www.imooc.com/learn/1117<br>
PHP-面向对象：https://www.imooc.com/learn/887<br>
PHP函数篇：https://www.imooc.com/learn/827<br>
PHP扩展安装指南：https://www.imooc.com/learn/757<br>
PHP进阶篇-字符串操作：https://www.imooc.com/learn/726</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP基础学习笔记(下)]]></title>
        <id>https://littlebuzi.github.io/learn_php_3</id>
        <link href="https://littlebuzi.github.io/learn_php_3">
        </link>
        <updated>2020-04-15T13:38:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-数据库">一、数据库</h2>
<h2 id="数据库操作">数据库操作</h2>
<p>PHP通过安装相应的扩展来实现数据库操作<br>
当前主流的数据库有：<br>
MsSQL，MySQL，Sybase，Db2，Oracle，PostgreSQL，Access<br>
一般情况下常说的LAMP架构指的是：<br>
Linux、Apache、Mysql、PHP</p>
<pre><code class="language-php">if (function_exists('mysql_connect')) {
    echo 'Mysql扩展已经安装';
}
</code></pre>
<h2 id="数据库扩展">数据库扩展</h2>
<p>数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。<br>
像Mysql常用的扩展有原生的mysql库，可使用增强版的mysqli扩展，或使用PDO进行连接与操作。<br>
不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。</p>
<p>mysql扩展进行数据库连接的方法：</p>
<pre><code class="language-php">$link = mysql_connect('mysql_host', 'mysql_user', 'mysql_password');
</code></pre>
<p>mysqli扩展：</p>
<pre><code class="language-php">$link = mysqli_connect('mysql_host', 'mysql_user', 'mysql_password');
</code></pre>
<p>PDO扩展：</p>
<pre><code class="language-php">$dsn = 'mysql:dbname=testdb;host=127.0.0.1';
$user = 'dbuser';
$password = 'dbpass';
$dbh = new PDO($dsn, $user, $password);
</code></pre>
<h2 id="连接mysql数据库">连接MySQL数据库</h2>
<pre><code class="language-php">指定数据库的地址，用户名及密码。
$host = 'localhost';
$user = 'code1';
$pass = '666';
$link = mysql_connect($host, $user, $pass);

选择一个操作的数据库，mysql_select_db函数选择数据库。
mysql_select_db('code1');

设置当前连接使用的字符编码，一般使用utf8编码。
mysql_query(&quot;set names 'utf8'&quot;);
</code></pre>
<h2 id="执行mysql查询">执行MySQL查询</h2>
<pre><code class="language-php">采用mysql_query加sql语句的形式向数据库发送查询指令。
$res = mysql_query('select * from user');
查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。
$row = mysql_fetch_array($res);
var_dump($row);

默认的，PHP使用最近的数据库连接执行查询，
但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。

$link1 = mysql_connect('127.0.0.1', 'code1', '');
$link2 = mysql_connect('127.0.0.1', 'code1', '', true); //开启一个新的连接
$res = mysql_query('select * from user limit 1', $link1); //从第一个连接中查询数据
</code></pre>
<h2 id="插入数据到mysql">插入数据到MySQL</h2>
<pre><code class="language-php">$sql = &quot;insert into user(name, age, class) values('李四', 18, '高三一班')&quot;;
mysql_query($sql); //执行插入语句

//或
$name = '李四';
$age = 18;
$class = '高三一班';
$sql = &quot;insert into user(name, age, class) values('$name', '$age', '$class')&quot;;
mysql_query($sql); //执行插入语句

//mysql_insert_id函数可以获取自增的主键id。
$uid = mysql_insert_id();
//可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。
</code></pre>
<h2 id="取得数据查询结果">取得数据查询结果</h2>
<p>PHP有多个函数可以获取数据集中的一行数据，最常用的是mysql_fetch_array，<br>
可以通过设定参数来更改行数据的下标，默认的会包含数字索引的下标以及字段名的关联索引下标。</p>
<pre><code class="language-php">$sql = &quot;select * from user limit 1&quot;;
$result = mysql_query($sql);
$row = mysql_fetch_array($result);
</code></pre>
<p>可以通过设定参数MYSQL_NUM只获取数字索引数组，等同于mysql_fetch_row函数，<br>
如果设定参数为MYSQL_ASSOC则只获取关联索引数组，等同于mysql_fetch_assoc函数。</p>
<pre><code class="language-php">$row = mysql_fetch_row($result);
$row = mysql_fetch_array($result, MYSQL_NUM); //这两个方法获取的数据是一样的
$row = mysql_fetch_assoc($result);
$row = mysql_fetch_array($result, MYSQL_ASSOC);
</code></pre>
<p>如果要获取数据集中的所有数据，我们通过循环来遍历整个结果集。</p>
<pre><code class="language-php">$data = array();
while ($row = mysql_fetch_array($result)) {
    $data[] = $row;
}
</code></pre>
<h2 id="查询分页数据">查询分页数据</h2>
<p>通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，要构造m与n来实现获取某一页的所有数据。</p>
<p>假定当前页为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi></mrow><annotation encoding="application/x-tex">page，每页显示</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span></span></span></span>n条数据，那么m为当前页前面所有的数据，<br>
既<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo>(</mo></mrow><annotation encoding="application/x-tex">m = (</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>page-1) * $n，通过构造SQL语句在PHP中实现数据翻页。</p>
<pre><code class="language-php">$page = 2;
$n = 2;
$m = ($page - 1) * $n;
$sql = &quot;select * from user limit $m, $n&quot;;
$result = mysql_query($sql);
//循环获取当前页的数据
$data = array();
while ($row = mysql_fetch_assoc($result)) {
    $data[] = $row;
}
</code></pre>
<p>使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi mathvariant="normal">与</mi></mrow><annotation encoding="application/x-tex">m与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">与</span></span></span></span>n变量来表示偏移量与每页数据条数，但推荐使用更有意义的变量名来表示，<br>
比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。</p>
<h2 id="更新与删除数据">更新与删除数据</h2>
<pre><code class="language-php">// 更新
$sql = &quot;update user set name = '曹操' where id=2 limit 1&quot;;
if (mysql_query($sql)) {
    echo '更新成功';
}

// 删除
$sql = &quot;delete from user where id=2 limit 1&quot;;
if (mysql_query($sql)) {
    echo '删除成功';
}

对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数，
如果数据没有变化，则结果为0。

$sql = &quot;update user set name = '曹操' where id=2 limit 1&quot;;
if (mysql_query($sql)) {
    echo mysql_affected_rows();
}
</code></pre>
<h2 id="关闭mysql连接">关闭MySQL连接</h2>
<pre><code class="language-php">mysql_close();
</code></pre>
<p>虽然PHP会自动关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下，<br>
可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。</p>
<p>在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。</p>
<pre><code class="language-php">$link = mysql_connect($host, $user, $pass);
mysql_close($link);
</code></pre>
<h1 id="phpmysqlajax实现分页">PHP+Mysql+Ajax实现分页</h1>
<p>https://www.imooc.com/learn/1117</p>
<h1 id="php环境lamplnmp安装与配置">PHP环境LAMP/LNMP安装与配置</h1>
<p>LAMP是Linux + Apache/Nginx + Mysql + PHP的简称。<br>
目前，国内外，无论一线互联网企业还是创业公司，LAMP都是Web开发的主流，以其高性能、特稳定、开源免费等特性闻名于世。</p>
<p>https://www.imooc.com/learn/703</p>
<p>扩展学习：<br>
PHP进阶篇-GD库图像处理：http://www.imooc.com/learn/701</p>
<hr>
<p>来源：慕课网，内容持续更新中...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP基础学习笔记(中)]]></title>
        <id>https://littlebuzi.github.io/learn_php_2</id>
        <link href="https://littlebuzi.github.io/learn_php_2">
        </link>
        <updated>2020-04-11T04:27:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文章是继PHP基础学习笔记（上）的下篇，主要记录php基础知识，资源整合自慕课网。</p>
</blockquote>
<hr>
<h1 id="一-数组定义">一、数组定义</h1>
<p>数组就是一个键值对组成的语言结构，键类似于酒店的房间号，值类似于酒店房间里存储的东西。</p>
<pre><code class="language-php">$arr = array();
</code></pre>
<p>表示创建一个空数组，并把创建的空数组赋值给变量$arr。</p>
<h2 id="索引数组初始化">索引数组初始化</h2>
<p>PHP有两种数组：索引数组、关联数组。<br>
索引和关联两个词都是针对数组的键而言的。</p>
<p>索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。</p>
<pre><code class="language-php">fruit
|香蕉|苹果|雪梨|
|:-|:-:|-:|
|0|1|2|

$fruit = array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;); 
print_r($fruit);
</code></pre>
<h2 id="索引数组赋值">索引数组赋值</h2>
<p>赋值有三种方式:</p>
<pre><code class="language-php">$arr[0]='苹果';
array('0'=&gt;'苹果');
$arr = array('0'=&gt;'苹果');
if( isset($arr) ) {print_r($arr);}
</code></pre>
<p>isset（） 函数是检查 括号内的是否被定义了，定义为null 也表示true。</p>
<h2 id="索引数组内容">索引数组内容</h2>
<pre><code class="language-php">$fruit = array('苹果','香蕉');
$fruit0 = $fruit['0'];
print_r($fruit0);//结果为苹果
</code></pre>
<h2 id="循环访问索引数组里的值">循环访问索引数组里的值</h2>
<pre><code class="language-php">$fruit=array('苹果','香蕉','菠萝');

// for循环
for($i=0; $i&lt;3; $i++){
    echo '&lt;br&gt;数组第'.$i.'值是：'.$fruit[$i];
}

//foreach循环
foreach($fruit as $key=&gt;$value){
    echo '&lt;br&gt;第'.$key.'值是：';
}
</code></pre>
<h2 id="关联数组初始化">关联数组初始化</h2>
<pre><code class="language-php">// 创建一个关联数组，关联数组的键“orange”，值是“橘子”
$fruit = array(
    // 关联数组赋值
    'apple'=&gt;&quot;苹果&quot;,
    'banana'=&gt;&quot;香蕉&quot;,
    'pineapple'=&gt;&quot;菠萝&quot;
); 

// 访问关联数组内容
$fruit0 = $fruit['banana'];
print_r($fruit0);

// foreach循环访问关联数组里的值
foreach($fruit as $k=&gt;$v){
    echo '&lt;br&gt;水果的英文键名：'.$k.'，对应的值是：'.$v;
</code></pre>
<h1 id="二-类和对象">二、类和对象</h1>
<p>类是面向对象程序设计的基本概念，通俗的理解类就是对现实中某一个种类的东西的抽象。<br>
如汽车可以抽象为一个类，<br>
属性：名字、轮胎、速度、重量等，<br>
操作方法：换挡、前进、后退等。</p>
<pre><code class="language-php">// 定义一个汽车类的方法为
class Car {
    $name = '汽车'; //定义属性
    function getName() { //定义方法
        return $this-&gt;name; //方法内部可以使用$this伪变量调用对象的属性或者方法
    }
}
// 类是一类东西的结构描述，而对象则是一类东西的一个具体实例，
// 例如汽车这个名词可以理解为汽车的总类，但这辆汽车则是一个具体的汽车对象。

// 对象通过new关键字进行实例化：
$car = new Car();
$car-&gt;name = '奥迪A6'; //设置对象的属性值
echo $car-&gt;getName();  //调用对象的方法 输出对象的名字

//也可以采用变量来创建
$className = 'Car';
$car = new $className();

//类与对象看起来比较相似，但实际上有本质的区别，
//类是抽象的概念，对象是具体的实例。
//类可以使程序具有可重用性。
</code></pre>
<h2 id="对象之类的属性">对象之类的属性</h2>
<p>在类中定义的变量称之为属性，<br>
通常属性跟数据库中的字段有一定的关联，因此也可以称作“字段”。<br>
属性声明是由以下关键字开头。<br>
<code>public：公开的</code><br>
<code>protected：受保护的</code><br>
<code>private：私有的</code></p>
<pre><code class="language-php">class Car {
    //定义公共属性
    public $name = '汽车';

    //定义受保护的属性
    protected $color = '白色';

    //定义私有属性
    private $price = '100000';
}
</code></pre>
<p>默认都为public，外部可以访问。<br>
一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。<br>
当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。</p>
<pre><code class="language-php">$car = new Car();
echo $car-&gt;name;   //调用对象的属性
echo $car-&gt;color;  //错误 受保护的属性不允许外部调用
echo $car-&gt;price;  //错误 私有属性不允许外部调用

受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。

class Car{
    private $price = '1000';
    public function getPrice() {
        return $this-&gt;price; //内部访问私有属性
​    }
}
</code></pre>
<h2 id="定义类的方法">定义类的方法</h2>
<p>方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，<br>
在面向过程的程序设计中function叫做<code>函数</code>，在面向对象中function则被称之为<code>方法</code>。</p>
<p>同属性一样，类的方法也具有public，protected 以及 private 的访问控制。</p>
<p>被定义为公有的类成员可以在任何地方被访问。<br>
被定义为受保护的类成员则可以被其自身以及其子类和父类访问。<br>
被定义为私有的类成员则只能被其定义所在的类访问。</p>
<pre><code class="language-php">class Car {
    public function getName() {
        return '汽车';
    }
​}
$car = new Car();
echo $car-&gt;getName();
</code></pre>
<p>使用关键字static修饰的，称之为静态方法。<br>
静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::。</p>
<pre><code class="language-php">class Car {
    public static function getName() {
        return '汽车';
    }
​}
echo Car::getName(); //结果为“汽车”

// 静态方法也可以通过变量来进行动态调用

$func = 'getSpeed';
$className = 'Car';
echo $className::$func();  //动态调用静态方法

静态方法中，$this伪变量不允许使用。
可以使用self，parent，static在内部调用静态方法与属性。

class Car {
    private static $speed = 10;
    
    public static function getSpeed() {
        return self::$speed;
    }
    
    public static function speedUp() {
        return self::$speed+=10;
    }
}
class BigCar extends Car {
    public static function start() {
        parent::speedUp();
    }
}

BigCar::start();
echo BigCar::getSpeed();

车辆加速

class Car {
    private static $speed = 10;
    
    public function getSpeed() {
        return self::$speed;
    }
    
    //在这里定义一个静态方法，实现速度累加10

public static function speedUp() {
    return self::$speed+=10;
}

}

$car = new Car();
Car::speedUp();  //调用静态方法加速
echo $car-&gt;getSpeed();  //调用共有方法输出当前的速度值
</code></pre>
<h2 id="构造函数和析构函数">构造函数和析构函数</h2>
<p>__construct()定义一个构造函数，具有构造函数的类，<br>
会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些<code>初始化工作</code>。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;构造函数被调用\n&quot;;
   }
}
$car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串
</code></pre>
<p>在子类中如果定义了__construct则不会调用父类的__construct，<br>
如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;父类构造函数被调用\n&quot;;
   }
}
class Truck extends Car {
   function __construct() {
       print &quot;子类构造函数被调用\n&quot;;
       parent::__construct();
   }
}
$car = new Truck();
</code></pre>
<p>同样，PHP5支持析构函数，使用__destruct()进行定义,<br>
析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。</p>
<pre><code class="language-php">class Car {
   function __construct() {
       print &quot;构造函数被调用 \n&quot;;
   }
   function __destruct() {
       print &quot;析构函数被调用 \n&quot;;
   }
}
$car = new Car(); //实例化时会调用构造函数
echo '使用后，准备销毁car对象 \n';
unset($car); //销毁时会调用析构函数
</code></pre>
<p>当PHP代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。</p>
<h2 id="访问控制">访问控制</h2>
<p>类属性必须定义为公有、受保护、私有之一。<br>
为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。</p>
<pre><code class="language-php">class Car {
    $speed = 10; //错误 属性必须定义访问控制
    public $name;   //定义共有属性
}
</code></pre>
<p>类中的方法可以被定义为公有、私有或受保护。<br>
如果没有设置这些关键字，则该方法默认为<code>公有</code>。</p>
<pre><code class="language-php">class Car {
​    //默认为共有方法
    function turnLeft() {
    }
}
</code></pre>
<p>如果构造函数定义成了私有方法，则不允许直接实例化对象了，<br>
这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，<br>
比如单例模式只允许有一个全局唯一的对象。</p>
<pre><code class="language-php">class Car {
    private function __construct() {
        echo 'object create';
    }

    private static $_object = null;
    public static function getInstance() {
        if (empty(self::$_object)) {
            self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象
        }
        return self::$_object;
    }
}
//$car = new Car(); //这里不允许直接实例化对象
$car = Car::getInstance(); //通过静态方法来获得一个实例
</code></pre>
<h2 id="对象继承">对象继承</h2>
<p>继承是面向对象程序设计中常用的一个特性，汽车是一个比较大的类，我们也可以称之为基类，<br>
除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，<br>
可以采用继承汽车类来共享这些属性与方法，实现代码的复用。</p>
<pre><code class="language-php">class Car {
    public $speed = 0; //汽车的起始速度是0
    
    public function speedUp() {
        $this-&gt;speed += 10;
        return $this-&gt;speed;
    }
}
//定义继承于Car的Truck类
class Truck extends Car {
    public function speedUp(){
        $this-&gt;speed = parent::speedUp() + 50;
    }
}

$car = new Truck();
$car-&gt;speedUp();
echo $car-&gt;speed;

//结果：60
</code></pre>
<h2 id="重载">重载</h2>
<p>PHP中的重载指的是<code>动态</code>的创建属性与方法，是通过魔术方法来实现的。</p>
<p>__set，对不存在属性赋值<br>
__get，对不存在属性读取<br>
__isset，判断属性是否设置<br>
__unset，销毁属性</p>
<p>方法的重载通过__call来实现，当调用不存在的方法的时候，<br>
将会转为参数调用__call方法，当调用不存在的静态方法时会使用__callStatic重载。</p>
<pre><code class="language-php">class Car {
    public $speed = 10;

    //在这里使用重载实现speedDown方法
    public function __call($name, $args) {
        if ($name == 'speedDown') {
            $this-&gt;speed -= 10;
        }
    }
}
$car = new Car();
$car-&gt;speedDown(); //调用不存在的speedDown方法
echo $car-&gt;speed;

// $name 参数是要调用的方法名称。
// $arg 参数是一个枚举数组，包含着要传递给方法 $name 的参数。
// 所有的重载方法都必须被声明为 public。
//这些魔术方法的参数都不能通过引用传递。
//属性重载只能在对象中进行。在静态方式中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。
</code></pre>
<p>详细：https://www.imooc.com/code/546</p>
<h2 id="高级特性">高级特性</h2>
<pre><code class="language-php">class Car {
    public $name = 'car';
    
    public function __clone() {
        $obj = new Car();
        $obj-&gt;name = $this-&gt;name;
    }
}
$a = new Car();
$a-&gt;name = 'new car';
$b = clone $a;
if ($a == $b) echo '==';   //true
if ($a === $b) echo '==='; //false

$str = serialize($a); //对象序列化成字符串
echo $str.'&lt;br&gt;';
$c = unserialize($str); //反序列化为对象
var_dump($c);
</code></pre>
<p>详细：https://www.imooc.com/code/547</p>
<hr>
<h1 id="三-正则表达式">三、正则表达式</h1>
<p>正则表达式是对字符串进行操作的一种逻辑公式，<br>
就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。</p>
<pre><code class="language-php">$p = '/apple/';
$str = &quot;apple banna&quot;;
if (preg_match($p, $str)) {
    echo 'matched';
}
</code></pre>
<p>其中字符串'/apple/'就是一个正则表达式，用于匹配源字符串中是否存在apple字符串。</p>
<p>PHP中使用PCRE库函数进行正则匹配，比如上例中的preg_match用于执行一个正则匹配，<br>
常用来判断一类字符模式是否存在。</p>
<h2 id="基本语法">基本语法</h2>
<p>PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：</p>
<pre><code class="language-php">/foo bar/
#^[^0-9]$#
~php~

//如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。

/http:\/\//

//如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。

$p = 'http://';
$p = '/'.preg_quote($p, '/').'/';
echo $p;

//分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，
//例如使用i修饰符可以忽略大小写匹配：

$str = &quot;Http://www.imooc.com/&quot;;
if (preg_match('/http/i', $str)) {
    echo '匹配成功';
}

// 忽略大小写匹配BBC
$p = '/bbc/i';
$str = &quot;BBC是英国的一个电视台&quot;;
if (preg_match($p, $str)) {
    echo '匹配成功';
}

</code></pre>
<h2 id="元字符与转义">元字符与转义</h2>
<p>正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有：</p>
<p>\ 一般用于转义字符<br>
^ 断言目标的开始位置(或在多行模式下是行首)<br>
$ 断言目标的结束位置(或在多行模式下是行尾)<br>
. 匹配除换行符外的任何字符(默认)<br>
[ 开始字符类定义<br>
] 结束字符类定义<br>
| 开始一个可选分支<br>
( 子组的开始标记<br>
) 子组的结束标记<br>
? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)</p>
<ul>
<li>量词，0 次或多次匹配</li>
</ul>
<ul>
<li>量词，1 次或多次匹配<br>
{ 自定义量词开始标记<br>
} 自定义量词结束标记</li>
</ul>
<p>//下面的\s匹配任意的空白符，包括空格，制表符，换行符。[<sup>\s]代表非空白符。[</sup>\s]+表示一次或多次匹配非空白符。</p>
<pre><code class="language-php">$p = '/^我[^\s]+(苹果|香蕉)$/';
$str = &quot;我喜欢吃苹果&quot;;
if (preg_match($p, $str)) {
    echo '匹配成功';
}
</code></pre>
<p>元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用，在方括号内使用的有：</p>
<p>\ 转义字符<br>
^ 仅在作为第一个字符(方括号内)时，表明字符类取反</p>
<ul>
<li>标记字符范围</li>
</ul>
<p>其中^在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号-可以标记字符范围，例如0-9表示0到9之间的所有数字。</p>
<pre><code class="language-php">//下面的\w匹配字母或数字或下划线。
$p = '/[\w\.\-]+@[a-z0-9\-]+\.(com|cn)/';
$str = &quot;我的邮箱是Spark.eric@imooc.com&quot;;
preg_match($p, $str, $match);
echo $match[0];

//匹配str中的电话
$p = '/\d+\-\d+/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0];
</code></pre>
<h2 id="贪婪模式与懒惰模式">贪婪模式与懒惰模式</h2>
<p>正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，<br>
但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。</p>
<p>贪婪模式：在可匹配与可不匹配的时候，优先匹配</p>
<pre><code class="language-php">//下面的\d表示匹配数字
$p = '/\d+\-\d+/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0]; //结果为：010-12345678
</code></pre>
<p>懒惰模式：在可匹配与可不匹配的时候，优先不匹配</p>
<pre><code class="language-php">$p = '/\d?\-\d?/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0];  //结果为：0-1
</code></pre>
<p>当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数</p>
<pre><code class="language-php">$p = '/\d{3}\-\d{8}/';
$str = &quot;我的电话是010-12345678&quot;;
preg_match($p, $str, $match);
echo $match[0]; //结果为：010-12345678
</code></pre>
<p>匹配str中的姓名</p>
<pre><code class="language-php">$p = '/name:([\w\s]+)/';
$str = &quot;name:steven jobs&quot;;
preg_match($p, $str, $match);
echo $match[1]; //结果为：steven jobs
</code></pre>
<h2 id="正则表达式匹配">正则表达式匹配</h2>
<pre><code class="language-php">//正则匹配，并输出邮箱地址,匹配email的方法还有有很多
$subject = &quot;my email is spark@imooc.com&quot;;
$pattern = '/[\w\-]+@\w+\.\w+/';
preg_match($pattern, $subject, $matches);
echo $matches[0];
</code></pre>
<p>详细：https://www.imooc.com/code/562</p>
<h2 id="查找所有匹配结果">查找所有匹配结果</h2>
<p>preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，<br>
preg_match_all可以循环获取一个列表的匹配结果数组。</p>
<pre><code class="language-php">$str = &quot;&lt;ul&gt;
            &lt;li&gt;item 1&lt;/li&gt;
            &lt;li&gt;item 2&lt;/li&gt;
        &lt;/ul&gt;&quot;;
//在这里补充代码，实现正则匹配所有li中的数据

$p = &quot;/&lt;li&gt;(.*)&lt;\/li&gt;/i&quot;;//解释下这个正则：
//后面的i表示不区分大小写，&lt;li&gt;(.*?)&lt;\/li&gt;表示li标签内的匹配的()内的值有多少，
括号内的.表示所有单字符,*表示数量为0个或者多个。也就是li标签内有字符就显示出来
preg_match_all($p, $str, $matches);
print_r($matches[1]);

结果：
Array
(
    [0] =&gt; item 1
    [1] =&gt; item 2
)
</code></pre>
<p>详细：https://www.imooc.com/code/563</p>
<h2 id="正则表达式的搜索和替换">正则表达式的搜索和替换</h2>
<pre><code class="language-php">$str = '主要有以下几个文件：index.php, style.css, common.js';
//将目标字符串$str中的文件名替换后增加em标签

$p = '/\w+\.\w+/i';
$str = preg_replace($p, '&lt;em&gt;$0&lt;/em&gt;', $str);
echo $str;
结果：
主要有以下几个文件：index.php, style.css, common.js
</code></pre>
<h2 id="常用案例">常用案例</h2>
<pre><code class="language-php">$user = array(
    'name' =&gt; 'spark1985',
    'email' =&gt; 'spark@imooc.com',
    'mobile' =&gt; '13312345678'
);
//进行一般性验证
if (empty($user)) {
    die('用户信息不能为空');
}
if (strlen($user['name']) &lt; 6) {
    die('用户名长度最少为6位');
}
//用户名必须为字母、数字与下划线
if (!preg_match('/^\w+$/i', $user['name'])) {
    die('用户名不合法');
}
//验证邮箱格式是否正确
if (!preg_match('/^[\w\.]+@\w+\.\w+$/i', $user['email'])) {
    die('邮箱不合法');
}
//手机号必须为11位数字，且为1开头
if (!preg_match('/^1\d{10}$/i', $user['mobile'])) {
    die('手机号不合法');
}
echo '用户信息验证成功';
</code></pre>
<hr>
<h1 id="四-cookie">四、cookie</h1>
<p>Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。<br>
一般情况下，Cookie通过HTTP headers从服务端返回到客户端。<br>
多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，<br>
所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。</p>
<p>PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在<code>$_COOKIE</code>的全局变量之中，因此我们可以通过<code>$_COOKIE['key']</code>的形式来读取某个Cookie值。</p>
<p>PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。</p>
<pre><code class="language-php">setcookie('test', time());
ob_start();
print_r($_COOKIE); 
$content = ob_get_contents();
$content = str_replace(&quot; &quot;, '&amp;nbsp;', $content);
ob_clean();
header(&quot;content-type:text/html; charset=utf-8&quot;);
echo '当前的Cookie为：&lt;br&gt;';
echo nl2br($content);
</code></pre>
<h2 id="设置cookie">设置cookie</h2>
<p>PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，</p>
<p>我们常用到的为前5个：</p>
<p>name（ Cookie名）可以通过$_COOKIE['name'] 进行访问<br>
value（Cookie的值）<br>
expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效<br>
path（有效路径）如果路径设置为'/'，则整个网站都有效<br>
domain（有效域）默认整个域名都有效，如果设置了'www.imooc.com',则只在www子域中有效</p>
<pre><code class="language-php">$value = 'test';
setcookie(&quot;TestCookie&quot;, $value);
setcookie(&quot;TestCookie&quot;, $value, time()+3600);  //有效期一小时
setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/path/&quot;, &quot;imooc.com&quot;); //设置路径与域
</code></pre>
<p>PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，<br>
唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。</p>
<pre><code class="language-php">setrawcookie('cookie_name', rawurlencode($value), time()+60*60*24*365); 
</code></pre>
<p>因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。</p>
<pre><code class="language-php">header(&quot;Set-Cookie:cookie_name=value&quot;);
</code></pre>
<p>设置一个名为test的Cookie</p>
<pre><code class="language-php">$value = time();
setcookie('test', $value); 
if (isset($_COOKIE['test'])) {
    echo 'success';
}
</code></pre>
<h2 id="删除与过期时间">删除与过期时间</h2>
<pre><code class="language-php">setcookie('test', time());
//在这里试着删除test的cookie值
setcookie('test', '', time()-1); 
var_dump($_COOKIE);
</code></pre>
<p>将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。<br>
之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，<br>
实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。</p>
<p>了解原理以后，我们也可以直接通过header来删除cookie。</p>
<p>header(&quot;Set-Cookie:test=1393832059; expires=&quot;.gmdate('D, d M Y H:i:s \G\M\T', time()-1));</p>
<p>这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。</p>
<h2 id="有效路径">有效路径</h2>
<p>cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为'/'，<br>
在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如：</p>
<pre><code class="language-php">setcookie('test', time(), 0, '/path');
</code></pre>
<p>上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。</p>
<p>一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，<br>
这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。</p>
<p>当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。</p>
<pre><code class="language-php">setcookie('test', '1',0, '/path');  
var_dump($_COOKIE['test']);  
</code></pre>
<h2 id="session与cookie的异同">session与cookie的异同</h2>
<p>cookie将数据存储在客户端，建立起用户与服务器之间的联系，<br>
通常可以解决很多问题，但是cookie仍然具有一些局限：</p>
<p>cookie相对不是太安全，容易被盗用导致cookie欺骗<br>
单个cookie的值最大只能存储4k<br>
每次请求都要进行网络传输，占用带宽</p>
<p>session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。</p>
<pre><code class="language-php">使用session

//先执行session_start方法开启session
session_start();
//设置一个session，然后通过全局变量$_SESSION进行session的读写
$_SESSION['test'] = time();
//显示当前的session_id
echo &quot;session_id:&quot;.session_id();
echo &quot;&lt;br&gt;&quot;;

//读取session值
echo $_SESSION['test'];
// var_dump($_SESSION);

//删除与销毁一个session
unset($_SESSION['test']);
echo &quot;&lt;br&gt;&quot;;
var_dump($_SESSION);
//如果要删除所有的session，可以使用session_destroy函数销毁当前session，
//session_destroy会删除所有数据，但是session_id仍然存在。

session_start();
$_SESSION['name'] = 'jobs';
$_SESSION['time'] = time();
session_destroy();

//session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，
//$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。

session_start();
$_SESSION['name'] = 'jobs';
$_SESSION['time'] = time();
unset($_SESSION);
session_destroy(); 
var_dump($_SESSION); //此时已为空

//如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，
//则还需要显式的调用setcookie方法删除session_id的cookie值。
</code></pre>
<p>session会自动的对要设置的值进行encode与decode，<br>
因此session可以支持任意数据类型，包括数据与对象等。</p>
<p>session_start();<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>S</mi></msub><mi>E</mi><mi>S</mi><mi>S</mi><mi>I</mi><mi>O</mi><mi>N</mi><msup><mo>[</mo><mo mathvariant="normal">′</mo></msup><mi>a</mi><mi>r</mi><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><msup><mo>(</mo><mo mathvariant="normal">′</mo></msup><mi>n</mi><mi>a</mi><mi>m</mi><msup><mi>e</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mo>&gt;</mo><mo mathvariant="normal">′</mo></msup><mi>j</mi><mi>o</mi><mi>b</mi><msup><mi>s</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">_SESSION[&#x27;ary&#x27;] = array(&#x27;name&#x27; =&gt; &#x27;jobs&#x27;);
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen"><span class="mopen">[</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mrel"><span class="mrel">&gt;</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span>_SESSION['obj'] = new stdClass();<br>
var_dump($_SESSION);<br>
默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题，</p>
<h2 id="session来存储用户的登录信息">session来存储用户的登录信息</h2>
<p>session可以用来存储多种类型的数据，因此具有很多的用途，<br>
常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。</p>
<p>用户在登录成功以后，通常可以将用户的信息存储在session中，<br>
一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。</p>
<pre><code class="language-php">$_SESSION['uid'] = $userinfo['uid'];
$_SESSION['userinfo'] = $userinfo;
</code></pre>
<p>一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，<br>
他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，<br>
同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。</p>
<pre><code class="language-php">session_start();
//假设用户登录成功获得了以下用户数据
$userinfo = array(
    'uid'  =&gt; 10000,
    'name' =&gt; 'spark',
    'email' =&gt; 'spark@imooc.com',
    'sex'  =&gt; 'man',
    'age'  =&gt; '18'
);
header(&quot;content-type:text/html; charset=utf-8&quot;);

/* 将用户信息保存到session中 */
$_SESSION['uid'] = $userinfo['uid'];
$_SESSION['name'] = $userinfo['name'];
$_SESSION['userinfo'] = $userinfo;

//* 将用户数据保存到cookie中的一个简单方法 */
$secureKey = 'imooc'; //加密密钥
$str = serialize($userinfo); //将用户信息序列化
//用户信息加密前
$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB));
//用户信息加密后
//将加密后的用户数据存储到cookie中
setcookie('userinfo', $str);

//当需要使用时进行解密
$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB);
$uinfo = unserialize($str);
echo &quot;解密后的用户信息：&lt;br&gt;&quot;;
print_r($uinfo);

结果：
解密后的用户信息：
Array
(
    [uid] =&gt; 10000
    [name] =&gt; spark
    [email] =&gt; spark@imooc.com
    [sex] =&gt; man
    [age] =&gt; 18
)
</code></pre>
<h1 id="五-文件系统">五、文件系统</h1>
<h2 id="读取文件内容">读取文件内容</h2>
<pre><code class="language-php">$content = file_get_contents('./test.txt');
// file_get_contents，可以将整个文件全部读取到一个字符串中

$content = file_get_contents('./test.txt', null, null, 100, 500);
//可通过参数控制读取内容的开始点以及长度。

echo $content;
</code></pre>
<p>PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，<br>
fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。</p>
<pre><code class="language-php">$fp = fopen('./text.txt', 'rb');
while(!feof($fp)) {
    echo fgets($fp); //读取一行
}
fclose($fp);
 
$fp = fopen('./text.txt', 'rb');
$contents = '';
while(!feof($fp)) {
    $contents .= fread($fp, 4096); //一次读取4096个字符
}
fclose($fp);
</code></pre>
<p>使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。</p>
<h2 id="判断文件是否存在">判断文件是否存在</h2>
<p>is_file与file_exists.</p>
<pre><code class="language-php">file_exists:

//判断文件是否存在，同时也可以判断目录是否存在
$filename = './test.txt';
if (file_exists($filename)) {
    echo file_get_contents($filename);
}

is_file:

//is_file是确切的判断给定的路径是否是一个文件,从函数名可以看出
$filename = './test.txt';
if (is_file($filename)) {
    echo file_get_contents($filename);
}
</code></pre>
<p>is_readable与is_writeable更加精确<br>
在文件是否存在的基础上，判断文件是否可读与可写。</p>
<pre><code class="language-php">//可写
$filename = './test.txt';
if (is_writeable($filename)) {
    file_put_contents($filename, 'test');
}
//可读
if (is_readable($filename)) {
    echo file_get_contents($filename);
}
</code></pre>
<h2 id="取得文件的修改时间">取得文件的修改时间</h2>
<p>文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。</p>
<p>fileowner：获得文件的所有者<br>
filectime：获取文件的创建时间<br>
filemtime：获取文件的修改时间<br>
fileatime：获取文件的访问时间</p>
<p>其中最常用的是文件的修改时间，通过文件的修改时间，<br>
可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">mtime = filemtime(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mopen">(</span></span></span></span>filename);<br>
echo '修改时间：'.date('Y-m-d H:i:s', filemtime($filename));</p>
<pre><code class="language-php">$filename = '/data/webroot/usercode/code/resource/test.txt';
echo '所有者：'.fileowner($filename).'&lt;br&gt;';
echo '创建时间：'.filectime($filename).'&lt;br&gt;';
echo '修改时间：'.filemtime($filename).'&lt;br&gt;';
echo '最后访问时间：'.fileatime($filename).'&lt;br&gt;';

//给$mtime赋值为文件的修改时间
$mtime = filemtime($filename);
//通过计算时间差 来判断文件内容是否有效
if (time() - $mtime &gt; 3600) {
    echo '&lt;br&gt;缓存已过期';
} else {
    echo file_get_contents($filename);
}
</code></pre>
<h2 id="取得文件的大小">取得文件的大小</h2>
<pre><code class="language-php">$filename = '/data/webroot/usercode/resource/test.txt';
echo filesize($filename);
//没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，
//因此需要通过递归的方法来循环计算目录的大小。
</code></pre>
<p>详细：https://www.imooc.com/code/578</p>
<h2 id="写入内容到文件">写入内容到文件</h2>
<pre><code class="language-php">$filename = '/data/webroot/usercode/code/test2.txt';
$fp = fopen($filename, 'w');
fwrite($fp, 'hello world'); 
fclose($fp); 

// 或者
$fp = fopen('./test.txt', 'w');
fwrite($fp, 'hello');
fwrite($fp, 'world');
fclose($fp);
</code></pre>
<h2 id="删除文件">删除文件</h2>
<p>跟Unix系统命令类似，PHP使用unlink函数进行文件删除。</p>
<pre><code class="language-php">unlink($filename);
</code></pre>
<p>删除文件夹使用rmdir函数，文件夹必须为空，如果不为空或者没有权限则会提示失败。</p>
<pre><code class="language-php">rmdir($dir);
</code></pre>
<p>如果文件夹中存在文件，可以先循环删除目录中的所有文件，然后再删除该目录，循环删除可以使用glob函数遍历所有文件。</p>
<pre><code class="language-php">foreach (glob(&quot;*&quot;) as $filename) {
   unlink($filename);
}
</code></pre>
<h1 id="六-异常处理">六、异常处理</h1>
<p>从PHP5开始，PHP支持异常处理，异常抛出之后，后面的代码将不会再被执行。<br>
当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。</p>
<pre><code class="language-php">基本语法
        try{
            //可能出现错误或异常的代码
            //catch表示捕获，Exception是php已定义好的异常类
        } catch(Exception $e){
            //对异常处理，方法：
                //1、自己处理
                //2、不处理，将其再次抛出
        }

//每一个 &quot;throw&quot; 必须对应至少一个 &quot;catch&quot;，当然可以对应多个&quot;catch&quot;
//Catch - &quot;catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象。

创建可抛出一个异常的函数
function checkNum($number){
     if($number&gt;1){
         throw new Exception(&quot;异常提示-数字必须小于等于1&quot;);
     }
     return true;
 }

//在 &quot;try&quot; 代码块中触发异常
 try{
     checkNum(2);
     //如果异常被抛出，那么下面一行代码将不会被输出
     echo '如果能看到这个提示，说明你的数字小于等于1';
 }catch(Exception $e){
     //捕获异常
     echo '捕获异常: ' .$e-&gt;getMessage();
 }

 检测文件是否存在
$filename = 'test.txt';
try {
    if (!file_exists($filename)) {
      throw new Exception('文件不存在');
    }
} catch(Exception $e) {
    echo $e-&gt;getMessage();
}
</code></pre>
<h2 id="异常处理类">异常处理类</h2>
<p>Exception具有几个基本属性与方法，其中包括了：</p>
<p>message 异常消息内容<br>
code 异常代码<br>
file 抛出异常的文件名<br>
line 抛出异常在该文件的行数</p>
<p>其中常用的方法有：</p>
<p>getTrace 获取异常追踪信息<br>
getTraceAsString 获取异常追踪信息的字符串<br>
getMessage 获取出错信息</p>
<pre><code class="language-php">class MyException extends Exception {
    function getInfo() {
        return '自定义错误信息';
    }
}

try {
    throw new MyException('error');
} catch(Exception $e) {
    echo $e-&gt;getInfo();
}
</code></pre>
<p>详细：https://www.imooc.com/code/601</p>
<h2 id="捕获异常信息">捕获异常信息</h2>
<p>在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常，<br>
抛出异常，可以保障程序的正确性与安全，避免导致不可预知的bug。</p>
<pre><code class="language-php">//一般的异常处理流程代码为：
try {
    throw new Exception('wrong');
} catch(Exception $ex) {
    echo 'Error:'.$ex-&gt;getMessage().'&lt;br&gt;';
    echo $ex-&gt;getTraceAsString().'&lt;br&gt;';
}
echo '异常处理后，继续执行其他代码';
</code></pre>
<h2 id="获取错误发生的所在行">获取错误发生的所在行</h2>
<p>在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。<br>
通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题。</p>
<pre><code class="language-php">try {
    throw new Exception('wrong');
} catch(Exception $ex) {
    $msg = 'Error:'.$ex-&gt;getMessage().&quot;\n&quot;;
    $msg.= $ex-&gt;getTraceAsString().&quot;\n&quot;;
    $msg.= '异常行号：'.$ex-&gt;getLine().&quot;\n&quot;;
    $msg.= '所在文件：'.$ex-&gt;getFile().&quot;\n&quot;;
    //将异常信息记录到日志中
 PHP异常处理之   file_put_contents('error.log', $msg);
}
</code></pre>
<p>扩展学习：<br>
PHP进阶篇-函数 ：http://www.imooc.com/learn/737<br>
PHP进阶篇-日期时间函数：http://www.imooc.com/learn/698</p>
<hr>
<p>来源：慕课网，内容持续更新中...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP基础学习笔记(上)]]></title>
        <id>https://littlebuzi.github.io/learn_php_1</id>
        <link href="https://littlebuzi.github.io/learn_php_1">
        </link>
        <updated>2020-04-07T10:02:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>学习一门新的计算机语言，对于基础基础不能丢三落四、模凌两可，这是一定要过关的。这对于以后遇到问题，能事半功倍，快人一步。不然会处处碰壁，事倍功半。假如你不是特别优秀的人，那可以选择像我一样，重复再重复吧，加油💪~</p>
</blockquote>
<hr>
<h1 id="一-符号">一、符号</h1>
<h2 id="单引号括双引号都可以用">单引号括，双引号都可以用:</h2>
<pre><code class="language-php">&lt;?php echo &quot;Hi,imooc！&quot;;?&gt;
&lt;?php echo 'Hi,imooc！';?&gt;
</code></pre>
<h2 id="连接符">连接符（.）：</h2>
<pre><code class="language-php">&lt;?php echo 'Hi,'.'imooc!';?&gt;
</code></pre>
<p>php在这一点比较特殊，其它语言中是用加号（+）来表示的，比如：JavaScirpt、Asp、C。</p>
<h2 id="结尾要加分号">结尾要加分号：</h2>
<p>（;）分号;一定在<a href="https://jingyan.baidu.com/article/c85b7a6401a3d3003bac9504.html">半角状态</a>下输入。</p>
<h2 id="注释语句">注释语句:</h2>
<pre><code class="language-php">PHP：// 注释语句
Html：&lt;!--注释语句--&gt;
CSS：/*注释语句*/
</code></pre>
<p>注释语句可以在PHP程序的任意位置（但注释语句一定要写在<?php ?>之间）。</p>
<hr>
<h1 id="二-变量">二、变量</h1>
<h2 id="定义输出">定义&amp;输出：</h2>
<pre><code class="language-php">$var_name = &quot;苹果&quot;;
$n = 10;
var_dump($var_name);
var_dump($n);
</code></pre>
<h2 id="命名规则">命名规则</h2>
<p>1.变量名必须以<a href="#">字母</a>或<a href="#">下划线 “_”</a>开头，</p>
<p><code>&quot;$_name&quot;</code>√<br>
<code>&quot;$name&quot;</code> √<br>
<code>&quot;$name2&quot;</code>√<br>
<code>&quot;$9name&quot;</code>×</p>
<p>2.由<a href="">字母</a>、<a href="">数字</a>、<a href="">“_”</a>、<a href="">汉字</a>组成。<br>
<code>&quot;$_qq&quot;</code>√<br>
<code>&quot;$qq308&quot;</code>√<br>
<code>&quot;$my_apple&quot;</code>√<br>
<code>&quot;$name我等&quot;</code> √<br>
<code>&quot;$name*&quot;</code>×  (不允许符号)<br>
<code>&quot;$666&quot;</code>×  (不允许纯数字)<br>
<code>&quot;$my apple&quot;</code>×   (不允许空格)</p>
<h2 id="格式">格式</h2>
<p>1.下划线法：<code>$my_apple</code><br>
2.驼峰命名法：<code>$myApple</code><br>
3.在PHP中变量名是区分大小写，<br>
<code>“$my_book”</code><br>
<code>“$my_Book”</code><br>
代表两个不同的变量。</p>
<h2 id="变量的数据类型">变量的数据类型</h2>
<p>php支持八种原始类型：</p>
<h2 id="1四种标量类型">1.四种标量类型：</h2>
<h2 id="boolean-布尔型">boolean 布尔型</h2>
<pre><code class="language-php">①只有两个值，一个是TRUE，另一个FALSE。即为是或否/真或假。
②不区分大小写， &quot;TRUE&quot; = &quot;true &quot;
③主要用在条件结构。
④用”echo”输出时，“true”则输出“1”，“false”不输出。
所以需要注意变量的类型，“1”可能是整型也可能是true，所以需要var_dump输出一下，
如：https://www.imooc.com/code/745
</code></pre>
<h2 id="integer-整型">integer 整型</h2>
<pre><code class="language-php">$data_int = 123;   // 十进制数  ，123
$data_int = -123;    // 一个负数  ，-123
$data_int = 0123;    // 八进制数（等于十进制的 83）  ，83
$data_int = 0x123;    // 十六进制数（等于十进制的 26）  ，291
// 十进制、八进制（数字前“0”）、十六进制（数字前“0x”）。(0是阿拉伯数字0，不是英文字母&quot;欧/o&quot;)
</code></pre>
<h2 id="float-浮点型也称double">float 浮点型（也称double）</h2>
<pre><code class="language-php">$num_float = 1.234;    //小数点  ，1.234
$num_float = 1.2e3;    //科学计数法，小写e  ，1200
$num_float = 7.0E-10;     //科学计数法，大写E ，0.007
// 支持小数点、科学计数法小写的e，大写的E表示。
</code></pre>
<h2 id="string-字符串">string (字符串)</h2>
<pre><code class="language-php">“$str_string1 = '我是字符串';”
// 字符和字节一样，所以一共有256种不同字符的可能性。
// 三种方法定义：单引号形式、双引号形式和Heredoc结构形式。

// 单双引号嵌入与转义符“\”
$str_string1 = '甲问：&quot;你在哪里学的PHP？&quot;';
$str_string2 = &quot;乙毫不犹豫地回答：'当然是慕课网咯！'&quot;;
$str_string3 = '甲问:\'能告诉我网址吗？\'';
$str_string4 = &quot;乙答道:\&quot;www.imooc.com\&quot;&quot;;

// 美元符号标识的变量与单双引号
$love = &quot;I love you!&quot;; 
$string1 = &quot;慕课网,$love&quot;;    输出：慕课网,I love you!
$string2 = '慕课网,$love';     输出：慕课网,$love

// Heredoc结构形式，很长的字符串
$string1 = &lt;&lt;&lt;GOD
我有一只小毛驴，我从来也不骑。
有一天我心血来潮，骑着去赶集。
我手里拿着小皮鞭，我心里正得意。
不知怎么哗啦啦啦啦，我摔了一身泥.
GOD;

</code></pre>
<h2 id="2两种符合类型">2.两种符合类型：</h2>
<h2 id="array-数组">array 数组</h2>
<h2 id="object-对象">object 对象</h2>
<h2 id="3特殊类型">3.特殊类型：</h2>
<h2 id="resource-资源">resource 资源</h2>
<p>资源是由专门的函数来建立和使用的，</p>
<pre><code class="language-php">// 例如打开文件、数据连接、图形画布。
$file=fopen(&quot;f.txt&quot;,&quot;r&quot;);   //打开文件
$con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);  //连接数据库
$img=imagecreate(100,100);//图形画布

// 对资源进行创建、使用和释放
$file_handle = fopen(&quot;/data/webroot/resource/php/f.txt&quot;,&quot;r&quot;);
if ($file_handle){
    //接着采用while循环（后面语言结构语句中的循环结构会详细介绍）一行行地读取文件，然后输出每行的文字
    while (!feof($file_handle)) { //判断是否到最后一行
        $line = fgets($file_handle); //读取一行文本
        echo $line; //输出一行文本
        echo &quot;&lt;br /&gt;&quot;; //换行
    }
}
fclose($file_handle);//关闭文件

// 任何资源，在不需要的时候应该被及时释放。
// 忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。

</code></pre>
<h2 id="null">null</h2>
<p>NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，<br>
①当被赋值为NULL：var1 = null;/var1 = NULL;<br>
②或者尚未被赋值：var_dump(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mn>2</mn><mo>)</mo><mo separator="true">;</mo><mi mathvariant="normal">③</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">被</mi><mi>u</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">var2);
③或者被unset()：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">③</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">被</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">：</span></span></span></span>var3 = &quot;节日快乐！&quot;;unset($var3);<br>
这三种情况下变量被认为为NULL。</p>
<h2 id="变量占用内存">变量占用内存</h2>
<pre><code class="language-php">echo $m1 = memory_get_usage(); 
// 获取当前PHP消耗的内存，结果：624432，
// 在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），分成几种数据类型。
</code></pre>
<p>详见：<a href="https://www.imooc.com/code/743">https://www.imooc.com/code/743</a></p>
<hr>
<h1 id="三-常量">三、常量</h1>
<p>常量可以理解为值不变的量（如圆周率）；<br>
或者是常量值被定义后，在脚本的其他任何地方都不可以被改变。分为自定义常量和系统常量</p>
<h2 id="自定义常量">自定义常量</h2>
<p>根据我们开发的需要，而定义的常量，它通过使用PHP中的函数define()定义。<br>
（注：函数，我们可以理解为一个混凝土搅拌机，亦或是一个筛子，通过入口提供原料，然后出口产出结果，在函数中也允许入口不提供任何数据，出口也允许不返回任何值。）</p>
<pre><code class="language-php">// define()函数的语法格式为(3个参数)：
bool define(string $constant_name, mixed $value[, $case_sensitive = true])
//“constant_name”为必选参数，常量名称,即标志符，常量的命名规则与变量的一致，但是要注意哦，它可不带美元符号哦。
//“value”为必选参数，它是常量的值。
//“case_sensitive”为可选参数，指定是否大小写敏感，设定为true表示不敏感，一般不指定第三个参数的情况下，默认第三个参数的值为false。

注：
 string表示参数类型为字符串类型，
mixed表示参数类型可以接受为多种不同的类型，
case_sensitive = true表示默认为布尔类型TRUE

如：
$p = &quot;PII&quot;;
define(&quot;PI&quot;,3.14);
define($p,3.14);
echo PI;
echo &quot;&lt;br /&gt;&quot;;
echo PII;

结果：
3.14
3.14

</code></pre>
<h2 id="常量的作用">常量的作用</h2>
<p>常量主要功效是可以避免重复定义，篡改变量值。在我们进行团队开发时，或者代码量很大的时候，对于一些第一次定义后不改变的量，如果我们使用变量，在不知情的情况下，使用同一变量名时，变量值就会被替换掉，从而会引发服务器执行错误的任务。</p>
<p>此外，使用常量还能提高代码的可维护性。如果由于某些原因，常量的值需要变更时候，我们只需要修改一个地方。例如在做计算中，起初我们取圆周率为3.14，于是很多计算中我们都使用3.14进行计算，当要求计算精度提高，圆周率需要取3.142的时候，我们不得不修改所有使用3.14的代码，倘若代码量比较多时，不仅工作量大，还可能遗漏。</p>
<h2 id="系统常量">系统常量</h2>
<p>系统常量是PHP已经定义好的常量，我们可以直接拿来使用，常见的系统常量有：</p>
<pre><code class="language-php">echo __FILE__;
// php程序文件名。它可以帮助我们获取&quot;当前文件在服务器的物理位置&quot;。

echo __LINE__;
// PHP程序文件行数。它可以告诉我们，&quot;当前代码在第几行&quot;。

echo PHP_VERSION;
// 当前解析器的版本号。可以提前知道&quot;PHP代码是否可被该PHP解析器解析&quot;。

echo PHP_OS;
// 执行当前PHP版本的操作系统名称。&quot;服务器所用的操作系统名称&quot;，可以根据该操作系统优化我们的代码。
</code></pre>
<h2 id="常量取值">常量取值</h2>
<p>获取常量值的有两种方法取值。<br>
第一种是使用常量名直接获取值；例如计算圆周率的面积：</p>
<pre><code class="language-php">define(&quot;PI&quot;,3.14);
$r=1;
$area = PI*$r*$r; //计算圆的面积
</code></pre>
<p>第二种是使用constant()函数。它和直接使用常量名输出的效果是一样的，<br>
但函数可以动态的输出不同的常量，在使用上要灵活、方便，其语法格式如下：</p>
<pre><code class="language-php">$p=&quot;&quot;;
//定义圆周率的两种取值
define(&quot;PI1&quot;,3.14);
define(&quot;PI2&quot;,3.142);
//定义值的精度
$height = &quot;中&quot;;
//根据精度返回常量名，将常量变成了一个可变的常量
if($height == &quot;中&quot;){
    $p = &quot;PI1&quot;;
}else if($height == &quot;低&quot;){
	$p = &quot;PI2&quot;;
}
$r=1;
echo $p; // 若不使用constant，输出的就是Pi1
$area= constant($p)*$r*$r;
echo $area;
</code></pre>
<p>mixed constant(string constant_name)<br>
第一个参数constant_name为要获取常量的名称，也可为存储常量名的变量。<br>
如果成功则返回常量的值，失败则提示错误信息常量没有被定义。<br>
（注：mixed表示函数返回值类型为多种不同的类型，string表示参数类型为字符串类型）</p>
<h2 id="判定常量是否被定义">判定常量是否被定义</h2>
<p>如果常量被重复定义以后，PHP解析器会发出“Constant XXX already defined”的警告，<br>
提醒我们该常量已经被定义过。在团队开发，或代码量很大的情况下，如何去判定一个常量是否被定义呢？</p>
<p>defined()函数可以帮助我们判断一个常量是否已经定义，其语法格式为：</p>
<pre><code class="language-php">define(&quot;PI1&quot;,3.14);
$p = &quot;PI1&quot;;
$is1 = defined($p);
$is2 = defined(&quot;PI2&quot;);
var_dump($is1);
var_dump($is2);
结果：
bool(true)
bool(false)

//其中，赋值给$p目的就是间接来表明PI1已经被定义，所以$is1 = defined(PI1);亦可行。

// define方法是定义一个常量的方法，返回的是该已定义的常量；
// defined方法是判断一个常量是否定义，返回的是一个bool值（true/false）。
</code></pre>
<p>bool defined(string constants_name)<br>
它只有参数constant_name，指的是要获取常量的名称，若存在则返回布尔类型true，否则返回布尔类型false; （注：bool表示函数返回值类型为布尔类型）</p>
<hr>
<h1 id="四-运算符">四、运算符</h1>
<p>分为算术运算符、赋值运算符、比较运算符、三元运算符、逻辑运算符、字符串连接运算符、错误控制运算符。</p>
<h2 id="算术运算符">算术运算符：</h2>
<p>加法运算、减法运算、乘法运算、除法运算</p>
<h2 id="赋值运算符">赋值运算符：</h2>
<p>(1)“=”：把右边表达式的值赋给左边的运算数。它将右边表达式值复制一份，交给左边的运算数。<br>
换而言之，首先给左边的运算数申请了一块内存，然后把复制的值放到这个内存中。</p>
<p>(2)“&amp;”：引用赋值，意味着两个变量都指向同一个数据。<br>
它将使两个变量共享一块内存，如果这个内存存储的数据变了，那么两个变量的值都会发生变化。</p>
<pre><code class="language-php">$a = &quot;学习PHP！&quot;;
$b = $a;
$c = &amp;$a;
$a = &quot;我天天在学习PHP！&quot;;
echo $b.&quot;&lt;br /&gt;&quot;;
echo $c.&quot;&lt;br /&gt;&quot;;

结果：
学习PHP！
我天天在学习PHP！
</code></pre>
<h2 id="比较运算符">比较运算符</h2>
<figure data-type="image" tabindex="1"><img src="https://littlebuzi.github.io//post-images/1586501035649.jpg" alt="" loading="lazy"></figure>
<h2 id="三元运算符">三元运算符</h2>
<p>(“?:”)三元运算符也是一个比较运算符，<br>
对于表达式(expr1)?(expr2):(expr3)，如果expr1的值为true，则此表达式的值为expr2，否则为expr3。</p>
<pre><code class="language-php">$a = 78;//成绩
	$b = $a &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;; 
	echo $b;

结果：及格
</code></pre>
<h2 id="逻辑运算符">逻辑运算符</h2>
<figure data-type="image" tabindex="2"><img src="https://littlebuzi.github.io//post-images/1586502150083.jpg" alt="" loading="lazy"></figure>
<p>1、逻辑与：要求所有人都投票同意，才会通过某协议；<br>
2、逻辑或：只要求一个人投票同意就行；<br>
3、逻辑异或：只能有且只能有一个人投票同意；<br>
4、逻辑非：某个人要反对，但是通过逻辑非，使其反对无效；</p>
<p>“与”和“或”有两种不同形式运算符的原因是它们运算的优先级（就是运算的有限顺序，比如我们小学的时候学习四则运算，加减乘除混合在一起啦，优先计算乘除，再计算加减）不同。</p>
<figure data-type="image" tabindex="3"><img src="https://littlebuzi.github.io//post-images/1586502214728.jpg" alt="" loading="lazy"></figure>
<h2 id="字符串连接运算符">字符串连接运算符</h2>
<p>（1）连接运算符(“.”)：它返回将右参数附加到左参数后面所得的字符串。</p>
<pre><code class="language-php">$a = &quot;张先生&quot;;
$tip = $a.&quot;,欢迎您在慕课网学习PHP！&quot;;
echo  $tip.&quot;&lt;br /&gt;&quot;;

结果：
张先生,欢迎您在慕课网学习PHP！

</code></pre>
<p>（2）连接赋值运算符(“.=”)：它将右边参数附加到左边的参数后。</p>
<pre><code class="language-php">$b = &quot;东边日出西边雨&quot;;	
$b .= &quot;,道是无晴却有晴&quot;;
$c = &quot;东边日出西边雨&quot;;	
$c = $c.&quot;,道是无晴却有晴&quot;;
echo  $b.&quot;&lt;br /&gt;&quot;;
echo  $c.&quot;&lt;br /&gt;&quot;;

结果：
东边日出西边雨,道是无晴却有晴
东边日出西边雨,道是无晴却有晴

</code></pre>
<h2 id="错误控制运算符">错误控制运算符</h2>
<p>PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉；</p>
<p>如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查。</p>
<p>需要注意的是：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。</p>
<pre><code class="language-php">$conn = @mysql_connect(&quot;localhost&quot;,&quot;username&quot;,&quot;password&quot;);
// 这样就不会报错并打印出来
</code></pre>
<h2 id="取整函数">取整函数</h2>
<p>ceil() 函数向上舍入为最接近的整数。</p>
<pre><code class="language-php">echo(ceil(0.60);
echo(ceil(0.40);
echo(ceil(5);
echo(ceil(5.1);
echo(ceil(-5.1);
echo(ceil(-5.9));

输出：
1
1
5
6
-5
-5

</code></pre>
<hr>
<h1 id="五-顺序结构">五、顺序结构</h1>
<p>顺序结构就像一条直线，按着顺序一直往下执行。我们编写的代码默认都是按照顺序结构执行的。</p>
<h2 id="条件结构">条件结构:</h2>
<h2 id="ifelse">if…else…</h2>
<pre><code class="language-php">if(条件){
     //分配服务器干的任务A
}else{
     //分配服务器干的任务B
}
</code></pre>
<h2 id="ifelse-if">if…else if…</h2>
<pre><code class="language-php">if(条件一){
     //分配服务器干的任务A
}else if(条件二){
     //分配服务器干的任务B
}
</code></pre>
<h2 id="ifelse-ifelse">if…else if…else…</h2>
<pre><code class="language-php">if(条件一){
     //分配服务器干的任务A
}else if(条件二){
     //分配服务器干的任务B
}else{
     //分配服务器干的任务C
}
</code></pre>
<p>当两个条件对立时用if…else，当两个条件不存在对立关系时用if…else if…</p>
<h2 id="switchcase">switch…case…</h2>
<pre><code class="language-php">switch (条件)
{
case 条件值一:
  //任务一
  break; 
case 条件值二:
  //任务二
  break;
default:
  //默认任务
}
</code></pre>
<p>switch…case…中的break：<br>
break的作用是结束switch，亦可以避免冗长的 “if..else if..else”代码块。</p>
<pre><code class="language-php">
//A例子
$num = 2;
$sum  = 10; 
switch($num){
    case 1:
		$sum = $sum  + 10;
		break;
	case 2:
		$sum = $sum  + 10;
		break;
 	case 3:
		$sum = $sum  + 10;
		break;
	default:
		$sum = $sum  + 10;
}
 echo &quot;A例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;;

 结果：A例子的值是：20
 // 直接查询到num为2，sum加10后即刻break，跳出查找。

//B例子
$num = 2;
$sum  = 10; 
switch($num){
	case 1:
		$sum = $sum  + 10;
	case 2:
		$sum = $sum  + 10;
	case 3:
		$sum = $sum  + 10;
	default:
		$sum = $sum  + 10;
}
 echo &quot;B例子的值是：&quot;.$sum.&quot;&lt;br /&gt;&quot;;

 结果：B例子的值是：40
//查询到num为2后，sum加10，因为没break，继续执行case3，加了10，再执行了defailt。 

</code></pre>
<h2 id="while循环语句">while循环语句</h2>
<pre><code class="language-php">while(条件){ 
     //执行任务
}
</code></pre>
<p>首先判断某个条件是否符合（条件返回值是否为TRUE），<br>
若符合则执行任务，执行完毕任务，再判断条件是否满足要求，符合则重复执行此任务，否则结束任务。</p>
<h2 id="do-while循环语句">do while循环语句</h2>
<pre><code class="language-php">do{ 
     //执行任务
}while(条件)
</code></pre>
<p>首先执行任务（while语句是先判断条件是否成立，再执行任务），执行任务完毕，判断某个条件是否符合（条件返回值是否为TRUE），若符合则再次执行任务，执行完毕任务，继续判定条件。</p>
<p>while与do…while循环语句的区别：<br>
while先判断条件是否成立，后执行循环，do...while先执行一次任务，再判断是否继续执行循环，也就是说do...while至少会执行一次任务。当条件为FALSE时，while中的任务会一次也不执行，do...while中的任务会执行1次。</p>
<h2 id="for循环语句">for循环语句</h2>
<pre><code class="language-php">for(初始化;循环条件;递增项){
      //执行任务
}

for($i = 1,$i&lt;=100;$i++){
    echo &quot;666&quot;;
}
</code></pre>
<p>for 语句中，“初始化”在循环开始前无条件求值一次，“循环条件”在每次循环开始前求值。如果值为 TRUE，则继续循环，执行循环体语句（执行任务）。如果值为 FALSE，则终止循环。“递增项”在每次循环之后被求值（执行）。其常用于循环执行代码块指定的次数。</p>
<h2 id="foreach循环语句">foreach循环语句</h2>
<p>常用于遍历数组，一般有两种使用方式:不取下标、取下标。</p>
<pre><code class="language-php">
//eg
$students = array(
'2010'=&gt;'令狐冲',
... ...
... ...
'2019'=&gt;'宁中则',
);//10个学生的学号和姓名，用数组存储

（1）只取值，不取下标

 foreach (数组 as 值){
//执行的任务
}

//使用循环结构遍历数组,获取学号和姓名  
foreach($students as  $v)
{ 
    echo $v;//输出（打印）姓名
	echo &quot;&lt;br /&gt;&quot;;
}

（2）同时取下标和值

foreach (数组 as 下标 =&gt; 值){
 //执行的任务
}

//使用循环结构遍历数组,获取学号和姓名  
foreach($students as $key =&gt;$v)
{ 
    echo $key.&quot;:&quot;.$v;//输出（打印）学号：姓名
	echo &quot;&lt;br /&gt;&quot;;
}
?&gt;

</code></pre>
<h2 id="结构嵌套">结构嵌套</h2>
<h2 id="条件嵌套">条件嵌套</h2>
<p>if里加if，</p>
<pre><code class="language-php">if (条件)
{
    if 条件成立时执行的代码;
}
elseif (条件)
{
    elseif 条件成立时执行的代码;
}
else
{
    条件不成立时执行的代码;
}
</code></pre>
<h2 id="循环嵌套">循环嵌套</h2>
<p>常用于遍历二维数组。</p>
<pre><code class="language-php">
 $students = array(
'2010'=&gt;array('令狐冲',&quot;59&quot;),
... ...
... ...
'2019'=&gt;array('宁中则',&quot;90&quot;),
);//10个学生的学号、姓名、分数，用数组存储
 
foreach($students as $key=&gt;$val)
{ //使用循环结构遍历数组,获取学号 
     echo $key; //输出学号
	 echo &quot;:&quot;;
	 //循环输出姓名和分数
    foreach($val as $v)
	{
		echo $v; 
	 }
	 echo &quot;&lt;br /&gt;&quot;;
}

</code></pre>
<p>#循环结构与条件结构嵌套</p>
<pre><code class="language-php"> $students = array(
'2010'=&gt;'令狐冲',
... ...
... ...
'2019'=&gt;'宁中则',
);//10个学生的学号和姓名，用数组存储
$query = '2014';
//使用循环结构遍历数组,获取学号和姓名
foreach($students as $key =&gt;$v)
{ 
    //使用条件结构，判断是否为该学号
	if($key == $query)
	{ 
		echo $v;//输出（打印）姓名
		break;//结束循环（跳出循环）
	}
}

</code></pre>
<p>在执行任务时，对于一些特殊的任务进行额外处理。</p>
<p>扩展学习：<br>
PHP进阶篇-字符串操作：http://www.imooc.com/learn/726</p>
<p>来源：慕课网，内容持续更新中...</p>
<hr>
<blockquote>
<p>为什么有了这么完备的“慕课网学习系统”，还要做个复制粘贴呢？<br>
1.这是一个笔记，是慕课课程的提炼，为学精一门语言而开辟的一个学习笔记文章。<br>
2.再好的学习平台，也可能会有结束的一天，所以我现在做的事情，可能可以为优秀的平台在茫茫的互联网长河中留下一点点痕迹。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[目前流行的9大前端框架]]></title>
        <id>https://littlebuzi.github.io/前端_1</id>
        <link href="https://littlebuzi.github.io/前端_1">
        </link>
        <updated>2020-03-15T09:52:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue">Vue</h1>
<p>https://cn.vuejs.org</p>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<p>php交互：<br>
https://www.cnblogs.com/cc1997/p/10522678.html<br>
[Vuejs+php] MySQL数据转JSON传值到前端</p>
<h1 id="react">React</h1>
<p>https://react.docschina.org/</p>
<p>React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>
<h1 id="angular">Angular</h1>
<p>https://angular.io</p>
<p>AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p>
<h1 id="qucikui">QucikUI</h1>
<p>http://www.uileader.com/product_quickui</p>
<p>QucikUI 4.0是一套完整的企业级web前端开发解决方案，由基础框架、UI组件库、皮肤包、示例工程和文档等组成。底层基于jquery构建。使用QucikUI 开发者可以极大地减少工作量，提高开发效率，快速构建功能强大、美观、兼容的web应用系统。</p>
<h1 id="layui">Layui</h1>
<p>https://www.layui.com/</p>
<p>layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。</p>
<p>入门：<br>
开始使用：https://www.layui.com/doc/<br>
组件：https://www.layui.com/demo/<br>
详细说明：https://www.layui.com/doc/element/layout.html</p>
<p>CDN引入：<br>
https://www.layuicdn.com/<br>
为 Layui 的广大用户提供免费的CDN静态库，非常稳定、快速、免费的 Layui开源组件项目 国内CDN加速服务</p>
<p>PHP交互：<br>
https://fly.layui.com/jie/32688/<br>
PHP后台怎么写才能使返回的数据渲染layui表格呢</p>
<h1 id="avalon">Avalon</h1>
<p>http://avalonjs.coding.me/</p>
<p>avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。</p>
<h1 id="dojo">Dojo</h1>
<p>https://dojo.io/</p>
<p>Dojo致力于实现最大的互操作性。Web组件提供了一种机制，可以在Dojo应用程序中利用非Dojo组件，并在非Dojo应用程序中轻松使用基于Dojo的小部件。Dojo为Web组件提供一流的支持。您今天做出的决定不应该将您锁定在未来的决策中。</p>
<h1 id="ember">Ember</h1>
<p>https://emberjs.com/</p>
<p>Ember.js可能是最固执己见的主流框架，这也是其最大的优势。它有创建Ember.js应用程序的正确方法，通常只有一种方法来创建应用程序。Ember.js更类似于一个产品或平台，在那里你会到一个供应商的长期支持和维护。Ember.js提供了对其平台的全面版本管理，升级工具以及对API升级的强大指导和工具。成熟，是对Ember.js的一个很好的总结。</p>
<h1 id="aurelia">Aurelia</h1>
<p>https://aurelia.io/</p>
<p>Aurelia是一个令人惊叹的框架，它在不牺牲功能的情况下采用简单而干净的代码。在本教程中，我们将通过构建“Todo”应用程序向您介绍Aurelia的简单性。您将看到应用程序代码的简洁程度，您将学习Aurelia的几个基本概念和功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch预训练的Resnet模型 Danbooru2018]]></title>
        <id>https://littlebuzi.github.io/face_4</id>
        <link href="https://littlebuzi.github.io/face_4">
        </link>
        <updated>2020-03-12T15:39:33.000Z</updated>
        <content type="html"><![CDATA[<p>原作者：https://github.com/RF5/danbooru-pretrained</p>
<h1 id="准备环境">准备环境</h1>
<p>Pytorch (&gt;1.0)</p>
<h1 id="提取图片的以下特征">提取图片的以下特征：</h1>
<figure data-type="image" tabindex="1"><img src="" alt="https://gitee.com/littlebuzi/danbooru-pretrained/raw/master/img/danbooru_resnet2.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工具网站]]></title>
        <id>https://littlebuzi.github.io/amine_reg_1</id>
        <link href="https://littlebuzi.github.io/amine_reg_1">
        </link>
        <updated>2020-03-09T10:57:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="二次元识图工具网站">二次元识图工具网站</h1>
<h2 id="httpstracemoe-找番剧网站有大量日番资源">https://trace.moe/ 找番剧网站，有大量日番资源</h2>
<p>优点：找到图片番剧后可实时预览<br>
缺点：只能识别番剧，魔改、加水印、模糊等图片不可用</p>
<h2 id="httpssaucenaocom-找画网站接入p站等数据">https://saucenao.com/ 找画网站，接入p站等数据</h2>
<p>优点：识别很多画师原创图及同人图<br>
缺点：查找结果为英文、日文、罗马音等。需要借助翻译工具</p>
<h2 id="httpswwwbaiducom-搜索引擎类百度谷歌等">https://www.baidu.com/ 搜索引擎类，百度谷歌等</h2>
<p>优点：可找的范围很广，包括但不限于：动漫、各类MV、影视剧等等，全中文<br>
缺点：结果并不是很精确需要进一步搜索，可能出现奇怪的结果</p>
<h2 id="人肉识别凉风kazedoge">人肉识别@凉风Kaze[doge]</h2>
<p>优点：快 准 狠<br>
缺点：消耗一个三连（误）</p>
<h2 id="各种搜索引擎某度某狗某歌等等">各种搜索引擎，某度，某狗，某歌等等……</h2>
<p>优点：谷歌搜索更广更专业<br>
缺点：国内没有，可尝试这个第三方国内版https://gfsoso.fcczp.com/image.html</p>
<h1 id="线上-pdf-工具">线上 PDF 工具</h1>
<h2 id="httpssmallpdfcomcn">https://smallpdf.com/cn/</h2>
<p>优点：功能一应俱全、简单好用<br>
缺点：免费次数有限</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动漫人物数据集]]></title>
        <id>https://littlebuzi.github.io/dongman_1</id>
        <link href="https://littlebuzi.github.io/dongman_1">
        </link>
        <updated>2020-03-09T10:57:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="danbooru"><a href="https://safebooru.donmai.us/">Danbooru</a> :</h1>
<blockquote>
<p>Danbooru2019：<br>
<a href="https://www.gwern.net/Danbooru2019">https://www.gwern.net/Danbooru2019</a></p>
</blockquote>
<p>A LARGE-SCALE CROWDSOURCED AND TAGGED ANIME ILLUSTRATION DATASET<br>
一个大规模的众包和标记动画插图数据集</p>
<p>Danbooru2017：<br>
https://www.gwern.net/Danbooru2019#danbooru2017</p>
<p>Danbooru2018：<br>
https://www.gwern.net/Danbooru2019#danbooru2018</p>
<h1 id="getchu"><a href="https://www.getchu.com/">Getchu</a> : (原址需科学上网访问)</h1>
<blockquote>
<p>百度云：<br>
<a href="https://pan.baidu.com/s/1bTWoEcJRzXJaMM8jELPCBA">https://pan.baidu.com/s/1bTWoEcJRzXJaMM8jELPCBA</a></p>
</blockquote>
<p>CSDN：<br>
https://blog.csdn.net/ONE_SIX_MIX/article/details/95935010</p>
<p>github 仓库：<br>
https://github.com/One-sixth/getchu_character_picture_grabber</p>
<h1 id="niconico-仅限于学术目的的图">Niconico : (仅限于学术目的的图)</h1>
<p>需要科研机构申请才可以下载。【放弃~】<br>
nico-opendata：<a href="https://nico-opendata.jp/en/index.html">https://nico-opendata.jp/en/index.html</a><br>
At Niconico, we are providing a wide variety of data from our services,<br>
to be used for academic purposes. 仅限用于学术目的。<br>
包含：<br>
Nico-Illust    超过40万张图像（插图）<br>
This dataset contains over 400,000 images (illustraions) from Niconico Seiga and Niconico Shunga.<br>
<a href="http://seiga.nicovideo.jp/">Niconico Seiga</a> is a community for posting illustrations.  一个发布插图的社区。<br>
<a href="http://seiga.nicovideo.jp/shunga/">Niconico Shunga</a> is a community for posting illustrations, where submission of explicit content is allowed. Viewers under age 18 are prohibited in this website.  本网站禁止18岁以下观众观看。</p>
<h1 id="其他">其他：</h1>
<p>IIIT-CFW<br>
https://zhuanlan.zhihu.com/p/25138563<br>
集合了各种类型的数据集（好多没见过的，感觉很全？可能有用，得再看看。），<br>
比较麻烦的就是得登陆某个网站、再用度盘下载。<br>
各领域公开数据集下载<br>
“整理了一些网上的免费数据集，分类下载地址如下，希望能节约大家找数据的时间。”</p>
<p>真实人脸：<br>
VGGFace2 : A large scale image dataset for face recognition<br>
http://www.robots.ox.ac.uk/~vgg/data/vgg_face2/index.html#about<br>
9000+身份，330w+图像</p>
]]></content>
    </entry>
</feed>